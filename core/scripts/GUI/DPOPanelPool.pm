use lib $ENV{DPO_CORE_ROOT} . "/scripts";

# generated by wxGlade 0.6.8 on Mon Sep 07 16:37:34 2015
#
# To get wxPerl visit http://wxPerl.sourceforge.net/
#

use Wx 0.15 qw[:allclasses];
use strict;
use List::MoreUtils;
use DPOUtils;
use DPOProduct;
use DPOEnvVars;
use DPOManifest;
use Archive::Zip qw( :ERROR_CODES :CONSTANTS );



package ImpactProject;

sub new
{
    my ($class,
        $project_name,
        $project_version,
        $product_version) = @_;

    my $self =
    {
        project_name => $project_name,
        project_version => $project_version,
        product_version => $product_version
    };

    bless($self, $class);

    return $self;
}

1;


package ImpactProduct;

sub new
{
    my ($class,
        $product_name,
        $flavour) = @_;

    my $self =
    {
        product_name => $product_name,
        flavour => $flavour
    };

    bless($self, $class);

    $self->{impact_projects} = [];

    return $self;
}

1;

package PackagingProductContent;

sub new
{
    my ($class,
        $product_name) = @_;

    my $self =
    {
        product_name => $product_name
    };

    bless($self, $class);

    $self->{content} = [];

    return $self;
}

1;


package DPOPanelPool;

use Wx qw[:everything];
use base qw(Wx::Panel);
use Wx::Locale 'gettext' => '_T', 'gettext_noop' => 'gettext_noop';

use constant
{
    MENU_INCLUDE => 0,
    MENU_EXCLUDE => 1
};

sub new {
    my( $self, $parent, $id, $pos, $size, $style, $name ) = @_;
    $parent = undef              unless defined $parent;
    $id     = -1                 unless defined $id;
    $pos    = wxDefaultPosition  unless defined $pos;
    $size   = wxDefaultSize      unless defined $size;
    $name   = ""                 unless defined $name;

    # begin wxGlade: DPOPanelPool::new
    $style = wxTAB_TRAVERSAL
        unless defined $style;

    $self = $self->SUPER::new( $parent, $id, $pos, $size, $style, $name );
    $self->{notebook_pool_operations} = Wx::Notebook->new($self, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
    $self->{notebook_pool_operations_activation} = Wx::Panel->new($self->{notebook_pool_operations}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{text_ctrl_current_pool_root} = Wx::TextCtrl->new($self->{notebook_pool_operations_activation}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, wxTE_READONLY);
    $self->{button_pool_switch} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Switch..."));
    $self->{button_load_pool} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Load"));
    $self->{sizer_current_pool_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Current pool (defined by DPO_POOL_ROOT)") );
    $self->{tree_ctrl_pool} = Wx::TreeCtrl->new($self->{notebook_pool_operations_activation}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_HIDE_ROOT|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{button_activation_expand_all} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Expand all"));
    $self->{button_activation_collapse_all} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Collapse all"));
    $self->{button_get_product} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("-->"));
    $self->{sizer_160_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Global") );
    $self->{combo_box_pool_products_names} = Wx::ComboBox->new($self->{notebook_pool_operations_activation}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{sizer_163_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Name") );
    $self->{combo_box_pool_products_versions} = Wx::ComboBox->new($self->{notebook_pool_operations_activation}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{sizer_164_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Version") );
    $self->{button_get_product_dependencies} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("-->"));
    $self->{sizer_161_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("According to product") );
    $self->{list_ctrl_product} = Wx::ListCtrl->new($self->{notebook_pool_operations_activation}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{button_activation_select_all} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Select all"));
    $self->{button_activation_deselect_all} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Deselect all"));
    $self->{button_activation_remove_from_list} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Remove from list"));
    $self->{button_activate} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Activate"));
    $self->{sizer_product_activation_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Product activation from DPO pool (defined by DPO_POOL_ROOT) ") );
    $self->{button_activate_project} = Wx::Button->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Activate a project..."));
    $self->{sizer_project_activation_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_activation}, wxID_ANY, _T("Project activation from DPO pool (defined by DPO_POOL_ROOT)") );
    $self->{notebook_pool_operations_packaging} = Wx::Panel->new($self->{notebook_pool_operations}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{notebook_creating_package_from} = Wx::Notebook->new($self->{notebook_pool_operations_packaging}, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
    $self->{notebook_11_pane_1} = Wx::Panel->new($self->{notebook_creating_package_from}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{text_ctrl_create_package_manifest_file} = Wx::TextCtrl->new($self->{notebook_11_pane_1}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{button_create_package_manifest_file_open} = Wx::Button->new($self->{notebook_11_pane_1}, wxID_ANY, _T("Open..."));
    $self->{sizer_135_staticbox} = Wx::StaticBox->new($self->{notebook_11_pane_1}, wxID_ANY, _T("Manifest file") );
    $self->{notebook_creating_package_from_pane_2} = Wx::Panel->new($self->{notebook_creating_package_from}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{button_packaging_load_products} = Wx::Button->new($self->{notebook_creating_package_from_pane_2}, wxID_ANY, _T("Load products"));
    $self->{combo_box_packaging_products} = Wx::ComboBox->new($self->{notebook_creating_package_from_pane_2}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{combo_box_packaging_product_versions} = Wx::ComboBox->new($self->{notebook_creating_package_from_pane_2}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{button_packaging_open_product} = Wx::Button->new($self->{notebook_creating_package_from_pane_2}, wxID_ANY, _T("Open"));
    $self->{sizer_125_staticbox} = Wx::StaticBox->new($self->{notebook_creating_package_from_pane_2}, wxID_ANY, _T("Product") );
    $self->{sizer_132_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_packaging}, wxID_ANY, _T("Creating package from...") );
    $self->{notebook_elements} = Wx::Notebook->new($self->{notebook_pool_operations_packaging}, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
    $self->{notebook_elements_pane_bin} = Wx::Panel->new($self->{notebook_elements}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{list_ctrl_lib} = Wx::ListCtrl->new($self->{notebook_elements_pane_bin}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{button_packaging_include_deep_deps} = Wx::Button->new($self->{notebook_elements_pane_bin}, wxID_ANY, _T("Include deep dependenceis"));
    $self->{notebook_elements_pane_etc} = Wx::Panel->new($self->{notebook_elements}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{list_ctrl_bin} = Wx::ListCtrl->new($self->{notebook_elements_pane_etc}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{notebook_elements_pane_var} = Wx::Panel->new($self->{notebook_elements}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{list_ctrl_etc} = Wx::ListCtrl->new($self->{notebook_elements_pane_var}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{notebook_elements_pane_doc} = Wx::Panel->new($self->{notebook_elements}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{list_ctrl_var} = Wx::ListCtrl->new($self->{notebook_elements_pane_doc}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{notebook_elements_pane_others} = Wx::Panel->new($self->{notebook_elements}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{list_ctrl_doc} = Wx::ListCtrl->new($self->{notebook_elements_pane_others}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{notebook_elements_pane_1} = Wx::Panel->new($self->{notebook_elements}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{list_ctrl_others} = Wx::ListCtrl->new($self->{notebook_elements_pane_1}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{button_pakaging_add} = Wx::Button->new($self->{notebook_pool_operations_packaging}, wxID_ANY, _T("Add..."));
    $self->{button_save_as_manifest} = Wx::Button->new($self->{notebook_pool_operations_packaging}, wxID_ANY, _T("Save manifest..."));
    $self->{button_create_package} = Wx::Button->new($self->{notebook_pool_operations_packaging}, wxID_ANY, _T("Create package..."));
    $self->{notebook_pool_operations_impact} = Wx::Panel->new($self->{notebook_pool_operations}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{text_ctrl_impact_current_pool_root} = Wx::TextCtrl->new($self->{notebook_pool_operations_impact}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{button_impact_switch} = Wx::Button->new($self->{notebook_pool_operations_impact}, wxID_ANY, _T("Switch..."));
    $self->{button_impact_load} = Wx::Button->new($self->{notebook_pool_operations_impact}, wxID_ANY, _T("Load"));
    $self->{sizer_153_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_impact}, wxID_ANY, _T("Current pool (defined by DPO_POOL_ROOT)") );
    $self->{combo_box_impact_product_name} = Wx::ComboBox->new($self->{notebook_pool_operations_impact}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{sizer_151_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_impact}, wxID_ANY, _T("Product name / flavour") );
    $self->{combo_box_impact_projects} = Wx::ComboBox->new($self->{notebook_pool_operations_impact}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{sizer_155_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_impact}, wxID_ANY, _T("Projects") );
    $self->{combo_box_impact_project_version} = Wx::ComboBox->new($self->{notebook_pool_operations_impact}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{checkbox_impact_any_version} = Wx::CheckBox->new($self->{notebook_pool_operations_impact}, wxID_ANY, _T("Any"), wxDefaultPosition, wxDefaultSize, );
    $self->{sizer_152_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_impact}, wxID_ANY, _T("Version") );
    $self->{button_impact_find} = Wx::Button->new($self->{notebook_pool_operations_impact}, wxID_ANY, _T("Find"));
    $self->{tree_ctrl_impact_dependants} = Wx::TreeCtrl->new($self->{notebook_pool_operations_impact}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{notebook_pool_operations_backup} = Wx::Panel->new($self->{notebook_pool_operations}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{combo_box_rdiff_backup} = Wx::ComboBox->new($self->{notebook_pool_operations_backup}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{button_rdiff_backup_browse} = Wx::Button->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("..."));
    $self->{sizer_141_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("rdiff-backup") );
    $self->{text_ctrl_local_pool} = Wx::TextCtrl->new($self->{notebook_pool_operations_backup}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{button_local_pool_browse} = Wx::Button->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("..."));
    $self->{sizer_137_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("Local pool directory") );
    $self->{text_ctrl_remote_pool} = Wx::TextCtrl->new($self->{notebook_pool_operations_backup}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{button_remote_pool_browse} = Wx::Button->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("..."));
    $self->{sizer_140_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("Remote pool directory") );
    $self->{button_backup_show_changes} = Wx::Button->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("Show changes"));
    $self->{list_ctrl_backup_new_local_files} = Wx::ListCtrl->new($self->{notebook_pool_operations_backup}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{button_backup_push} = Wx::Button->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("Push"));
    $self->{sizer_138_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("New local files") );
    $self->{list_ctrl_backup_new_remote_files} = Wx::ListCtrl->new($self->{notebook_pool_operations_backup}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{button_backup_pull} = Wx::Button->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("Pull"));
    $self->{sizer_139_staticbox} = Wx::StaticBox->new($self->{notebook_pool_operations_backup}, wxID_ANY, _T("New remote files") );

    $self->__set_properties();
    $self->__do_layout();

    Wx::Event::EVT_BUTTON($self, $self->{button_pool_switch}->GetId, \&on_button_pool_switch);
    Wx::Event::EVT_BUTTON($self, $self->{button_load_pool}->GetId, \&on_button_load_pool);
    Wx::Event::EVT_BUTTON($self, $self->{button_activation_expand_all}->GetId, \&on_button_activation_expand_all);
    Wx::Event::EVT_BUTTON($self, $self->{button_activation_collapse_all}->GetId, \&on_button_activation_collapse_all);
    Wx::Event::EVT_BUTTON($self, $self->{button_get_product}->GetId, \&on_button_get_product);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_pool_products_names}->GetId, \&on_combo_box_pool_products_names);
    Wx::Event::EVT_BUTTON($self, $self->{button_get_product_dependencies}->GetId, \&on_button_button_get_product_dependencies);
    Wx::Event::EVT_LIST_COL_CLICK($self, $self->{list_ctrl_product}->GetId, \&on_list_ctrl_product_col_click);
    Wx::Event::EVT_BUTTON($self, $self->{button_activation_select_all}->GetId, \&on_button_activation_select_all);
    Wx::Event::EVT_BUTTON($self, $self->{button_activation_deselect_all}->GetId, \&on_button_activation_deselect_all);
    Wx::Event::EVT_BUTTON($self, $self->{button_activation_remove_from_list}->GetId, \&on_button_activation_remove_from_list);
    Wx::Event::EVT_BUTTON($self, $self->{button_activate}->GetId, \&on_button_activate);
    Wx::Event::EVT_BUTTON($self, $self->{button_activate_project}->GetId, \&on_button_activate_project);
    Wx::Event::EVT_BUTTON($self, $self->{button_create_package_manifest_file_open}->GetId, \&on_button_create_package_manifest_file_open);
    Wx::Event::EVT_BUTTON($self, $self->{button_packaging_load_products}->GetId, \&on_button_packaging_load_products);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_packaging_products}->GetId, \&on_combo_box_packaging_products);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_packaging_product_versions}->GetId, \&on_combo_box_packaging_product_versions);
    Wx::Event::EVT_BUTTON($self, $self->{button_packaging_open_product}->GetId, \&on_button_packaging_open_product);
    Wx::Event::EVT_LIST_ITEM_RIGHT_CLICK($self, $self->{list_ctrl_lib}->GetId, \&on_list_ctrl_lib_right_click);
    Wx::Event::EVT_BUTTON($self, $self->{button_packaging_include_deep_deps}->GetId, \&on_button_packaging_include_deep_deps);
    Wx::Event::EVT_LIST_ITEM_RIGHT_CLICK($self, $self->{list_ctrl_bin}->GetId, \&on_list_ctrl_bin_right_click);
    Wx::Event::EVT_LIST_ITEM_RIGHT_CLICK($self, $self->{list_ctrl_etc}->GetId, \&on_list_ctrl_etc_right_click);
    Wx::Event::EVT_LIST_ITEM_RIGHT_CLICK($self, $self->{list_ctrl_var}->GetId, \&on_list_ctrl_var_right_click);
    Wx::Event::EVT_LIST_ITEM_RIGHT_CLICK($self, $self->{list_ctrl_doc}->GetId, \&on_list_ctrl_doc_right_click);
    Wx::Event::EVT_LIST_ITEM_RIGHT_CLICK($self, $self->{list_ctrl_others}->GetId, \&on_list_ctrl_others_right_click);
    Wx::Event::EVT_BUTTON($self, $self->{button_pakaging_add}->GetId, \&on_button_pakaging_add);
    Wx::Event::EVT_BUTTON($self, $self->{button_save_as_manifest}->GetId, \&on_button_save_as_manifest);
    Wx::Event::EVT_BUTTON($self, $self->{button_create_package}->GetId, \&on_button_create_package);
    Wx::Event::EVT_BUTTON($self, $self->{button_impact_switch}->GetId, \&on_button_impact_switch);
    Wx::Event::EVT_BUTTON($self, $self->{button_impact_load}->GetId, \&on_button_impact_load);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_impact_product_name}->GetId, \&on_combo_box_impact_product_name);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_impact_projects}->GetId, \&on_combo_box_impact_projects);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_impact_project_version}->GetId, \&on_combo_box_impact_project_version);
    Wx::Event::EVT_CHECKBOX($self, $self->{checkbox_impact_any_version}->GetId, \&on_checkbox_impact_any_version);
    Wx::Event::EVT_BUTTON($self, $self->{button_impact_find}->GetId, \&on_button_impact_find);
    Wx::Event::EVT_BUTTON($self, $self->{button_rdiff_backup_browse}->GetId, \&on_button_rdiff_backup_browse);
    Wx::Event::EVT_BUTTON($self, $self->{button_local_pool_browse}->GetId, \&on_button_local_pool_browse);
    Wx::Event::EVT_BUTTON($self, $self->{button_remote_pool_browse}->GetId, \&on_button_remote_pool_browse);
    Wx::Event::EVT_BUTTON($self, $self->{button_backup_show_changes}->GetId, \&on_button_backup_show_changes);
    Wx::Event::EVT_BUTTON($self, $self->{button_backup_push}->GetId, \&on_button_backup_push);
    Wx::Event::EVT_BUTTON($self, $self->{button_backup_pull}->GetId, \&on_button_backup_pull);

    # end wxGlade

    Wx::Event::EVT_MENU($self, MENU_EXCLUDE, \&on_menu_exclude);
    Wx::Event::EVT_MENU($self, MENU_INCLUDE, \&on_menu_include);


    $self->{list_ctrl_product_order_current_col} = 0;
    $self->{list_ctrl_product_order_col_name} = 1;
    $self->{list_ctrl_product_order_col_flavour} = 1;

    $self->{selected_products} = [];
    $self->{versions_blocks} = [];
    $self->{loaded_projects} = [];
    $self->{non_compliant_libs} = [];
    $self->{manifest_scanned} = [];
    $self->{impact_products} = [];
    $self->{product_content} = [];
    $self->{products_to_activate_dependencies} = {};

    $self->{manifest} = 0;

    my $env_var_id =  "\$(DPO_POOL_ROOT)";
    $self->{pool_path} = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$self->{pool_path}))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, ["DPO_POOL_ROOT"]);
    }

    $self->{text_ctrl_current_pool_root}->SetValue($self->{pool_path});
    $self->{text_ctrl_impact_current_pool_root}->SetValue($self->{pool_path});

    $self->create_list_ctrl_product();
    $self->create_list_lib();
    $self->create_list_bin();
    $self->create_list_etc();
    $self->create_list_var();
    $self->create_list_doc();
    $self->create_list_others();
    $self->create_list_backup_new_local();
    $self->create_list_backup_new_remote();
    $self->load_combo_box_rdiff_backup();

    $self->{button_packaging_open_product}->Enable(0);
    $self->{button_save_as_manifest}->Enable(0);
    $self->{notebook_elements}->Enable(0);
    $self->{button_pakaging_add}->Enable(0);
    $self->{button_create_package}->Enable(0);

    my $pool_dir = DPOUtils::dpo_pool_dir();
    $self->{text_ctrl_local_pool}->SetValue($pool_dir);

    $self->{combo_box_impact_product_name}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    $self->{combo_box_impact_projects}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    $self->{combo_box_impact_project_version}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));

    return $self;
}


sub __set_properties {
    my $self = shift;
    # begin wxGlade: DPOPanelPool::__set_properties
    $self->{tree_ctrl_pool}->SetMinSize(Wx::Size->new(138, 53));
    $self->{button_get_product}->SetMinSize(Wx::Size->new(75, -1));
    $self->{combo_box_pool_products_names}->SetSelection(-1);
    $self->{combo_box_pool_products_versions}->SetSelection(-1);
    $self->{combo_box_packaging_products}->SetMinSize(Wx::Size->new(200, 21));
    $self->{combo_box_packaging_products}->SetSelection(-1);
    $self->{combo_box_packaging_product_versions}->SetSelection(-1);
    $self->{combo_box_impact_product_name}->SetMinSize(Wx::Size->new(200, 21));
    $self->{combo_box_impact_product_name}->SetSelection(-1);
    $self->{combo_box_impact_projects}->SetMinSize(Wx::Size->new(200, 21));
    $self->{combo_box_impact_projects}->SetSelection(-1);
    $self->{combo_box_impact_project_version}->SetSelection(-1);
    $self->{combo_box_rdiff_backup}->SetSelection(-1);
    $self->{button_rdiff_backup_browse}->SetMinSize(Wx::Size->new(20, -1));
    $self->{button_local_pool_browse}->SetMinSize(Wx::Size->new(20, -1));
    $self->{button_remote_pool_browse}->SetMinSize(Wx::Size->new(20, -1));
    # end wxGlade
}

sub __do_layout {
    my $self = shift;
    # begin wxGlade: DPOPanelPool::__do_layout
    $self->{sizer_pool} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_136} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_139_staticbox}->Lower();
    $self->{sizer_139} = Wx::StaticBoxSizer->new($self->{sizer_139_staticbox}, wxHORIZONTAL);
    $self->{sizer_138_staticbox}->Lower();
    $self->{sizer_138} = Wx::StaticBoxSizer->new($self->{sizer_138_staticbox}, wxHORIZONTAL);
    $self->{sizer_142} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_140_staticbox}->Lower();
    $self->{sizer_140} = Wx::StaticBoxSizer->new($self->{sizer_140_staticbox}, wxHORIZONTAL);
    $self->{sizer_137_staticbox}->Lower();
    $self->{sizer_137} = Wx::StaticBoxSizer->new($self->{sizer_137_staticbox}, wxHORIZONTAL);
    $self->{sizer_141_staticbox}->Lower();
    $self->{sizer_141} = Wx::StaticBoxSizer->new($self->{sizer_141_staticbox}, wxHORIZONTAL);
    $self->{sizer_148} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_149} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_150} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_152_staticbox}->Lower();
    $self->{sizer_152} = Wx::StaticBoxSizer->new($self->{sizer_152_staticbox}, wxHORIZONTAL);
    $self->{sizer_154} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_155_staticbox}->Lower();
    $self->{sizer_155} = Wx::StaticBoxSizer->new($self->{sizer_155_staticbox}, wxHORIZONTAL);
    $self->{sizer_151_staticbox}->Lower();
    $self->{sizer_151} = Wx::StaticBoxSizer->new($self->{sizer_151_staticbox}, wxHORIZONTAL);
    $self->{sizer_153_staticbox}->Lower();
    $self->{sizer_153} = Wx::StaticBoxSizer->new($self->{sizer_153_staticbox}, wxHORIZONTAL);
    $self->{sizer_106} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_116} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_120} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_119} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_131} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_122} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_118} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_117} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_115} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_121} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_130} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_132_staticbox}->Lower();
    $self->{sizer_132} = Wx::StaticBoxSizer->new($self->{sizer_132_staticbox}, wxHORIZONTAL);
    $self->{sizer_133} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_125_staticbox}->Lower();
    $self->{sizer_125} = Wx::StaticBoxSizer->new($self->{sizer_125_staticbox}, wxHORIZONTAL);
    $self->{sizer_134} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_135_staticbox}->Lower();
    $self->{sizer_135} = Wx::StaticBoxSizer->new($self->{sizer_135_staticbox}, wxHORIZONTAL);
    $self->{sizer_activation} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_project_activation_staticbox}->Lower();
    $self->{sizer_project_activation} = Wx::StaticBoxSizer->new($self->{sizer_project_activation_staticbox}, wxVERTICAL);
    $self->{sizer_product_activation_staticbox}->Lower();
    $self->{sizer_product_activation} = Wx::StaticBoxSizer->new($self->{sizer_product_activation_staticbox}, wxVERTICAL);
    $self->{sizer_product_activation_working_trees} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_product_activation_actions} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_144} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_159} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_161_staticbox}->Lower();
    $self->{sizer_161} = Wx::StaticBoxSizer->new($self->{sizer_161_staticbox}, wxHORIZONTAL);
    $self->{sizer_162} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_164_staticbox}->Lower();
    $self->{sizer_164} = Wx::StaticBoxSizer->new($self->{sizer_164_staticbox}, wxHORIZONTAL);
    $self->{sizer_163_staticbox}->Lower();
    $self->{sizer_163} = Wx::StaticBoxSizer->new($self->{sizer_163_staticbox}, wxHORIZONTAL);
    $self->{sizer_160_staticbox}->Lower();
    $self->{sizer_160} = Wx::StaticBoxSizer->new($self->{sizer_160_staticbox}, wxHORIZONTAL);
    $self->{sizer_124} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_143} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_current_pool_staticbox}->Lower();
    $self->{sizer_current_pool} = Wx::StaticBoxSizer->new($self->{sizer_current_pool_staticbox}, wxHORIZONTAL);
    $self->{sizer_current_pool}->Add($self->{text_ctrl_current_pool_root}, 1, 0, 0);
    $self->{sizer_current_pool}->Add($self->{button_pool_switch}, 0, wxLEFT, 3);
    $self->{sizer_current_pool}->Add($self->{button_load_pool}, 0, wxLEFT, 5);
    $self->{sizer_product_activation}->Add($self->{sizer_current_pool}, 0, wxALL|wxEXPAND, 5);
    $self->{sizer_124}->Add($self->{tree_ctrl_pool}, 1, wxEXPAND, 0);
    $self->{sizer_143}->Add($self->{button_activation_expand_all}, 0, wxALL, 5);
    $self->{sizer_143}->Add($self->{button_activation_collapse_all}, 0, wxALL, 5);
    $self->{sizer_124}->Add($self->{sizer_143}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{sizer_160}->Add($self->{sizer_124}, 1, wxEXPAND, 0);
    $self->{sizer_160}->Add($self->{button_get_product}, 0, wxALL|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_159}->Add($self->{sizer_160}, 1, wxALL|wxEXPAND, 10);
    $self->{sizer_163}->Add($self->{combo_box_pool_products_names}, 1, 0, 0);
    $self->{sizer_162}->Add($self->{sizer_163}, 1, wxEXPAND, 0);
    $self->{sizer_164}->Add($self->{combo_box_pool_products_versions}, 1, 0, 0);
    $self->{sizer_162}->Add($self->{sizer_164}, 1, wxEXPAND, 0);
    $self->{sizer_161}->Add($self->{sizer_162}, 1, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_161}->Add($self->{button_get_product_dependencies}, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5);
    $self->{sizer_159}->Add($self->{sizer_161}, 0, wxALL|wxEXPAND, 10);
    $self->{sizer_product_activation_working_trees}->Add($self->{sizer_159}, 1, wxEXPAND, 0);
    $self->{sizer_144}->Add($self->{list_ctrl_product}, 1, wxEXPAND, 0);
    $self->{sizer_product_activation_working_trees}->Add($self->{sizer_144}, 1, wxEXPAND, 0);
    $self->{sizer_product_activation_actions}->Add($self->{button_activation_select_all}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{sizer_product_activation_actions}->Add($self->{button_activation_deselect_all}, 0, wxTOP|wxALIGN_CENTER_HORIZONTAL, 5);
    $self->{sizer_product_activation_actions}->Add($self->{button_activation_remove_from_list}, 0, wxTOP|wxALIGN_CENTER_HORIZONTAL, 5);
    $self->{sizer_product_activation_actions}->Add($self->{button_activate}, 0, wxTOP|wxALIGN_CENTER_HORIZONTAL, 10);
    $self->{sizer_product_activation_working_trees}->Add($self->{sizer_product_activation_actions}, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5);
    $self->{sizer_product_activation}->Add($self->{sizer_product_activation_working_trees}, 1, wxALL|wxEXPAND, 5);
    $self->{sizer_activation}->Add($self->{sizer_product_activation}, 1, wxEXPAND, 0);
    $self->{sizer_project_activation}->Add($self->{button_activate_project}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    $self->{sizer_activation}->Add($self->{sizer_project_activation}, 0, wxEXPAND, 0);
    $self->{notebook_pool_operations_activation}->SetSizer($self->{sizer_activation});
    $self->{sizer_135}->Add($self->{text_ctrl_create_package_manifest_file}, 1, 0, 0);
    $self->{sizer_135}->Add($self->{button_create_package_manifest_file_open}, 0, wxLEFT, 5);
    $self->{sizer_134}->Add($self->{sizer_135}, 1, wxALL, 10);
    $self->{notebook_11_pane_1}->SetSizer($self->{sizer_134});
    $self->{sizer_125}->Add($self->{button_packaging_load_products}, 0, 0, 0);
    $self->{sizer_125}->Add($self->{combo_box_packaging_products}, 1, wxLEFT, 3);
    $self->{sizer_125}->Add($self->{combo_box_packaging_product_versions}, 0, wxLEFT, 3);
    $self->{sizer_125}->Add($self->{button_packaging_open_product}, 0, wxLEFT, 3);
    $self->{sizer_133}->Add($self->{sizer_125}, 1, wxALL, 10);
    $self->{notebook_creating_package_from_pane_2}->SetSizer($self->{sizer_133});
    $self->{notebook_creating_package_from}->AddPage($self->{notebook_11_pane_1}, _T("Existing manifest"));
    $self->{notebook_creating_package_from}->AddPage($self->{notebook_creating_package_from_pane_2}, _T("Product defintion"));
    $self->{sizer_132}->Add($self->{notebook_creating_package_from}, 1, wxEXPAND, 0);
    $self->{sizer_106}->Add($self->{sizer_132}, 0, wxALL|wxEXPAND, 10);
    $self->{sizer_121}->Add($self->{list_ctrl_lib}, 1, wxEXPAND, 0);
    $self->{sizer_130}->Add($self->{button_packaging_include_deep_deps}, 0, 0, 0);
    $self->{sizer_121}->Add($self->{sizer_130}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    $self->{notebook_elements_pane_bin}->SetSizer($self->{sizer_121});
    $self->{sizer_115}->Add($self->{list_ctrl_bin}, 1, wxEXPAND, 0);
    $self->{notebook_elements_pane_etc}->SetSizer($self->{sizer_115});
    $self->{sizer_117}->Add($self->{list_ctrl_etc}, 1, wxEXPAND, 0);
    $self->{notebook_elements_pane_var}->SetSizer($self->{sizer_117});
    $self->{sizer_118}->Add($self->{list_ctrl_var}, 1, wxEXPAND, 0);
    $self->{notebook_elements_pane_doc}->SetSizer($self->{sizer_118});
    $self->{sizer_122}->Add($self->{list_ctrl_doc}, 1, wxEXPAND, 0);
    $self->{notebook_elements_pane_others}->SetSizer($self->{sizer_122});
    $self->{sizer_131}->Add($self->{list_ctrl_others}, 1, wxEXPAND, 0);
    $self->{notebook_elements_pane_1}->SetSizer($self->{sizer_131});
    $self->{notebook_elements}->AddPage($self->{notebook_elements_pane_bin}, _T("Lib"));
    $self->{notebook_elements}->AddPage($self->{notebook_elements_pane_etc}, _T("Bin"));
    $self->{notebook_elements}->AddPage($self->{notebook_elements_pane_var}, _T("Etc"));
    $self->{notebook_elements}->AddPage($self->{notebook_elements_pane_doc}, _T("Var"));
    $self->{notebook_elements}->AddPage($self->{notebook_elements_pane_others}, _T("Doc"));
    $self->{notebook_elements}->AddPage($self->{notebook_elements_pane_1}, _T("Others"));
    $self->{sizer_120}->Add($self->{notebook_elements}, 1, wxEXPAND, 0);
    $self->{sizer_119}->Add($self->{button_pakaging_add}, 0, 0, 0);
    $self->{sizer_120}->Add($self->{sizer_119}, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5);
    $self->{sizer_106}->Add($self->{sizer_120}, 1, wxLEFT|wxRIGHT|wxEXPAND, 10);
    $self->{sizer_116}->Add($self->{button_save_as_manifest}, 0, wxALL, 5);
    $self->{sizer_116}->Add($self->{button_create_package}, 0, wxALL, 5);
    $self->{sizer_106}->Add($self->{sizer_116}, 0, wxALIGN_CENTER_HORIZONTAL, 10);
    $self->{notebook_pool_operations_packaging}->SetSizer($self->{sizer_106});
    $self->{sizer_153}->Add($self->{text_ctrl_impact_current_pool_root}, 1, 0, 0);
    $self->{sizer_153}->Add($self->{button_impact_switch}, 0, wxLEFT, 3);
    $self->{sizer_153}->Add($self->{button_impact_load}, 0, wxLEFT, 5);
    $self->{sizer_149}->Add($self->{sizer_153}, 0, wxALL|wxEXPAND, 5);
    $self->{sizer_151}->Add($self->{combo_box_impact_product_name}, 0, 0, 0);
    $self->{sizer_150}->Add($self->{sizer_151}, 0, wxEXPAND, 0);
    $self->{sizer_155}->Add($self->{combo_box_impact_projects}, 0, 0, 0);
    $self->{sizer_154}->Add($self->{sizer_155}, 1, wxEXPAND, 0);
    $self->{sizer_150}->Add($self->{sizer_154}, 0, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_152}->Add($self->{combo_box_impact_project_version}, 0, 0, 0);
    $self->{sizer_152}->Add($self->{checkbox_impact_any_version}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 5);
    $self->{sizer_150}->Add($self->{sizer_152}, 0, wxLEFT|wxEXPAND, 10);
    $self->{sizer_150}->Add($self->{button_impact_find}, 0, wxLEFT|wxTOP|wxALIGN_CENTER_VERTICAL, 10);
    $self->{sizer_149}->Add($self->{sizer_150}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{sizer_149}->Add($self->{tree_ctrl_impact_dependants}, 1, wxALL|wxEXPAND, 10);
    $self->{sizer_148}->Add($self->{sizer_149}, 1, wxEXPAND, 0);
    $self->{notebook_pool_operations_impact}->SetSizer($self->{sizer_148});
    $self->{sizer_141}->Add($self->{combo_box_rdiff_backup}, 1, 0, 0);
    $self->{sizer_141}->Add($self->{button_rdiff_backup_browse}, 0, wxLEFT, 3);
    $self->{sizer_136}->Add($self->{sizer_141}, 0, wxEXPAND, 0);
    $self->{sizer_137}->Add($self->{text_ctrl_local_pool}, 1, 0, 0);
    $self->{sizer_137}->Add($self->{button_local_pool_browse}, 0, wxLEFT, 3);
    $self->{sizer_142}->Add($self->{sizer_137}, 1, 0, 0);
    $self->{sizer_140}->Add($self->{text_ctrl_remote_pool}, 1, 0, 0);
    $self->{sizer_140}->Add($self->{button_remote_pool_browse}, 0, wxLEFT, 3);
    $self->{sizer_142}->Add($self->{sizer_140}, 1, wxLEFT, 10);
    $self->{sizer_136}->Add($self->{sizer_142}, 0, wxEXPAND, 0);
    $self->{sizer_136}->Add($self->{button_backup_show_changes}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    $self->{sizer_138}->Add($self->{list_ctrl_backup_new_local_files}, 1, wxALL|wxEXPAND, 10);
    $self->{sizer_138}->Add($self->{button_backup_push}, 0, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_136}->Add($self->{sizer_138}, 1, wxEXPAND, 0);
    $self->{sizer_139}->Add($self->{list_ctrl_backup_new_remote_files}, 1, wxALL|wxEXPAND, 10);
    $self->{sizer_139}->Add($self->{button_backup_pull}, 0, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_136}->Add($self->{sizer_139}, 1, wxEXPAND, 0);
    $self->{notebook_pool_operations_backup}->SetSizer($self->{sizer_136});
    $self->{notebook_pool_operations}->AddPage($self->{notebook_pool_operations_activation}, _T("Activation"));
    $self->{notebook_pool_operations}->AddPage($self->{notebook_pool_operations_packaging}, _T("Packaging"));
    $self->{notebook_pool_operations}->AddPage($self->{notebook_pool_operations_impact}, _T("Impact"));
    $self->{notebook_pool_operations}->AddPage($self->{notebook_pool_operations_backup}, _T("Backup"));
    $self->{sizer_pool}->Add($self->{notebook_pool_operations}, 2, wxEXPAND, 0);
    $self->SetSizer($self->{sizer_pool});
    $self->{sizer_pool}->Fit($self);
    # end wxGlade
}

sub get_path_with_dpoproduct_xml
{
    my ($self, $parent_path, $paths_ref) = @_;

    if (-d $parent_path)
    {
        if (-f "$parent_path/DPOProduct.xml")
        {
            push(@$paths_ref, $parent_path);
            return 0;
        }

        my @content;
        if (DPOUtils::get_dir_content($parent_path, \@content))
        {
            foreach my $element (@content)
            {
                my $complete = "$parent_path/$element";
                $self->get_path_with_dpoproduct_xml($complete, $paths_ref);
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::GET_DIR_CONTENT_FAILURE, [$parent_path]);
            return 0;
        }
    }

    return 1;
}

sub fill_pool_tree_struct
{
    my ($self, $paths_ref, $node) = @_;

    foreach my $path (@$paths_ref)
    {
        my ($pool, $rest) = $path =~ /($self->{pool_path})\/(.*)/;

        $node->add($rest);
    }
}

sub fill_pool_tree
{
    my ($self, $parent_item, $node) = @_;

    my $tree_ctrl =  $self->{tree_ctrl_pool};

    foreach my $sub_node (@{$node->{nodes}})
    {
        my $new_item = $tree_ctrl->AppendItem($parent_item, $sub_node->{id});
        $self->fill_pool_tree($new_item, $sub_node);
    }

    return;
}

sub create_list_ctrl_product
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("Product");
    $col->SetWidth(130);
    $self->{list_ctrl_product}->InsertColumn(0, $col);

    $col = Wx::ListItem->new();
    $col->SetId(1);
    $col->SetText("Flavour");
    $col->SetWidth(60);
    $self->{list_ctrl_product}->InsertColumn(1, $col);

    $col = Wx::ListItem->new();
    $col->SetId(2);
    $col->SetText("Version");
    $col->SetWidth(80);
    $self->{list_ctrl_product}->InsertColumn(2, $col);
}

sub create_list_lib
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("Module");
    $col->SetWidth(1000);
    $self->{list_ctrl_lib}->InsertColumn(0, $col);
}

sub create_list_bin
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("Module");
    $col->SetWidth(1000);
    $self->{list_ctrl_bin}->InsertColumn(0, $col);
}

sub create_list_etc
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("File");
    $col->SetWidth(1000);
    $self->{list_ctrl_etc}->InsertColumn(0, $col);
}

sub create_list_var
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("File");
    $col->SetWidth(1000);
    $self->{list_ctrl_var}->InsertColumn(0, $col);
}

sub create_list_doc
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("File");
    $col->SetWidth(1000);
    $self->{list_ctrl_doc}->InsertColumn(0, $col);
}

sub create_list_others
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("File");
    $col->SetWidth(1000);
    $self->{list_ctrl_others}->InsertColumn(0, $col);
}

sub create_list_backup_new_local
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("New local files");
    $col->SetWidth(1000);
    $self->{list_ctrl_backup_new_local_files}->InsertColumn(0, $col);
}

sub create_list_backup_new_remote
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("New remote files");
    $col->SetWidth(1000);
    $self->{list_ctrl_backup_new_remote_files}->InsertColumn(0, $col);
}

sub load_combo_box_rdiff_backup
{
    my ($self) = @_;

    my $rdiff_backup_path =  "\$(DPO_CORE_ROOT)";
    if (!DPOEnvVars::expand_env_var(\$rdiff_backup_path))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$rdiff_backup_path]);
        return;
    }

    $rdiff_backup_path =~ s/\\/\//g;
    $rdiff_backup_path .= "/../external_tools/rdiff-backup";

    my @out;
    if (DPOUtils::TreeScan($rdiff_backup_path, \@out))
    {
        foreach my $elem (@out)
        {
            my $valid = 0;
            if ($^O =~ /Win/)
            {
                if ($elem =~ /\/rdiff-backup.exe$/)
                {
                    $valid = 1;
                }
            }
            else
            {
                # TO_DO: linux
            }
            if ($valid)
            {
                $self->{combo_box_rdiff_backup}->Append($elem);
            }
        }
    }

    if ($self->{combo_box_rdiff_backup}->GetCount() == 1)
    {
        $self->{combo_box_rdiff_backup}->SetSelection(0);
    }
}

sub get_products
{
    my ($self, $path, $selected_products) = @_;

    my $rc = 1;

    my $found = 0;

    my $file = "$path/DPOProduct.xml";

    if (-f $file)
    {
        my $compliant = 1;
        my $product_name;
        my $flavour;
        my $non_compliant_version;

        if ($file =~ /.*\/(.*)\/(.*)\/(\d+\.\d+\.\d+)\/DPOProduct.xml/)
        {
            # Non compliant product (DPOProduct.xml is saved in version directory)
            $compliant = 0;
            $product_name = $1;
            $flavour = $2;
            $non_compliant_version = $3;
        }
        else
        {
            ($product_name, $flavour) = $path =~ /.*\/(.*)\/(.*)/;
        }

        my $product;
        my $config_product = DPOProductConfig->new($file);
        if ($config_product)
        {
            if (!$config_product->get_product(\$product))
            {
                DPOLog::report_msg(DPOEvents::GET_PRODUCT_FAILURE, [$config_product->{product}->{name}]);
                return 0;
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::LOAD_PRODUCT_FAILURE, [$file]);
            return 0;
        }

        if ($compliant)
        {
            my $versions_log = "$path/dpo_versions.log";
            if (-f $versions_log)
            {
                my @lines;
                if (DPOUtils::get_file_lines($versions_log, \@lines))
                {
                    foreach my $line (@lines)
                    {
                        if ($line =~ /\[(\d+\.\d+\.\d+)\]/)
                        {
                            my $clone = $product->clone;
                            $clone->{xml_file} = $file;
                            $clone->{version} = $1;
                            if (!List::MoreUtils::any {"$_->{name}-$_->{flavour}-$_->{version}" eq "$clone->{name}-$clone->{flavour}-$clone->{version}"} @$selected_products)
                            {
                                push(@$selected_products, $clone);
                            }
                        }
                    }
                }
                else
                {
                    DPOLog::report_msg(DPOEvents::GET_LINES_FROM_FILE_FAILURE, [$versions_log]);
                    return 0;
                }
            }
        }
        else
        {
            if (!List::MoreUtils::any {"$_->{name}-$_->{flavour}-$_->{version}" eq "$product->{name}-$product->{flavour}-$product->{version}"} @$selected_products)
            {
                $product->{xml_file} = $file;
                push(@$selected_products, $product);
            }
        }

        $found = 1;
    }

    if (!$found)
    {
        my @content;
        if (!DPOUtils::get_dir_content($path, \@content))
        {
            DPOLog::report_msg(DPOEvents::GET_DIR_CONTENT_FAILURE, [$path]);
            return 0;
        }

        foreach my $element (@content)
        {
            my $complete = "$path/$element";

            if (-d $complete)
            {
                $rc &= $self->get_products($complete, $selected_products);
            }
        }
    }

    return $rc;
}

sub fill_list_products
{
    my ($self) = @_;

    # Init multiple hash
    my %multiple;
    foreach my $product (@{$self->{selected_products}})
    {
        $multiple{$product->{name}} = [];
    }

    foreach my $product (@{$self->{selected_products}})
    {
        my $elem = "$product->{version}/$product->{flavour}";
        if (!List::MoreUtils::any {$_ eq $elem} @{$multiple{$product->{name}}})
        {
            push(@{$multiple{$product->{name}}}, $elem);
        }
    }

    $self->{list_ctrl_product}->DeleteAllItems();

    my $i = 0;
    foreach my $product (@{$self->{selected_products}})
    {
        my $item = Wx::ListItem->new();

        $item->SetId($i);
        $item->SetText($product->{name});
        $self->{list_ctrl_product}->InsertItem( $item );
        $self->{list_ctrl_product}->SetItem($i, 1, $product->{flavour});
        $self->{list_ctrl_product}->SetItem($i, 2, $product->{version});

        if (scalar(@{$multiple{$product->{name}}}) > 1)
        {
            $self->{list_ctrl_product}->SetItemBackgroundColour($i, Wx::Colour->new(255, 255, 0));
        }

        $i++;
    }
}

sub fill_product_comboboxes
{
    my ($self, $path) = @_;

    my @products;
    if ($self->get_products($path, \@products))
    {
        foreach my $product (@products)
        {
            if (!defined($self->{products_to_activate_dependencies}->{$product->{name}}))
            {
                $self->{products_to_activate_dependencies}->{$product->{name}} = [];
            }

            push(@{$self->{products_to_activate_dependencies}->{$product->{name}}}, $product->{version});
        }

        $self->{combo_box_pool_products_names}->Clear();

        foreach my $key (keys $self->{products_to_activate_dependencies})
        {
            $self->{combo_box_pool_products_names}->Append($key);
        }
    }
}

sub sort_products
{
    my ($self) = @_;

    if ($self->{list_ctrl_product_order_current_col} == 0)
    {
        if ($self->{list_ctrl_product_order_col_name} == 0)
        {
            @{$self->{selected_products}} = sort {$b->{name} cmp $a->{name}} @{$self->{selected_products}};
        }
        else
        {
            @{$self->{selected_products}} = sort {$a->{name} cmp $b->{name}} @{$self->{selected_products}};
        }
    }
    else
    {
        if ($self->{list_ctrl_product_order_current_col} == 1)
        {
            if ($self->{list_ctrl_product_order_col_flavour} == 0)
            {
                @{$self->{selected_products}} = sort {$b->{flavour} cmp $a->{flavour}} @{$self->{selected_products}};
            }
            else
            {
                @{$self->{selected_products}} = sort {$a->{flavour} cmp $b->{flavour}} @{$self->{selected_products}};
            }
        }
    }
}

sub get_manifest_from_project
{
    my ($self, $project) = @_;

    if (List::MoreUtils::any {$_->{name} eq $project->{name}} @{$self->{manifest_scanned}})
    {
        return 1;
    }

    push(@{$self->{manifest_scanned}}, $project);

    print "get_manifest_from $project->{name}\n";

    if ($project->{dpo_compliant}->{value})
    {
        if (!$self->get_manifest_from_compliant_project($project))
        {
            # TO_DO
            print "Failed to get manifest for $project->{name}\n";
            return 0;
        }
    }
    else
    {
        if (!$self->get_manifest_from_non_compliant_project($project))
        {
            # TO_DO
            print "Failed to get manifest for $project->{name}\n";
            return 0;
        }

        # No need to check for runtime (non compliant products don't care with runtime dependencies)
    }

    # project dependencies
    foreach my $dep (@{$project->{dependencies_when_dynamic}}, @{$project->{dependencies_when_static}})
    {
        my $proj;
        if ($self->get_project($dep->{name}, \$proj))
        {
            if (!$self->get_manifest_from_project($proj))
            {
                # TO_DO
                print "Can't get manifest from $proj->{name}\n";
                return 0;
            }
        }
    }

    return 1;
}

sub get_manifest_from_runtime
{
    my ($self, $product_name, $product_flavour) = @_;

    my $product_config_file = $self->{packaging_products}->{"$product_name/$product_flavour"};
    my ($product_path) = $product_config_file =~ /(.*)\/DPOProduct\.xml/;

    my $product;
    if (!DPOProductConfig::get_product_with_name($product_name, \$product))
    {
        Wx::MessageBox("Can't load product $product_name", "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    foreach my $runtime_product_compliant (@{$product->{runtime}->{runtime_products_compliant}})
    {
        foreach my $project_dependency (@{$runtime_product_compliant->{dpo_project_dependencies}})
        {
            my $proj;
            if ($self->get_project($project_dependency->{name}, \$proj))
            {
                if (!$self->get_manifest_from_project($proj))
                {
                    # TO_DO
                    print "Can't get manifest from $proj->{name}\n";
                    return 0;
                }
            }
        }
    }

    foreach my $non_compliant_product (@{$product->{runtime}->{runtime_products_non_compliant}})
    {
        my $env_var_id =  "\$(" . uc($non_compliant_product->{name}) . "_ROOT)";
        my $product_path = $env_var_id;
        if (!DPOEnvVars::expand_env_var(\$product_path))
        {
            DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, ["$env_var_id"]);
            return 0;
        }

        foreach my $module (@{$non_compliant_product->{modules_names}})
        {
            # lib ?
            my $module_name = "$product_path/lib/$module";
            if (-e $module_name)
            {
                if (!List::MoreUtils::any {$_->{name} eq $module_name} @{$self->{manifest}->{lib}})
                {
                    push(@{$self->{manifest}->{lib}}, QualifiedManifestFile->new($module_name));
                }
            }

            # bin ?
            $module_name = "$product_path/bin/$module";
            if (-e $module_name)
            {
                if (!List::MoreUtils::any {$_->{name} eq $module_name} @{$self->{manifest}->{bin}})
                {
                    push(@{$self->{manifest}->{bin}}, QualifiedManifestFile->new($module_name));
                }
            }
        }
    }

    return 1;
}

sub get_manifest_from_path
{
    my ($self, $path, $src, $sub) = @_;

    my $complete_path;
    if (defined($sub)
        && $sub == 1)
    {
        $complete_path = $path;
    }
    else
    {
        $complete_path = "$path/$src";
    }

    my @content;
    if (-d $complete_path)
    {
        if (DPOUtils::get_dir_content($complete_path, \@content))
        {
            foreach my $elem (@content)
            {
                my $complete = "$complete_path/$elem";

                if (-d $complete)
                {
                    if (!$self->get_manifest_from_path($complete, $src, 1))
                    {
                        return 0;
                    }
                }
                else
                {
                    if ($src eq "lib")
                    {
                        if (!List::MoreUtils::any {$_->{name} eq $complete} @{$self->{manifest}->{lib}})
                        {
                            if ($^O =~ /Win/)
                            {
                                if ($elem !~ /\.lib$/)
                                {
                                    push(@{$self->{manifest}->{lib}}, QualifiedManifestFile->new($complete));
                                }
                            }
                            else
                            {
                                push(@{$self->{manifest}->{lib}}, QualifiedManifestFile->new($complete));
                            }
                        }
                    }

                    if ($src eq "bin")
                    {
                        if (!List::MoreUtils::any {$_->{name} eq $complete} @{$self->{manifest}->{bin}})
                        {
                            push(@{$self->{manifest}->{bin}}, QualifiedManifestFile->new($complete));
                        }
                    }

                    if ($src eq "etc")
                    {
                        if (!List::MoreUtils::any {$_->{name} eq $complete} @{$self->{manifest}->{etc}})
                        {
                            push(@{$self->{manifest}->{etc}}, QualifiedManifestFile->new($complete));
                        }
                    }

                    if ($src eq "var")
                    {
                        if (!List::MoreUtils::any {$_->{name} eq $complete} @{$self->{manifest}->{var}})
                        {
                            push(@{$self->{manifest}->{var}}, QualifiedManifestFile->new($complete));
                        }
                    }

                    if ($src eq "doc")
                    {
                        if (!List::MoreUtils::any {$_->{name} eq $complete} @{$self->{manifest}->{doc}})
                        {
                            push(@{$self->{manifest}->{doc}}, QualifiedManifestFile->new($complete));
                        }
                    }
                }
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::GET_DIR_CONTENT_FAILURE, [$complete_path]);
            return 0;
        }
    }

    return 1;
}

sub extract_dpoproject_xml_paths
{
    my ($self, $product_path, $dpoproject_xml_paths) = @_;

    my @content;
    if (!DPOUtils::get_dir_content("$product_path/modules", \@content))
    {
        DPOLog::report_msg(DPOEvents::GET_DIR_CONTENT_FAILURE, ["$product_path/modules"]);
        return 0;
    }

    foreach my $project_dir (@content)
    {
        my @versions_dirs;
        if (!DPOUtils::get_dir_content("$product_path/modules/$project_dir", \@versions_dirs))
        {
            DPOLog::report_msg(DPOEvents::GET_DIR_CONTENT_FAILURE, ["$product_path/modules/$project_dir"]);
            return 0;
        }

        foreach my $version_dir (@versions_dirs)
        {
            my $file = "$product_path/modules/$project_dir/$version_dir/DPOProject.xml";

            if (-e $file)
            {
                push($dpoproject_xml_paths, "$product_path/modules/$project_dir/$version_dir");
            }
            else
            {
                DPOLog::report_msg(DPOEvents::FILE_DOESNT_EXIST, [$file]);
                return 0;
            }
        }
    }

    return 1;
}

sub get_manifest_from_compliant_project
{
    my ($self, $project) = @_;

    my $product_name = $project->{dpo_compliant}->{product_name};
    my $flavour = $project->{dpo_compliant}->{product_flavour};

    my $product_xml = $self->{packaging_products}->{"$product_name/$flavour"};

    if (!defined($product_xml))
    {
        Wx::MessageBox("$product_name/$flavour is not in the pool");
        return 0;
    }
    else
    {
        #~ print "project product: $product_name/$flavour: use $product_xml\n";
    }

    my ($product_path) = $product_xml =~ /(.*)\/DPOProduct\.xml/;

    my $path = "$product_path/modules/$project->{name}/$project->{version}";

    # Fill manifest from lib, bin, etc, var doc directories
    if (!$self->get_manifest_from_path($path, "lib"))
    {
        # TO_DO
        return 0;
    }

    if (!$self->get_manifest_from_path($path, "bin"))
    {
        # TO_DO
        return 0;
    }

    if (!$self->get_manifest_from_path($path, "etc"))
    {
        # TO_DO
        return 0;
    }

    if (!$self->get_manifest_from_path($path, "var"))
    {
        # TO_DO
        return 0;
    }

    if (!$self->get_manifest_from_path($path, "doc"))
    {
        # TO_DO
        return 0;
    }

    if (!$self->get_manifest_from_runtime(
                    $project->{dpo_compliant}->{product_name},
                    $project->{dpo_compliant}->{product_flavour}))
    {
        # TO_DO
        return 0;
    }

    return 1;
}

sub get_manifest_from_non_compliant_project
{
    my ($self, $project) = @_;

    my $lib_id = $project->{name};
    my $product_name = $project->{dpo_compliant}->{product_name};

    if (List::MoreUtils::any {$_ eq $lib_id} @{$self->{non_compliant_libs}})
    {
        return 1;
    }

    push(@{$self->{non_compliant_libs}}, $lib_id);

    print "get_manifest_from_non_compliant_project: $lib_id\n";

    if (!List::MoreUtils::any {$_->{product_name} eq $product_name} @{$self->{product_content}})
    {
        my $env_var_id =  "\$(" . uc($product_name) . "_ROOT)";
        my $product_path = $env_var_id;
        if (!DPOEnvVars::expand_env_var(\$product_path))
        {
            DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, ["$env_var_id"]);
            return 0;
        }

        my @content;
        if (DPOUtils::TreeScan($product_path, \@content))
        {
            my $product_content = PackagingProductContent->new($product_name);
            $product_content->{content} = \@content;
            push(@{$self->{product_content}}, $product_content);
        }
        else
        {
            # TO_DO
            print "Can't get content of $product_name (TreeScan)\n";
            return 0;
        }
    }

    my $product;
    if (DPOProductConfig::get_product_with_name($product_name, \$product))
    {
        foreach my $non_compliant_lib (@{$product->{dpo_compliant_product}->{non_compliant_lib_seq}})
        {
            if ($non_compliant_lib->{lib_id} eq $lib_id)
            {
                if ($non_compliant_lib->{dynamic_debug_dll} ne "")
                {
                    my $path_of_lib;
                    if ($self->get_path_of_lib($product_name, $non_compliant_lib->{dynamic_debug_dll}, \$path_of_lib))
                    {
                        push(@{$self->{manifest}->{lib}}, QualifiedManifestFile->new("$path_of_lib/$non_compliant_lib->{dynamic_debug_dll}"));
                    }
                    else
                    {
                        # TO_DO
                        print "path of $non_compliant_lib->{dynamic_debug_dll} not found\n";
                        return 0;
                    }
                }
                if ($non_compliant_lib->{dynamic_release_dll} ne "")
                {
                    my $path_of_lib;
                    if ($self->get_path_of_lib($product_name, $non_compliant_lib->{dynamic_release_dll}, \$path_of_lib))
                    {
                        push(@{$self->{manifest}->{lib}}, QualifiedManifestFile->new("$path_of_lib/$non_compliant_lib->{dynamic_release_dll}"));
                    }
                    else
                    {
                        # TO_DO
                        print "path of $non_compliant_lib->{dynamic_release_dll} not found\n";
                        return 0;
                    }
                }
            }
        }
    }
    else
    {
        #TO_DO
        print "Can't get product of $product_name\n";
        return 0;
    }

    return 1;
}

sub load_relevant_project
{
    my ($self, $relevant_project, $dpoproject_xml_paths_ref, $project_ref) = @_;

    my $project_name = $relevant_project->{project_name};
    my $project_version = $relevant_project->{version};

    foreach my $path (@$dpoproject_xml_paths_ref)
    {
        my ($proj_name, $proj_version) = $path =~ /.*\/(.*)\/(.*)$/;
        if ("$proj_name-$proj_version" eq "$project_name-$project_version")
        {
            $$project_ref = 0;

            foreach my $proj (@{$self->{loaded_projects}})
            {
                if ("$proj->{name}-$proj->{version}" eq "$project_name-$project_version")
                {
                    $$project_ref = $proj;
                    last;
                }
            }

            if ($$project_ref == 0)
            {
                my $file = "$path/DPOProject.xml";

                if (-f $file)
                {
                    my $err;
                    my $config = DPOProjectConfig->new($file, \$err);
                    if ($config)
                    {
                        if ($config->get_project($project_ref))
                        {
                            if (!List::MoreUtils::any {"$_->{name}" eq "$$project_ref->{name}"} @{$self->{loaded_projects}})
                            {
                                push(@{$self->{loaded_projects}}, $$project_ref);
                            }
                        }
                        else
                        {
                            DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_name]);
                            return 0;
                        }
                    }
                    else
                    {
                        DPOLog::report_msg(DPOEvents::LOAD_PROJECT_FAILURE, [$file, $err]);
                        return 0;
                    }
                }
                else
                {
                    DPOLog::report_msg(DPOEvents::FILE_DOESNT_EXIST, [$file]);
                    return 0;
                }
            }

            last;
        }
    }

    return 1;
}


sub fill_list_ctrl_with_manifest
{
    my ($self) = @_;

    $self->{list_ctrl_lib}->DeleteAllItems();
    $self->{list_ctrl_bin}->DeleteAllItems();
    $self->{list_ctrl_etc}->DeleteAllItems();
    $self->{list_ctrl_var}->DeleteAllItems();
    $self->{list_ctrl_doc}->DeleteAllItems();
    $self->{list_ctrl_others}->DeleteAllItems();

    my $i = 0;
    foreach my $elem (sort {$a->{name} cmp $b->{name}} @{$self->{manifest}->{lib}})
    {
        my $item = Wx::ListItem->new();
        $item->SetId($i);
        $item->SetText($elem->{name});
        $self->{list_ctrl_lib}->InsertItem( $item );

        if ($elem->{status} eq "exclude")
        {
            $self->{list_ctrl_lib}->SetItemBackgroundColour($i, Wx::Colour->new(200, 200, 200));
        }

        unless (-f $elem->{name})
        {
            $self->{list_ctrl_lib}->SetItemBackgroundColour($i, Wx::Colour->new(255, 0, 0));
            $self->{list_ctrl_lib}->SetItemTextColour($i, Wx::Colour->new(255, 255, 255));
        }
        $i++;
    }

    foreach my $elem (sort {$a->{name} cmp $b->{name}} @{$self->{manifest}->{bin}})
    {
        my $item = Wx::ListItem->new();
        $item->SetId($i);
        $item->SetText($elem->{name});
        $self->{list_ctrl_bin}->InsertItem( $item );

        if ($elem->{status} eq "exclude")
        {
            $self->{list_ctrl_lib}->SetItemBackgroundColour($i, Wx::Colour->new(200, 200, 200));
        }

        unless (-f $elem->{name})
        {
            $self->{list_ctrl_bin}->SetItemBackgroundColour($i, Wx::Colour->new(255, 0, 0));
            $self->{list_ctrl_bin}->SetItemTextColour($i, Wx::Colour->new(255, 255, 255));
        }
        $i++;
    }

    $i = 0;
    foreach my $elem (sort {$a->{name} cmp $b->{name}} @{$self->{manifest}->{etc}})
    {
        my $item = Wx::ListItem->new();
        $item->SetId($i);
        $item->SetText($elem->{name});
        $self->{list_ctrl_etc}->InsertItem( $item );

        if ($elem->{status} eq "exclude")
        {
            $self->{list_ctrl_lib}->SetItemBackgroundColour($i, Wx::Colour->new(200, 200, 200));
        }

        unless (-f $elem->{name})
        {
            $self->{list_ctrl_etc}->SetItemBackgroundColour($i, Wx::Colour->new(255, 0, 0));
            $self->{list_ctrl_etc}->SetItemTextColour($i, Wx::Colour->new(255, 255, 255));
        }
        $i++;
    }

    foreach my $elem (sort {$a->{name} cmp $b->{name}} @{$self->{manifest}->{var}})
    {
        my $item = Wx::ListItem->new();
        $item->SetId($i);
        $item->SetText($elem->{name});
        $self->{list_ctrl_var}->InsertItem( $item );

        if ($elem->{status} eq "exclude")
        {
            $self->{list_ctrl_lib}->SetItemBackgroundColour($i, Wx::Colour->new(200, 200, 200));
        }

        unless (-f $elem->{name})
        {
            $self->{list_ctrl_var}->SetItemBackgroundColour($i, Wx::Colour->new(255, 0, 0));
            $self->{list_ctrl_var}->SetItemTextColour($i, Wx::Colour->new(255, 255, 255));
        }
        $i++;
    }

    foreach my $elem (sort {$a->{name} cmp $b->{name}} @{$self->{manifest}->{doc}})
    {
        my $item = Wx::ListItem->new();
        $item->SetId($i);
        $item->SetText($elem->{name});
        $self->{list_ctrl_doc}->InsertItem( $item );

        if ($elem->{status} eq "exclude")
        {
            $self->{list_ctrl_lib}->SetItemBackgroundColour($i, Wx::Colour->new(200, 200, 200));
        }

        unless (-f $elem->{name})
        {
            $self->{list_ctrl_doc}->SetItemBackgroundColour($i, Wx::Colour->new(255, 0, 0));
            $self->{list_ctrl_doc}->SetItemTextColour($i, Wx::Colour->new(255, 255, 255));
        }
        $i++;
    }

    foreach my $elem (sort {$a->{name} cmp $b->{name}} @{$self->{manifest}->{others}})
    {
        my $item = Wx::ListItem->new();
        $item->SetId($i);
        $item->SetText($elem->{name});
        $self->{list_ctrl_others}->InsertItem( $item );

        if ($elem->{status} eq "exclude")
        {
            $self->{list_ctrl_lib}->SetItemBackgroundColour($i, Wx::Colour->new(200, 200, 200));
        }

        unless (-f $elem->{name})
        {
            $self->{list_ctrl_others}->SetItemBackgroundColour($i, Wx::Colour->new(255, 0, 0));
            $self->{list_ctrl_others}->SetItemTextColour($i, Wx::Colour->new(255, 255, 255));
        }
        $i++;
    }
}


sub list_ctrl_menu
{
    my ($self, $event, $list_ctrl) = @_;

    my $menuPopUp = Wx::Menu->new();
    $menuPopUp->Append(MENU_EXCLUDE, "Exclude");
    $menuPopUp->Append(MENU_INCLUDE, "Include");

    $self->{menu_list_ctrl} = $list_ctrl;
    $list_ctrl->PopupMenu($menuPopUp, $event->GetPoint());
}

sub set_package_file_status
{
    my ($self, $manifest, $list_ctrl, $status) = @_;

    my $i = -1;
    for ( ;; )
    {
        $i = $self->{menu_list_ctrl}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $item = $self->{menu_list_ctrl}->GetItem($i, 0);
        my $item_text = $item->GetText();
        if ($status eq "exclude")
        {
            $self->{menu_list_ctrl}->SetItemBackgroundColour($i, Wx::Colour->new(200, 200, 200));
        }
        else
        {
            $self->{menu_list_ctrl}->SetItemBackgroundColour($i, Wx::Colour->new(255, 255, 255));
        }

        if ($self->{menu_list_ctrl} == $list_ctrl)
        {
            foreach my $file (@{$manifest})
            {
                if ($file->{name} eq $item_text)
                {
                    $file->{status} = $status;
                }
            }
        }
    }
}

sub copy_to_packaging_tmp
{
    my ($self, $manifest_dir_ref, $target_path, $subdir) = @_;

    if ($subdir eq "lib")
    {
        $subdir = "bin";
    }

    foreach my $file (@$manifest_dir_ref)
    {
        if ($file->{status} ne "exclude")
        {
            my ($fname) = $file->{name} =~ /.*\/(.*)/;

            if (!File::Copy::syscopy($file->{name}, "$target_path/$subdir/$fname"))
            {
                DPOLog::report_msg(DPOEvents::FILE_COPY_FAILURE, [$file->{name}, "$target_path/$subdir/$fname", $!]);
                return 0;
            }
        }
    }

    return 1;
}

sub backup_show_changes
{
    my ($self, $diff_count_ref) = @_;

    $self->{list_ctrl_backup_new_local_files}->DeleteAllItems();

    my $rdiff_backup_cmd = $self->{combo_box_rdiff_backup}->GetValue();

    my $local = $self->{text_ctrl_local_pool}->GetValue();
    my $remote = $self->{text_ctrl_remote_pool}->GetValue();

    unless (-d $local && -d $remote)
    {
        Wx::MessageBox("Local or remote not set");
        return;
    }

    unless (-d "$remote/rdiff-backup-data")
    {
        my $rc = Wx::MessageBox("Remote directory doesn't exist (or is not a rdiff-backup directory).\n\n".
                                "Do you want to make a backup now?",
                                "",
                                Wx::wxYES_NO | Wx::wxICON_QUESTION);
        if ($rc == Wx::wxNO)
        {
            return;
        }

        if (!DPOUtils::make_path($remote))
        {
            Wx::MessageBox("Failed to create directory: $remote");
            return;
        }

        my $wait = Wx::BusyCursor->new();

        my $output = `$rdiff_backup_cmd \"$local\" \"$remote\"`;
        print "$output\n";
    }

    my $diffs = `$rdiff_backup_cmd --compare-at-time now \"$local\" \"$remote\"`;

    my $diff_count = 0;

    #~ print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n";
    if ($diffs =~ /new:/)
    {
        my $i = 0;
        foreach my $line (split /^/, $diffs)
        {
            if ($line =~ /new:/) # not redundant
            {
                $diff_count++;

                my ($file) = $line =~ /new\:\s*(.*)/;

                #~ print "   $local/$file\n";

                my $item = Wx::ListItem->new();

                $item->SetId($i);
                $item->SetText("$local/$file");
                $self->{list_ctrl_backup_new_local_files}->InsertItem( $item );
                $i++;
            }
        }
    }

    #~ print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
    if ($diffs =~ /deleted:/)
    {
        my $i = 0;
        foreach my $line (split /^/, $diffs)
        {
            if ($line =~ /deleted:/) # not redundant
            {
                $diff_count++;

                my ($file) = $line =~ /deleted\:\s*(.*)/;

                #~ print "   $remote/$file\n";

                my $item = Wx::ListItem->new();

                $item->SetId($i);
                $item->SetText("$remote/$file");
                $self->{list_ctrl_backup_new_remote_files}->InsertItem( $item );
                $i++;
            }
        }
    }

    if (defined($diff_count_ref))
    {
        $$diff_count_ref = $diff_count;
    }
}

sub extract_projects_versions_from_versions_log
{
    my ($self, $versions_log, $impact_projects_ref) = @_;

    my @lines;
    if (!DPOUtils::get_file_lines($versions_log, \@lines))
    {
        return 1;
    }

    my $product_version;
    foreach my $line (@lines)
    {
        chomp $line;

        if ($line =~ /^$/)
        {
            # an empty line
            next;
        }

        if ($line =~ /\[(.*)\]/)
        {
            $product_version = $1;
        }
        else
        {
            my ($status, $project_name, $project_version) = $line =~ /^(.{1})\s*(.*)\-(.*)/;
            if (defined($status)
                && defined($project_name)
                && defined($project_version))
            {
                if (!List::MoreUtils::any {"$_->{project_name}-$_->{project_version}" eq $project_name . "-" . $project_version} @$impact_projects_ref)
                {
                    my $impact_project = ImpactProject->new($project_name, $project_version, $product_version);
                    push(@$impact_projects_ref, $impact_project);
                }
            }
        }
    }

    return 1;
}

sub get_path_of_lib
{
    my ($self, $product_name, $lib, $lib_path_ref) =  @_;

    foreach my $product_content (@{$self->{product_content}})
    {
        if ($product_content->{product_name} eq $product_name)
        {
            foreach my $elem (@{$product_content->{content}})
            {
                $elem =~ s/\\/\//g;
                my ($path, $fname) = $elem =~ /(.*)\/(.*)/;
                if ($fname eq $lib)
                {
                    $$lib_path_ref = $path;
                    return 1;
                }
            }
        }
    }

    return 0;
}

sub get_project
{
    my ($self, $project_name, $project_ref) = @_;

    foreach my $loaded_project (@{$self->{loaded_projects}})
    {
        if ($loaded_project->{name} eq $project_name)
        {
            $$project_ref = $loaded_project;
            return 1;
        }
    }

    # Project not loaded yet

    my $path="";

    my $env_var_id = uc($project_name) . "_PRJ_ROOT";
    $path = "\$($env_var_id)";
    if (!DPOEnvVars::expand_env_var(\$path))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$env_var_id]);
        return 0;
    }

    if (!DPOUtils::in_dpo_pool($path))
    {
        DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["$project_name env. var. doesn't map with pool. Please activate all project as pool projects."]);
        return 0;
    }

    my $file = "$path/DPOProject.xml";

    if (-e $file)
    {
        my $err;
        my $config = DPOProjectConfig->new($file, \$err);
        if ($config)
        {
            my $new_project;
            if ($config->get_project(\$new_project))
            {
                if (!$new_project->load_features())
                {
                    DPOLog::report_msg(DPOEvents::GET_FEATURES_FAILURE, [$project_name]);
                    return 0;
                }

                if (!$self->load_project_dependencies($new_project))
                {
                    DPOLog::report_msg(DPOEvents::LOAD_DYN_DEP_FAILURE, [$project_name]);
                    return 0;
                }

                push(@{$self->{loaded_projects}}, $new_project);

                $$project_ref = $new_project;
            }
            else
            {
                DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_name]);
                return 0;
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::LOAD_PROJECT_FAILURE, [$file, $err]);
            return 0;
        }
    }
    else
    {
        DPOLog::report_msg(DPOEvents::FILE_DOESNT_EXIST, [$file]);
        return 0;
    }

    return 1;
}

sub load_project_dependencies
{
    my ($self, $project) = @_;

    foreach my $dep (@{$project->{dependencies_when_dynamic}}, @{$project->{dependencies_when_static}})
    {
        if (!List::MoreUtils::any {$_->{name} eq $dep->{name}} @{$self->{loaded_projects}})
        {
            if ($dep->{dpo_compliant}->{value})
            {
                my $new_project;
                if (!$self->get_project($dep->{name}, \$new_project))
                {
                    DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$dep->{name}]);
                    return 0;
                }

                #~ $new_project->{version} = $dep->{version};
                #~ $new_project->{target_version} = $dep->{target_version};
            }
            else
            {
                # make $dep (DPOProjectDependency) a DPOProject
                my $new_project = DPOProject->new($dep->{name},
                                                    $dep->{version},
                                                    $dep->{target_version},
                                                    $dep->{type},
                                                    $dep->{dpo_compliant});

                # Load dependencies of the new project

                # Get product to allow load_non_compliant_dependencies getting libs types from product
                my $product;
                if (!DPOProductConfig::get_product_with_name($dep->{dpo_compliant}->{product_name}, \$product))
                {
                    DPOLog::report_msg(DPOEvents::CANT_GET_PRODUCT, [$dep->{dpo_compliant}->{product_name}]);
                    return 0;
                }

                my $dpo_mpb = DPOMpb->new($new_project->{name}, # lib_id
                                            $new_project->{dpo_compliant}->{mpb}, # mpb name
                                            $new_project->{dpo_compliant}->{mpc_includes});

                # Get dependencies of $new_project and put them into loaded_projects
                if (!$dpo_mpb->load_non_compliant_dependencies($product,
                                                            $new_project,
                                                            $self->{loaded_projects},
                                                            $self->{mpbs_scanned}))
                {
                    DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Can't get non compliant dependencies for $dep->{name}"]);
                    return 0;
                }

                if (!List::MoreUtils::any {$_->{name} eq $new_project->{name}} @{$self->{loaded_projects}})
                {
                    push(@{$self->{loaded_projects}}, $new_project);
                }
            }
        }
    }

    return 1;
}

#######Eeeeeeeeeeeeeeevent handlers...
sub on_button_load_pool
{
    my ($self, $event) = @_;

    my $wait = Wx::BusyCursor->new();

    my $pool_path = $self->{text_ctrl_current_pool_root}->GetValue();

    my @paths;
    if (!$self->get_path_with_dpoproduct_xml($pool_path, \@paths))
    {
        return;
    }

    my $node = PoolTreeNode->new("root");
    $self->fill_pool_tree_struct(\@paths, $node);

    $self->{tree_ctrl_pool}->DeleteAllItems();
    my $tree_root = $self->{tree_ctrl_pool}->AddRoot("");
    $self->fill_pool_tree($tree_root, $node);

    $self->sort_products();
    $self->fill_list_products();

    $self->fill_product_comboboxes($pool_path);

    # On some machines, the refresh is not done properly --> Show(0) + Show(1) fix the problem.
    $self->Show(0);
    $self->Show(1);

    return;

    # wxGlade: DPOPanelPool::on_button_load_pool <event_handler>
    warn "Event handler (on_button_load_pool) not implemented";
    $event->Skip;
    # end wxGlade
}

sub on_button_get_product
{
    my ($self, $event) = @_;

    my $wait = Wx::BusyCursor->new();

    my $selection = $self->{tree_ctrl_pool}->GetSelection();

    if ($selection->IsOk())
    {
        my $relative_path = DPOUtils::get_tree_item_path($self->{tree_ctrl_pool}, $selection);

        my $path = $self->{text_ctrl_current_pool_root}->GetValue() . "/$relative_path";
        if (!$self->get_products($path, $self->{selected_products}))
        {
            Wx::MessageBox("Failed to get products from $path.");
            return;
        }

        $self->sort_products();
        $self->fill_list_products();
    }

    return;

    # wxGlade: DPOPanelPool::on_button_get_product <event_handler>
    warn "Event handler (on_button_get_product) not implemented";
    $event->Skip;
    # end wxGlade
}

sub on_list_ctrl_product_col_click
{
    my ($self, $event) = @_;

    if ($event->GetColumn() == 0)
    {
        if ($self->{list_ctrl_product_order_col_name} == 0)
        {
            @{$self->{selected_products}} = sort {$a->{name} cmp $b->{name}} @{$self->{selected_products}};
            $self->{list_ctrl_product_order_col_name} = 1;
        }
        else
        {
            @{$self->{selected_products}} = sort {$b->{name} cmp $a->{name}} @{$self->{selected_products}};
            $self->{list_ctrl_product_order_col_name} = 0;
        }
        $self->{list_ctrl_product_order_current_col} = 0;
    }
    if ($event->GetColumn() == 1)
    {
        if ($self->{list_ctrl_product_order_col_flavour} == 0)
        {
            @{$self->{selected_products}} = sort {$a->{flavour} cmp $b->{flavour}} @{$self->{selected_products}};
            $self->{list_ctrl_product_order_col_flavour} = 1;
        }
        else
        {
            @{$self->{selected_products}} = sort {$b->{flavour} cmp $a->{flavour}} @{$self->{selected_products}};
            $self->{list_ctrl_product_order_col_flavour} = 0;
        }
        $self->{list_ctrl_product_order_current_col} = 1;
    }

    $self->fill_list_products();

    return;

    # wxGlade: DPOPanelPool::on_list_ctrl_product_col_click <event_handler>
    warn "Event handler (on_list_ctrl_product_col_click) not implemented";
    $event->Skip;
    # end wxGlade
}



sub on_button_activate
{
    my ($self, $event) = @_;

    my @products_to_activate;
    my @names;
    my @multiple_names;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_product}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $item_name = $self->{list_ctrl_product}->GetItem($i, 0);
        my $name = $item_name->GetText();

        my $item_flavour = $self->{list_ctrl_product}->GetItem($i, 1);
        my $flavour = $item_flavour->GetText();

        my $item_version = $self->{list_ctrl_product}->GetItem($i, 2);
        my $version = $item_version->GetText();

        my $prod = "$name-$version-$flavour";

        if (List::MoreUtils::any {$_ eq $name} @names)
        {
            if (!List::MoreUtils::any {$_ eq $name} @multiple_names)
            {
                push(@multiple_names, $name);
            }
        }
        else
        {
            push(@products_to_activate, $prod);
            push(@names, $name);
        }
    }

    if (scalar(@products_to_activate) == 0)
    {
        Wx::MessageBox("No selection", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    if (scalar(@multiple_names) != 0)
    {
        my $text = "";
        my $sep = "";
        foreach my $name (@multiple_names)
        {
            $text .= "$sep- $name";
            $sep = "\n";
        }

        Wx::MessageBox("More than one selection for:\n\n$text", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    if ($self->{frame}->{panel_product}->{this_product} ne "")
    {
        Wx::MessageBox("The product will be closed", "", Wx::wxOK | Wx::wxICON_INFORMATION);
        $self->{frame}->{panel_product}->close_product();
    }

    my @list_env_vars_to_del;
    my @list_env_vars_to_set;

    my @failures;
    foreach my $product_to_activate (@products_to_activate)
    {
        foreach my $product (@{$self->{selected_products}})
        {
            if ("$product->{name}-$product->{version}-$product->{flavour}" eq $product_to_activate)
            {
                my $config_product = DPOProductConfig->new($product->{xml_file});
                if ($config_product)
                {
                    if (!$config_product->save($product, 1))
                    {
                        push(@failures, $product->{name});
                        next;
                    }
                }
                else
                {
                    DPOLog::report_msg(DPOEvents::LOAD_PRODUCT_FAILURE, [$product->{xml_file}]);
                    push(@failures, $product->{name});
                    next;
                }

                my ($path) = $product->{xml_file} =~ /(.*)\/DPOProduct.xml/;
                my $env_var = DPOEnvVar->new(uc($product->{name}) . "_ROOT", $path);
                push(@list_env_vars_to_set, $env_var);

                # Extract projects from dpo_versions.log
                my %env_vars_to_set;
                my %env_vars_to_del;
                if ($product->{dpo_compliant_product}->{value})
                {
                    my $versions_log = "$path/dpo_versions.log";
                    my @lines;
                    my $last_block = 0;
                    if (DPOUtils::get_file_lines($versions_log, \@lines))
                    {
                        foreach my $line (@lines)
                        {
                            chomp $line;

                            if ($line =~ /\[(\d+\.\d+\.\d+)\]/)
                            {
                                if ($last_block)
                                {
                                    last;
                                }

                                if ($1 eq $product->{version})
                                {
                                    $last_block = 1;
                                }
                                next;
                            }

                            if ($line =~ /^$/) # an empty line
                            {
                                next
                            }

                            print "$line\n";

                            my $status;
                            my $project_name;
                            my $version;
                            if ($line =~ /-->/)
                            {
                                ($status, my $former_project_name, my $former_version, $project_name, $version) = $line =~ /(.)\s+(.*)-(.*) --> (.*)-(.*)/;
                            }
                            else
                            {
                                ($status, $project_name, $version) = $line =~ /(.)\s+(.*)-(.*)/;
                            }

                            my $env_var_id = uc($project_name) . "_PRJ_ROOT";
                            my $env_var_value = "$path/modules/$project_name/$version";
                            if ($status eq "X")
                            {
                                if (exists $env_vars_to_set{$env_var_id})
                                {
                                    delete $env_vars_to_set{$env_var_id};
                                    $env_vars_to_del{$env_var_id} = $env_var_value;
                                }
                            }
                            else
                            {
                                if (exists $env_vars_to_del{$env_var_id})
                                {
                                    delete $env_vars_to_del{$env_var_id};
                                }

                                $env_vars_to_set{$env_var_id} = $env_var_value;
                            }
                        }
                    }
                    else
                    {
                        DPOLog::report_msg(DPOEvents::GET_LINES_FROM_FILE_FAILURE, [$versions_log]);
                        next;
                    }
                }

                foreach my $key (keys %env_vars_to_del)
                {
                    my $env_var = DPOEnvVar->new($key, $env_vars_to_del{$key});
                    push(@list_env_vars_to_del, $env_var);
                }

                foreach my $key (keys %env_vars_to_set)
                {
                    my $env_var = DPOEnvVar->new($key, $env_vars_to_set{$key});
                    push(@list_env_vars_to_set, $env_var);
                }
            }
        }
    }

    if (scalar(@list_env_vars_to_del) != 0)
    {
        foreach my $env_var (@list_env_vars_to_del)
        {
            print "DD - $env_var->{name}\n";
        }
        DPOEnvVars::system_del_env_vars(\@list_env_vars_to_del);
    }

    if (scalar(@list_env_vars_to_set) != 0)
    {
        foreach my $env_var (@list_env_vars_to_set)
        {
            print "Set env var: $env_var->{name} = $env_var->{value}\n";
        }

        DPOEnvVars::system_set_env_vars(\@list_env_vars_to_set);
    }
    else
    {
        Wx::MessageBox("Nothing activated");
        return;
    }

    if (scalar(@products_to_activate) == scalar(@failures))
    {
        Wx::MessageBox("Activation failed");
    }
    else
    {
        my $text = "";

        if (scalar(@failures) != 0)
        {
            $text = " with failures:\n\n";
            my $sep = "";
            foreach my $failure (@failures)
            {
                $text .= "$sep- $failure";
                $sep = "\n";
            }
        }

        Wx::MessageBox("Activated$text");
    }

    return;

    # wxGlade: DPOPanelPool::on_button_activate <event_handler>
    warn "Event handler (on_button_activate) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_activate_project
{
    my ($self, $event) = @_;

    my $dlg = Wx::DirDialog->new($self, "DPO project", $self->{pool_path});
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        my ($flavour, $project_name, $version) = $path =~ /.*\/(.*)\/modules\/(.*)\/(\d+\.\d+\.\d+)/;

        my $proj = "$project_name-$version-$flavour";

        if (-e "$path/DPOProject.xml")
        {
            my $rc = Wx::MessageBox(
                        "Do you really want to activate $proj from pool ($path) ?\n\n",
                        "Pool project activation",
                        Wx::wxYES_NO | Wx::wxICON_QUESTION);
            if ($rc == Wx::wxYES)
            {
                my $env_var = DPOEnvVar->new(uc($project_name) . "_PRJ_ROOT", $path);
                print "set env var for project $project_name ($env_var->{name} = $env_var->{value})\n";

                my @list_env_vars_to_set;
                push(@list_env_vars_to_set, $env_var);
                DPOEnvVars::system_set_env_vars(\@list_env_vars_to_set);
            }
        }
        else
        {
            Wx::MessageBox("$path is not a pool project path or is not a DPO compliant product.");
            return;
        }
    }

    return;

    # wxGlade: DPOPanelPool::on_button_activate_project <event_handler>
    warn "Event handler (on_button_activate_project) not implemented";
    $event->Skip;
    # end wxGlade
}


sub get_all_products
{
    my ($self, $dir, $content_ref) = @_;

    my @content;
    if (!DPOUtils::get_dir_content($dir, \@content))
    {
        DPOLog::report_msg(DPOEvents::GET_DIR_CONTENT_FAILURE, [$dir]);
        return 0;
    }

    foreach my $elem (@content)
    {
        my $complete = "$dir/$elem";
        if (-f $complete)
        {
            if ($elem eq "DPOProduct\.xml")
            {
                push(@$content_ref, $complete);
                return 1;
            }
        }
        else
        {
            if (-d $complete && $elem ne "." && $elem ne ".." && $elem ne ".svn")
            {
                if (!$self->get_all_products($complete, $content_ref))
                {
                    return 0;
                }
            }
        }
    }

    return  1;
}

sub on_button_packaging_load_products
{
    my ($self, $event) = @_;

    my $wait = Wx::BusyCursor->new();

    my $pool_dir = DPOUtils::dpo_pool_dir();

    my @content;
    if (!$self->get_all_products($pool_dir, \@content))
    {
        Wx::MessageBox("Failed to get all products");
        return;
    }
    else
    {
        #~ foreach my $elem (@content)
        #~ {
            #~ print "Product found: $elem\n";
        #~ }
    }

    my %prods;

    $self->{combo_box_packaging_products}->Clear();
    foreach my $elem (@content)
    {
        my $text;
        if ($elem =~ /(\d+.\d+.\d+)\/DPOProduct\.xml/)
        {
            my ($path, $product_name, $flavour) = $elem =~ /(.*)\/(.*)\/(.*)\/\d+\.\d+\.\d+\/DPOProduct\.xml/;
            $text = "$product_name/$flavour";
        }
        else
        {
            my ($path, $product_name, $flavour) = $elem =~ /(.*)\/(.*)\/(.*)\/DPOProduct\.xml/;
            $text = "$product_name/$flavour";
        }

        $self->{packaging_products}->{$text} = $elem;

        $prods{$text} = "$text  ---  $elem";
    }

    foreach my $key (sort keys %prods)
    {
        $self->{combo_box_packaging_products}->Append($prods{$key});
    }

    $self->{combo_box_packaging_products}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    $self->Refresh();

    return;

    # wxGlade: DPOPanelPool::on_button_packaging_load_products <event_handler>
    warn "Event handler (on_button_packaging_load_products) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_combo_box_packaging_products
{
    my ($self, $event) = @_;

    my $combo_box_element = $self->{combo_box_packaging_products}->GetValue();

    my ($product_config_file) = $combo_box_element =~ /---\s*(.*)/;
    unless (-f $product_config_file)
    {
        Wx::MessageBox("$product_config_file does not exist");
        return;
    }

    my ($path, $dpoproduct_xml) = $product_config_file =~ /(.*)\/(DPOProduct.xml)/;
    my $versions_log = "$path/dpo_versions.log";

    $self->{versions_blocks} = [];
    if (!DPOUtils::get_versions_blocks($versions_log, $self->{versions_blocks}))
    {
        Wx::MessageBox("Can't extract versions from $versions_log");
        return;
    }

    $self->{combo_box_packaging_product_versions}->Clear();
    foreach my $block (@{$self->{versions_blocks}})
    {
        $self->{combo_box_packaging_product_versions}->Append($block->{version});
    }

    $self->{button_packaging_open_product}->Enable();

    $self->{combo_box_packaging_product_versions}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    $self->{combo_box_packaging_products}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
    $self->Refresh();

    return;

    # wxGlade: DPOPanelPool::on_combo_box_packaging_products <event_handler>
    warn "Event handler (on_combo_box_packaging_products) not implemented";
    $event->Skip;
    # end wxGlade
}

sub on_combo_box_packaging_product_versions
{
    my ($self, $event) = @_;

    $self->{combo_box_packaging_product_versions}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
    $self->Refresh();

    return;

    # wxGlade: DPOPanelPool::on_combo_box_packaging_product_versions <event_handler>
    warn "Event handler (on_combo_box_packaging_product_versions) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_packaging_open_product
{
    my ($self, $event) = @_;

    my $wait = Wx::BusyCursor->new();

    $self->{loaded_projects} = [];

    # Get product
    my $product;

    my $combo_box_element = $self->{combo_box_packaging_products}->GetValue();

    my ($product_config_file) = $combo_box_element =~ /---\s*(.*)/;
    unless (-f $product_config_file)
    {
        Wx::MessageBox("$product_config_file does not exist");
        return;
    }

    my $config_product = DPOProductConfig->new($product_config_file);
    if ($config_product)
    {
        $config_product->get_product(\$product);

    }
    else
    {
        Wx::MessageBox("Can't load product from $product_config_file");
        return;
    }

    # Version
    my $version = $self->{combo_box_packaging_product_versions}->GetValue();
    if ($version eq "")
    {
        Wx::MessageBox("Please, select version.");
        return;
    }

    # Flavour
    my ($flavour) = $product_config_file =~ /.*\/(.*)\/DPOProduct.xml$/;


    # Manifest
    $self->{manifest} = DPOManifest->new();

    # Get projects according to version
    my @relevant_projects;
    foreach my $block (@{$self->{versions_blocks}})
    {
        if ($block->{version} eq $version)
        {
            foreach my $block_project (@{$block->{projects}})
            {
                if ($block_project->{status} ne "X")
                {
                    my $new_relevant_project = $block_project->clone;
                    push(@relevant_projects, $new_relevant_project);
                }
            }
        }
    }

    # For the relevant projects, determine the corresponding paths where
    # DPOProject.xml files reside.
    my @dpoproject_xml_paths;   # Used to find files to extract from projects and their dependencies.
    my ($product_path) = $product_config_file =~ /(.*)\/DPOProduct\.xml/;
    if (!$self->extract_dpoproject_xml_paths($product_path, \@dpoproject_xml_paths))
    {
        # TO_DO
        return;
    }

    $self->{loaded_projects} = [];
    $self->{manifest_scanned} = [];

    print "Loading projects...\n";

    my @projects;
    $self->{non_compliant_libs} = [];
    foreach my $relevant_project (@relevant_projects)
    {
        my $project = 0;
        $self->load_relevant_project($relevant_project, \@dpoproject_xml_paths, \$project);
        if ($project)
        {
            push(@projects, $project);
            push(@{$self->{loaded_projects}}, $project);
        }
        else
        {
            # TO_DO
            return;
        }
    }

    foreach my $project (@projects)
    {
        if (!$self->load_project_dependencies($project))
        {
            DPOLog::report_msg(DPOEvents::LOAD_DYN_DEP_FAILURE, [$project->{name}]);
            return 0;
        }
    }

    foreach my $project (@{$self->{loaded_projects}})
    {
        if (!$self->get_manifest_from_project($project))
        {
            # TO_DO
            return;
        }
    }

    if (!$self->get_manifest_from_runtime($product->{name}, $flavour))
    {
        # TO_DO
        return;
    }

    $self->fill_list_ctrl_with_manifest();

    # Warning quand project n'a pas le mme tool_chain ??? TO_DO ?

    $self->{button_save_as_manifest}->Enable(1);
    $self->{notebook_elements}->Enable(1);
    $self->{button_pakaging_add}->Enable(1);
    $self->{button_create_package}->Enable(1);

    return;

    # wxGlade: DPOPanelPool::on_button_packaging_open_product <event_handler>
    warn "Event handler (on_button_packaging_open_product) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_packaging_include_deep_deps {
    my ($self, $event) = @_;
    # wxGlade: DPOPanelPool::on_button_packaging_include_deep_deps <event_handler>
    warn "Event handler (on_button_packaging_include_deep_deps) not implemented";
    $event->Skip;
    # end wxGlade
}

sub on_button_create_package_manifest_file_open
{
    my ($self, $event) = @_;

    my $product_path = $self->{combo_box_packaging_products}->GetValue();
    if ($product_path eq "")
    {
        $product_path = DPOUtils::dpo_pool_dir();
    }
    else
    {
        ($product_path) = $product_path =~ /---\s*(.*)\/DPOProduct.xml/;
    }

    my $dlg = Wx::FileDialog->new($self, "Manifest file", $product_path, "", "Manifest files (*.manifest)|*.manifest|All files (*.*)|*.*");
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        my @lines;
        if (DPOUtils::get_file_lines($path, \@lines))
        {
            $self->{manifest} = DPOManifest->new();

            foreach my $line (@lines)
            {
                my ($type, $file, $status) = $line =~ /(.*) \| (.*) \| \s*(.*)/;
                my $qualified_manifest_file = QualifiedManifestFile->new($file);
                $qualified_manifest_file->{status} = $status;
                push(@{$self->{manifest}->{$type}}, $qualified_manifest_file);
            }

            $self->fill_list_ctrl_with_manifest();

            $self->{text_ctrl_create_package_manifest_file}->SetValue($path);
            $self->{button_save_as_manifest}->Enable(1);
            $self->{notebook_elements}->Enable(1);
            $self->{button_pakaging_add}->Enable(1);
            $self->{button_create_package}->Enable(1);
        }
        else
        {
            # TO_DO
            return;
        }
    }

    return;

    # wxGlade: DPOPanelPool::on_button_create_package_manifest_file_open <event_handler>
    warn "Event handler (on_button_create_package_manifest_file_open) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_save_as_manifest
{
    my ($self, $event) = @_;

    my $product_path = $self->{combo_box_packaging_products}->GetValue();
    if ($product_path eq "")
    {
        $product_path = DPOUtils::dpo_pool_dir();
    }
    else
    {
        ($product_path) = $product_path =~ /---\s*(.*)\/DPOProduct.xml/;
    }

    my $dlg = Wx::FileDialog->new($self, "Manifest file", $product_path, "", "Manifest files (*.manifest)|*.manifest|All files (*.*)|*.*");
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        $path .= ".manifest";

        my $fh = new FileHandle();

        my $bPrintToFile = 1;  #  1: to file,  0: to console

        if ($bPrintToFile)
        {
            if (!$fh->open(">> $path"))
            {
                DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, [$path, $!]);
                return 0;
            }
        }
        else
        {
            $fh = *STDOUT;
        }

        foreach my $file (@{$self->{manifest}->{lib}})
        {
            print $fh "lib | $file->{name} | $file->{status}\n";
        }

        foreach my $file (@{$self->{manifest}->{bin}})
        {
            print $fh "bin | $file->{name} | $file->{status}\n";
        }

        foreach my $file (@{$self->{manifest}->{etc}})
        {
            print $fh "etc | $file->{name} | $file->{status}\n";
        }

        foreach my $file (@{$self->{manifest}->{var}})
        {
            print $fh "var | $file->{name} | $file->{status}\n";
        }

        foreach my $file (@{$self->{manifest}->{doc}})
        {
            print $fh "doc | $file->{name} | $file->{status}\n";
        }

        foreach my $file (@{$self->{manifest}->{others}})
        {
            print $fh "others | $file->{name} | $file->{status}\n";
        }

        if ($bPrintToFile)
        {
            $fh->close;
        }
    }

    return;

    # wxGlade: DPOPanelPool::on_button_save_as_manifest <event_handler>
    warn "Event handler (on_button_save_as_manifest) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_pakaging_add
{
    my ($self, $event) = @_;

    my $dlg = Wx::FileDialog->new($self, "DPO project");
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        my $current_page_text = $self->{notebook_elements}->GetPageText($self->{notebook_elements}->GetSelection());

        my $rc = Wx::MessageBox(
                    "You're about to add $path into $current_page_text\n\n" .
                    "Do you really want to proceed ?",
                    "",
                    Wx::wxYES_NO | Wx::wxICON_QUESTION);
        if ($rc == Wx::wxYES)
        {
            if ($current_page_text eq "Lib")
            {
                push(@{$self->{manifest}->{lib}}, QualifiedManifestFile->new($path));
            }

            if ($current_page_text eq "Bin")
            {
                push(@{$self->{manifest}->{bin}}, QualifiedManifestFile->new($path));
            }

            if ($current_page_text eq "Etc")
            {
                push(@{$self->{manifest}->{etc}}, QualifiedManifestFile->new($path));
            }

            if ($current_page_text eq "Var")
            {
                push(@{$self->{manifest}->{var}}, QualifiedManifestFile->new($path));
            }

            if ($current_page_text eq "Doc")
            {
                push(@{$self->{manifest}->{doc}}, QualifiedManifestFile->new($path));
            }

            if ($current_page_text eq "Others")
            {
                push(@{$self->{manifest}->{others}}, QualifiedManifestFile->new($path));
            }

            $self->fill_list_ctrl_with_manifest();
        }
    }

    return;

    # wxGlade: DPOPanelPool::on_button_pakaging_add <event_handler>
    warn "Event handler (on_button_pakaging_add) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_lib_right_click
{
    my ($self, $event) = @_;

    $self->list_ctrl_menu($event, $self->{list_ctrl_lib});

    return;

    # wxGlade: DPOPanelPool::on_list_ctrl_lib_right_click <event_handler>
    warn "Event handler (on_list_ctrl_lib_right_click) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_bin_right_click
{
    my ($self, $event) = @_;

    $self->list_ctrl_menu($event, $self->{list_ctrl_lib});

    return;

    # wxGlade: DPOPanelPool::on_list_ctrl_bin_right_click <event_handler>
    warn "Event handler (on_list_ctrl_bin_right_click) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_etc_right_click
{
    my ($self, $event) = @_;

    $self->list_ctrl_menu($event, $self->{list_ctrl_lib});

    return;

    # wxGlade: DPOPanelPool::on_list_ctrl_etc_right_click <event_handler>
    warn "Event handler (on_list_ctrl_etc_right_click) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_var_right_click
{
    my ($self, $event) = @_;

    $self->list_ctrl_menu($event, $self->{list_ctrl_lib});

    return;

    # wxGlade: DPOPanelPool::on_list_ctrl_var_right_click <event_handler>
    warn "Event handler (on_list_ctrl_var_right_click) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_doc_right_click
{
    my ($self, $event) = @_;

    $self->list_ctrl_menu($event, $self->{list_ctrl_lib});

    return;

    # wxGlade: DPOPanelPool::on_list_ctrl_doc_right_click <event_handler>
    warn "Event handler (on_list_ctrl_doc_right_click) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_others_right_click
{
    my ($self, $event) = @_;

    $self->list_ctrl_menu($event, $self->{list_ctrl_lib});

    return;

    # wxGlade: DPOPanelPool::on_list_ctrl_others_right_click <event_handler>
    warn "Event handler (on_list_ctrl_others_right_click) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_menu_exclude
{
    my ($self) = @_;

    $self->set_package_file_status($self->{manifest}->{lib}, $self->{list_ctrl_lib}, "exclude");
}


sub on_menu_include
{
    my ($self) = @_;

    $self->set_package_file_status($self->{manifest}->{lib}, $self->{list_ctrl_lib}, "include");
}


sub on_button_create_package
{
    my ($self, $event) = @_;

    my $target_path =  "\$(DPO_CORE_ROOT)";
    if (!DPOEnvVars::expand_env_var(\$target_path))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$target_path]);
        return;
    }

    my $wait = Wx::BusyCursor->new();

    $target_path .= "/packaging_tmp";

    if (-d $target_path)
    {
        if (!DPOUtils::remove_dir($target_path))
        {
            DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Can't remove $target_path. Please remove it manually."]);
            return;
        }
    }

    if (!DPOUtils::make_path("$target_path/bin")
        || !DPOUtils::make_path("$target_path/etc")
        || !DPOUtils::make_path("$target_path/var")
        || !DPOUtils::make_path("$target_path/doc")
        || !DPOUtils::make_path("$target_path/others"))
    {
        return;
    }

    if (!$self->copy_to_packaging_tmp($self->{manifest}->{lib}, $target_path, "lib"))
    {
        return;
    }

    if (!$self->copy_to_packaging_tmp($self->{manifest}->{bin}, $target_path, "bin"))
    {
        return;
    }

    if (!$self->copy_to_packaging_tmp($self->{manifest}->{etc}, $target_path, "etc"))
    {
        return;
    }

    if (!$self->copy_to_packaging_tmp($self->{manifest}->{var}, $target_path, "var"))
    {
        return;
    }

    if (!$self->copy_to_packaging_tmp($self->{manifest}->{doc}, $target_path, "doc"))
    {
        return;
    }

    if (!$self->copy_to_packaging_tmp($self->{manifest}->{others}, $target_path, "others"))
    {
        return;
    }

    # Zip...

    my $from_existing_manifest_path = "";
    my $product_path_from_existing_manifest_pane = $self->{text_ctrl_create_package_manifest_file}->GetValue();
    if ($product_path_from_existing_manifest_pane ne "")
    {
        ($from_existing_manifest_path) = $product_path_from_existing_manifest_pane =~ /(.*)\/(.*)/;
    }

    my $from_product_definition_path;
    my $product_path_from_product_definition_pane  = $self->{combo_box_packaging_products}->GetValue();
    if ($product_path_from_product_definition_pane ne "")
    {
        ($from_product_definition_path) = $product_path_from_product_definition_pane =~ /---\s*(.*)\/DPOProduct.xml/;
    }

    if ($from_existing_manifest_path eq ""
        && $from_product_definition_path eq "")
    {
        # TO_DO
        return;
    }

    if ($from_product_definition_path ne ""
        && $from_existing_manifest_path ne "")
    {
        if ($from_product_definition_path ne $from_existing_manifest_path)
        {
            # TO_DO
            return;
        }
    }

    my $product_path;
    if ($from_existing_manifest_path ne "")
    {
        $product_path = $from_existing_manifest_path;
    }
    else
    {
        $product_path = $from_product_definition_path;
    }

    my $file = "$product_path/DPOProduct.xml";
    my $product;
    my $config_product = DPOProductConfig->new($file);
    if ($config_product)
    {
        if (!$config_product->get_product(\$product))
        {
            DPOLog::report_msg(DPOEvents::GET_PRODUCT_FAILURE, [$config_product->{product}->{name}]);
            return;
        }
    }
    else
    {
        DPOLog::report_msg(DPOEvents::LOAD_PRODUCT_FAILURE, [$file]);
        return;
    }

    my ($arch, $os, $toolchain) = $product_path =~ /.*\/dpo_pool-(.*?)-(.*?)\/(.*?)\//;

    my $tar = "$product_path/$product->{name}-$product->{version}-$product->{flavour}-$arch-$os-$toolchain.zip";

    print "Zipping $tar\n";

    my $zip = Archive::Zip->new;
    my $file_member = $zip->addTree($target_path, $product->{name});
    if ( $zip->writeToFileNamed($tar) != Archive::Zip::AZ_OK )
    {
        DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Archive::Zip->addTree($tar) failed"]);
        return;
    }

    Wx::MessageBox("Package $tar generated");

    if (!DPOUtils::remove_dir($target_path))
    {
        DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Can't remove $target_path. Please remove it manually."]);
    }

    return;

    # wxGlade: DPOPanelPool::on_button_create_package <event_handler>
    warn "Event handler (on_button_create_package) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_rdiff_backup_browse
{
    my ($self, $event) = @_;

    my $current = $self->{combo_box_rdiff_backup}->GetValue();

    ($current) = $current =~ /(.*)\/rdiff-backup/;

    my $dlg = Wx::FileDialog->new($self, "rdiff-backup program", $current, "", "");
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $file = $dlg->GetPath();

        $file =~ s/\\/\//g;

        $self->{combo_box_rdiff_backup}->SetValue($file);
    }

    return;

    # wxGlade: DPOPanelPool::on_button_rdiff_backup_browse <event_handler>
    warn "Event handler (on_button_rdiff_backup_browse) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_remote_pool_browse
{
    my ($self, $event) = @_;

    my $current = $self->{text_ctrl_remote_pool}->GetValue();

    my $dlg = Wx::DirDialog->new($self, "Remote pool path", $current);
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        $self->{text_ctrl_remote_pool}->SetValue($path);
    }

    return;

    # wxGlade: DPOPanelPool::on_button_remote_pool_browse <event_handler>
    warn "Event handler (on_button_remote_pool_browse) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_local_pool_browse
{
    my ($self, $event) = @_;

    my $current = $self->{text_ctrl_local_pool}->GetValue();

    if ($current eq "")
    {
        $current = DPOUtils::dpo_pool_dir();
    }

    my $dlg = Wx::DirDialog->new($self, "Local pool path", $current);
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        $self->{text_ctrl_local_pool}->SetValue($path);
    }

    return;

    # wxGlade: DPOPanelPool::on_button_local_pool_browse <event_handler>
    warn "Event handler (on_button_local_pool_browse) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_backup_push
{
    my ($self, $event) = @_;

    my @include_files;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_backup_new_local_files}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $file = $self->{list_ctrl_backup_new_local_files}->GetItemText($i);
        push(@include_files, $file);
    }

    my @exclude_files;
    $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_backup_new_local_files}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        my $file = $self->{list_ctrl_backup_new_local_files}->GetItemText($i);
        if (!List::MoreUtils::any {$_ eq $file} @include_files)
        {
            push(@exclude_files, $file);
        }
    }

    my $rdiff_backup_include_file = "rdiff-backup_include_file_tmp";
    if (scalar(@include_files) != 0)
    {
        my $fh = new FileHandle();

        if (!$fh->open("> $rdiff_backup_include_file"))
        {
            DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, [$rdiff_backup_include_file, $!]);
            return;
        }

        foreach my $inc (@include_files)
        {
            print $fh "$inc\n";
        }

        $fh->close;
    }

    my $rdiff_backup_exclude_file = "rdiff-backup_exclude_file_tmp";
    if (scalar(@exclude_files) != 0)
    {
        my $fh = new FileHandle();

        if (!$fh->open("> $rdiff_backup_exclude_file"))
        {
            DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, [$rdiff_backup_exclude_file, $!]);
            return;
        }

        foreach my $exc (@exclude_files)
        {
            print $fh "$exc\n";
        }

        $fh->close;
    }

    if (scalar(@include_files) != 0)
    {
        my $rdiff_backup_cmd = $self->{combo_box_rdiff_backup}->GetValue();

        my $local = $self->{text_ctrl_local_pool}->GetValue();
        my $remote = $self->{text_ctrl_remote_pool}->GetValue();

        my $push_cmd = "$rdiff_backup_cmd --include-filelist $rdiff_backup_include_file ";

        if (scalar(@exclude_files) != 0)
        {
            $push_cmd .= "--exclude-filelist $rdiff_backup_exclude_file ";
        }

        $push_cmd .= "\"$local\" \"$remote\"";

        my $output = `$push_cmd`;

        $self->{list_ctrl_backup_new_local_files}->DeleteAllItems();
        $self->backup_show_changes();
    }
    else
    {
        Wx::MessageBox("No selection");
    }

    if (-f $rdiff_backup_include_file)
    {
        unlink $rdiff_backup_include_file;
    }

    if (-f $rdiff_backup_exclude_file)
    {
        unlink $rdiff_backup_exclude_file;
    }

    return;

    # wxGlade: DPOPanelPool::on_button_backup_push <event_handler>
    warn "Event handler (on_button_backup_push) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_backup_pull
{
    my ($self, $event) = @_;

    my @include_files;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_backup_new_remote_files}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $file = $self->{list_ctrl_backup_new_remote_files}->GetItemText($i);
        push(@include_files, $file);
    }

    my @exclude_files;
    $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_backup_new_remote_files}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        my $file = $self->{list_ctrl_backup_new_remote_files}->GetItemText($i);
        if (!List::MoreUtils::any {$_ eq $file} @include_files)
        {
            push(@exclude_files, $file);
        }
    }

    my $rdiff_backup_include_file = "rdiff-backup_include_file_tmp";
    if (scalar(@include_files) != 0)
    {
        my $fh = new FileHandle();

        if (!$fh->open("> $rdiff_backup_include_file"))
        {
            DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, [$rdiff_backup_include_file, $!]);
            return;
        }

        foreach my $inc (@include_files)
        {
            print $fh "$inc\n";
        }

        $fh->close;
    }

    my $rdiff_backup_exclude_file = "rdiff-backup_exclude_file_tmp";
    if (scalar(@exclude_files) != 0)
    {
        my $fh = new FileHandle();

        if (!$fh->open("> $rdiff_backup_exclude_file"))
        {
            DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, [$rdiff_backup_exclude_file, $!]);
            return;
        }

        foreach my $exc (@exclude_files)
        {
            print $fh "$exc\n";
        }

        $fh->close;
    }

    if (scalar(@include_files) != 0)
    {
        my $rdiff_backup_cmd = $self->{combo_box_rdiff_backup}->GetValue();

        my $local = $self->{text_ctrl_local_pool}->GetValue();
        my $remote = $self->{text_ctrl_remote_pool}->GetValue();

        my $pull_cmd = "$rdiff_backup_cmd --force -r now ";

        if (scalar(@exclude_files) != 0)
        {
            # rdiff-backup includes all by default (see rdiff-backup doc).
            $pull_cmd .= "--exclude-filelist $rdiff_backup_exclude_file ";
        }

        $pull_cmd .= "\"$remote\" \"$local\"";

        my $output = `$pull_cmd`;

        $self->{list_ctrl_backup_new_remote_files}->DeleteAllItems();
        $self->backup_show_changes();
    }
    else
    {
        Wx::MessageBox("No selection");
    }

    if (-f $rdiff_backup_include_file)
    {
        unlink $rdiff_backup_include_file;
    }

    if (-f $rdiff_backup_exclude_file)
    {
        unlink $rdiff_backup_exclude_file;
    }

    return;

    # wxGlade: DPOPanelPool::on_button_backup_pull <event_handler>
    warn "Event handler (on_button_backup_pull) not implemented";
    $event->Skip;
    # end wxGlade
}




sub on_button_backup_show_changes
{
    my ($self, $event) = @_;

    my $diff_count = 0;
    $self->backup_show_changes(\$diff_count);

    if ($diff_count == 0)
    {
        Wx::MessageBox("No changes");
    }

    return;

    # wxGlade: DPOPanelPool::on_button_backup_show_changes <event_handler>
    warn "Event handler (on_button_backup_show_changes) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_activation_expand_all
{
    my ($self, $event) = @_;

    $self->{tree_ctrl_pool}->ExpandAll();

    my $root = $self->{tree_ctrl_pool}->GetRootItem();
    my ($child, $cookie) = $self->{tree_ctrl_pool}->GetFirstChild($root);
    if ($child && $child->IsOk())
    {
        $self->{tree_ctrl_pool}->EnsureVisible($child);
    }

    return;

    # wxGlade: DPOPanelPool::on_button_activation_expand_all <event_handler>
    warn "Event handler (on_button_activation_expand_all) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_activation_collapse_all
{
    my ($self, $event) = @_;

    $self->{tree_ctrl_pool}->CollapseAll();

    return;

    # wxGlade: DPOPanelPool::on_button_activation_collapse_all <event_handler>
    warn "Event handler (on_button_activation_collapse_all) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_activation_remove_from_list
{
    my ($self, $event) = @_;

    my @to_remove;

    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_product}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $product_name = $self->{list_ctrl_product}->GetItemText($i);

        # wxWidgets < 2.9.1 (we must get column 1 value by getting item this way...)
        my $item_flavour = $self->{list_ctrl_product}->GetItem($i, 1);
        my $flavour = $item_flavour->GetText();
        my $item_version = $self->{list_ctrl_product}->GetItem($i, 2);
        my $version = $item_version->GetText();

        push(@to_remove, "$product_name$flavour$version");
    }

    foreach my $r (@to_remove)
    {
        @{$self->{selected_products}} = grep { "$_->{name}$_->{flavour}$_->{version}" ne $r } @{$self->{selected_products}};
    }

    $self->fill_list_products();

    return;

    # wxGlade: DPOPanelPool::on_button_activation_remove_from_list <event_handler>
    warn "Event handler (on_button_activation_remove_from_list) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_activation_select_all
{
    my ($self, $event) = @_;

    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_product}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        $self->{list_ctrl_product}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);
    }

    return;

    # wxGlade: DPOPanelPool::on_button_activation_select_all <event_handler>
    warn "Event handler (on_button_activation_select_all) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_activation_deselect_all
{
    my ($self, $event) = @_;

    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_product}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        $self->{list_ctrl_product}->SetItemState($i, 0, wxLIST_STATE_SELECTED);
    }

    return;

    # wxGlade: DPOPanelPool::on_button_activation_deselect_all <event_handler>
    warn "Event handler (on_button_activation_deselect_all) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_pool_switch
{
    my ($self, $event) = @_;

    my $env_var_id =  "\$(DPO_POOL_ROOT)";
    my $pool_path = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$pool_path))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, ["DPO_POOL_ROOT"]);
        return;
    }

    my ($parent_dir, $pool) = $pool_path =~ /(.*)\/(.*)$/;

    my $dlg = Wx::DirDialog->new($self, "DPO project", $parent_dir);
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        my ($dpo_pool_const, $arch, $os) = $path =~ /(dpo_pool)\-(.*)\-(.*)/;
        if (!defined($dpo_pool_const)
            || !defined($arch)
            || !defined($os))
        {
            Wx::MessageBox("Not a valid pool directory: $path");
            return;
        }

        my $wait = Wx::BusyCursor->new();

        my @list_env_vars;
        my $env_var = DPOEnvVar->new("DPO_POOL_ROOT", $path);
        push(@list_env_vars, $env_var);
        DPOEnvVars::system_set_env_vars(\@list_env_vars);

        $self->{text_ctrl_current_pool_root}->SetValue($path);

        $self->{pool_path} = $path;

        $self->{tree_ctrl_pool}->DeleteAllItems();

        $self->{list_ctrl_product}->DeleteAllItems();
    }

    # On some machines, the refresh is not done properly --> Show(0) + Show(1) fix the problem.
    $self->Show(0);
    $self->Show(1);

    return;

    # wxGlade: DPOPanelPool::on_button_pool_switch <event_handler>
    warn "Event handler (on_button_pool_switch) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_impact_switch
{
    my ($self, $event) = @_;

    my $env_var_id =  "\$(DPO_POOL_ROOT)";
    my $pool_path = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$pool_path))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, ["DPO_POOL_ROOT"]);
        return;
    }

    my ($parent_dir, $pool) = $pool_path =~ /(.*)\/(.*)$/;

    my $dlg = Wx::DirDialog->new($self, "DPO project", $parent_dir);
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        my ($dpo_pool_const, $arch, $os) = $path =~ /(dpo_pool)\-(.*)\-(.*)/;
        if (!defined($dpo_pool_const)
            || !defined($arch)
            || !defined($os))
        {
            Wx::MessageBox("Not a valid pool directory: $path");
            return;
        }

        my $wait = Wx::BusyCursor->new();

        my @list_env_vars;
        my $env_var = DPOEnvVar->new("DPO_POOL_ROOT", $path);
        push(@list_env_vars, $env_var);
        DPOEnvVars::system_set_env_vars(\@list_env_vars);

        $self->{text_ctrl_current_pool_root}->SetValue($path);
        $self->{text_ctrl_impact_current_pool_root}->SetValue($path);

        $self->{pool_path} = $path;

        $self->{tree_ctrl_impact_dependants}->DeleteAllItems();
    }

    return;

    # wxGlade: DPOPanelPool::on_button_impact_switch <event_handler>
    warn "Event handler (on_button_impact_switch) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_impact_load
{
    my ($self, $event) = @_;

    my $wait = Wx::BusyCursor->new();

    $self->{impact_products} = [];

    my $pool_path = $self->{text_ctrl_impact_current_pool_root}->GetValue();

    my @paths;
    if (!$self->get_path_with_dpoproduct_xml($pool_path, \@paths))
    {
        return;
    }

    $self->{combo_box_impact_product_name}->Clear();

    my @impact_projects;
    foreach my $path (@paths) # foreach product
    {
        $path =~ s/\\/\//g;

        my @versions;
        my $versions_log = "$path/dpo_versions.log";
        if (-e $versions_log)
        {
            my ($product_name, $flavour) = $path =~ /.*\/(.*)\/(.*)/;

            my $impact_product = ImpactProduct->new($product_name, $flavour);

            if (!List::MoreUtils::any {"$_->{product_name}-$_->{flavour}" eq "$impact_product->{product_name}-$impact_product->{flavour}"} @{$self->{impact_products}})
            {
                push(@{$self->{impact_products}}, $impact_product);
            }

            my @impact_projects;
            $self->extract_projects_versions_from_versions_log($versions_log, $impact_product->{impact_projects});
        }
        else
        {
            my ($product_name, $flavour, $product_version) = $path =~ /.*\/(.*)\/(.*)\/(.*)/;

            my $impact_product = ImpactProduct->new($product_name, $flavour);
            if (!List::MoreUtils::any {"$_->{product_name}-$_->{flavour}" eq "$impact_product->{product_name}-$impact_product->{flavour}"} @{$self->{impact_products}})
            {
                push(@{$self->{impact_products}}, $impact_product);
            }

            my $dpoproduct_file = "$path/DPOProduct.xml";
            my $config_product = DPOProductConfig->new($dpoproduct_file);
            if ($config_product)
            {
                my $product;
                $config_product->get_product(\$product);

                foreach my $non_compliant_lib (@{$product->{dpo_compliant_product}->{non_compliant_lib_seq}})
                {
                    my $impact_project = ImpactProject->new($non_compliant_lib->{lib_id}, $product_version, $product_name, $flavour, $product_version);
                    push(@{$impact_product->{impact_projects}}, $impact_project);
                }
            }
            else
            {
                DPOLog::report_msg(DPOEvents::LOAD_PRODUCT_FAILURE, [$dpoproduct_file]);
            }
        }
    }

    foreach my $prod (sort {$a->{product_name} cmp $b->{product_name}} @{$self->{impact_products}})
    {
        $self->{combo_box_impact_product_name}->Append("$prod->{product_name}-$prod->{flavour}");
    }

    return;

    # wxGlade: DPOPanelPool::on_button_impact_load <event_handler>
    warn "Event handler (on_button_impact_load) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_combo_box_impact_product_name
{
    my ($self, $event) = @_;

    my $product_name_flavour = $self->{combo_box_impact_product_name}->GetValue();

    foreach my $impact_product (@{$self->{impact_products}})
    {
        if ("$impact_product->{product_name}-$impact_product->{flavour}" eq $product_name_flavour)
        {
            $self->{combo_box_impact_projects}->Clear();
            $self->{combo_box_impact_projects}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));

            foreach my $impact_project (@{$impact_product->{impact_projects}})
            {
                $self->{combo_box_impact_projects}->Append($impact_project->{project_name});
            }
            next;
        }
    }

    $self->{combo_box_impact_product_name}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));

    $self->{combo_box_impact_project_version}->Clear();
    $self->{combo_box_impact_projects}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));

    return;

    # wxGlade: DPOPanelPool::on_combo_box_impact_product_name <event_handler>
    warn "Event handler (on_combo_box_impact_product_name) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_combo_box_impact_projects
{
    my ($self, $event) = @_;

    my $product_name_flavour = $self->{combo_box_impact_product_name}->GetValue();
    my $project_name = $self->{combo_box_impact_projects}->GetValue();

    foreach my $impact_product (@{$self->{impact_products}})
    {
        if ("$impact_product->{product_name}-$impact_product->{flavour}" eq $product_name_flavour)
        {
            $self->{combo_box_impact_project_version}->Clear();
            $self->{combo_box_impact_project_version}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));

            foreach my $impact_project (@{$impact_product->{impact_projects}})
            {
                if ($impact_project->{project_name} eq $project_name)
                {
                    $self->{combo_box_impact_project_version}->Append($impact_project->{project_version});
                }
            }
        }
    }

    $self->{combo_box_impact_projects}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));

    return;

    # wxGlade: DPOPanelPool::on_combo_box_impact_projects <event_handler>
    warn "Event handler (on_combo_box_impact_projects) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_combo_box_impact_project_version
{
    my ($self, $event) = @_;

    $self->{combo_box_impact_project_version}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));

    return;

    # wxGlade: DPOPanelPool::on_combo_box_impact_project_version <event_handler>
    warn "Event handler (on_combo_box_impact_project_version) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_checkbox_impact_any_version
{
    my ($self, $event) = @_;

    if ($self->{checkbox_impact_any_version}->GetValue())
    {
        $self->{combo_box_impact_project_version}->SetBackgroundColour(Wx::Colour->new(192, 192, 192));
    }
    else
    {
        if ($self->{combo_box_impact_project_version}->GetValue() eq "")
        {
            $self->{combo_box_impact_project_version}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
        }
        else
        {
            $self->{combo_box_impact_project_version}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
        }
    }

    $self->Refresh();

    return;


    # wxGlade: DPOPanelPool::on_checkbox_impact_any_version <event_handler>
    warn "Event handler (on_checkbox_impact_any_version) not implemented";
    $event->Skip;
    # end wxGlade
}

sub on_button_impact_find
{
    my ($self, $event) = @_;

    my $product_name = $self->{combo_box_impact_product_name};
    my $project_name = $self->{combo_box_impact_projects};
    my $project_version = $self->{combo_box_impact_project_version};

    my $wait = Wx::BusyCursor->new();

    my $pool_path = $self->{text_ctrl_impact_current_pool_root}->GetValue();

    my @paths;
    if (!$self->get_path_with_dpoproduct_xml($pool_path, \@paths))
    {
        return;
    }

    foreach my $path (@paths) # foreach product
    {
        $path =~ s/\\/\//g;

        my $config_product = DPOProductConfig->new("$path/DPOProduct.xml");
        if ($config_product)
        {
            my $product;
            $config_product->get_product(\$product);
        }
        else
        {
            DPOLog::report_msg(DPOEvents::LOAD_PRODUCT_FAILURE, ["$path/DPOProduct.xml"]);
        }
    }

    return;

    # wxGlade: DPOPanelPool::on_button_impact_find <event_handler>
    warn "Event handler (on_button_impact_find) not implemented";
    $event->Skip;
    # end wxGlade
}




sub on_combo_box_pool_products_names
{
    my ($self, $event) = @_;

    my $product_name = $self->{combo_box_pool_products_names}->GetValue();

    if ($product_name ne "")
    {
        $self->{combo_box_pool_products_versions}->Clear();

        foreach my $version (@{$self->{products_to_activate_dependencies}->{$product_name}})
        {
            $self->{combo_box_pool_products_versions}->Append($version);
            print "      $version\n";
        }
    }

    return;

    # wxGlade: DPOPanelPool::on_combo_box_pool_products_names <event_handler>
    warn "Event handler (on_combo_box_pool_products_names) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_button_get_product_dependencies
{
    my ($self, $event) = @_;

    my $product_name = $self->{combo_box_pool_products_names}->GetValue();
    if ($product_name eq "")
    {
        Wx::MessageBox("No product selected");
        return;
    }

    my $version = $self->{combo_box_pool_products_versions}->GetValue();
    if ($version eq "")
    {
        Wx::MessageBox("No version selected");
        return;
    }

    Wx::MessageBox("Not implemented yet");

    # Obtenir un objet DPOProduct  partir de $product_name
    # Si compliant
    #   extraire les projets correspondants  la $version du produit (avec dpo_versions.log)
    #   extraire les dpendances rcursivement
    #   extraire aussi les runtimes et ses dpendances
    #   activer chaque projet (_PRJ_ROOT) et chaque produit (_ROOT)
    # Si non compliant
    #   extraire les runtimes et ses dpendances
    #   activer chaque projet (_PRJ_ROOT) et chaque produit (_ROOT)

    return;

    # wxGlade: DPOPanelPool::on_button_button_get_product_dependencies <event_handler>
    warn "Event handler (on_button_button_get_product_dependencies) not implemented";
    $event->Skip;
    # end wxGlade
}

# end of class DPOPanelPool

1;

