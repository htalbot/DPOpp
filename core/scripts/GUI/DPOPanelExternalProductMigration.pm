use lib $ENV{DPO_CORE_ROOT} . "/scripts";

# generated by wxGlade 0.6.8 on Fri Sep 04 05:22:39 2015
#
# To get wxPerl visit http://wxPerl.sourceforge.net/
#

use Wx 0.15 qw[:allclasses];
use strict;
use List::MoreUtils;
use DPOUtils;
use DPOProduct;
use DPOEnvVars;
use DPOEvents;
use DPONewProductACE;
use DPONewProductOpenDDS;
use DPOAutoDiscoverMPBDlg;
use DPOExternalMigrationNonMPCCompliantNewDirDlg;
use DPONonMPCLibAssociationDlg;

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

# Drag and drop class
package DPONewProductFrameDropTarget;

use Wx qw[:everything];
#~ use Wx::DND;
use base qw( Wx::TextDropTarget );

sub new
{
    my $class = shift;
    my $dpo_new_product_frame= shift;

    my $self = $class->SUPER::new(@_);

    $self->{dpo_new_product_frame} = $dpo_new_product_frame;

    return $self;
}

sub OnDropText
{
    my ( $self, $x, $y, $source ) = @_;

    $self->{dpo_new_product_frame}->drag_copy($x, $y, $source);

    return 1;    # important
}

1;


package MPCCompliantNode;

sub new
{
    my ($class,
        $path,
        $id) = @_;

    my $self =
    {
        id => $id,
        path => $path,
        type => "",
        build_config => DPOUtils::BUILD_CONFIG_NOT_SET,
        mpb_file => "",
        plugin => 0,
        sub_dpo_lib_entry => []
    };

    bless($self, $class);

    $self->{relative_path} = ""; # relative_path is specific to non_mpc_compliant_libs/bins

    my $complete = "$path/$id";

    if (-d $complete)
    {
        $self->add_sub_dpo_lib_entry($complete);
    }

    return $self;
}

sub add_sub_dpo_lib_entry
{
    my ($self, $path) = @_;

    my @content;
    if (DPOUtils::get_dir_content($path, \@content))
    {
        foreach my $x (@content)
        {
            $path =~ s/\\/\//g;
            my $new_element = MPCCompliantNode->new($path, $x);

            push(@{$self->{sub_dpo_lib_entry}}, $new_element);

            my $complete = "$path/$x";
            if (-d $complete)
            {
                $new_element->add_sub_dpo_lib_entry($complete);
            }
        }
    }
}

1;


package NonMPCCompliantNode;

sub new
{
    my ($class,
        $id,
        $node_or_leaf, # 0: node, 1: leaf
        $nameable,
        $source,
        $parent,
        $reserved) = @_;

    my $self =
    {
        id => $id,
        node_or_leaf => $node_or_leaf,
        nameable => $nameable,
        source => $source,
        parent => $parent,
        reserved => $reserved,
        type => "", # static/dynamic
        build_config => DPOUtils::BUILD_CONFIG_NOT_SET, # Debug/release
        mpb_file => "",
        plugin => 0 # true/false
    };

    bless($self, $class);

    $self->{nodes} = [];

    return $self;
}

sub find_node
{
    my ($self, $path) = @_;

    my $node = 0;

    if ($path eq $self->{id})
    {
        return $self;
    }

    my ($a, $b) = $path =~ /($self->{id})\/(.*)/;
    if (!defined($b))
    {
        return 0;
    }

    foreach my $n (@{$self->{nodes}})
    {
        $node = $n->find_node($b);
        if ($node)
        {
            last;
        }
    }

    return $node;
}

sub add
{
    my ($self, $new_node_id, $node_or_leaf, $nameable, $source, $reserved) = @_;

    my $node = 0;

    if (!List::MoreUtils::any {$_->{id} eq $new_node_id} @{$self->{nodes}})
    {
        #~ print "Adding $new_node_id ($node_or_leaf) in $self->{id}\n";
        $node = NonMPCCompliantNode->new($new_node_id, $node_or_leaf, $nameable, $source, $self, $reserved);
        push(@{$self->{nodes}}, $node);
    }

    return $node;
}

sub remove
{
    my ($self, $element) = @_;

    if (List::MoreUtils::any {$_->{id} eq $element} @{$self->{nodes}})
    {
        #~ print "Removing $element from $self->{id}\n";
        @{$self->{nodes}} = grep { "$_->{id}" ne $element } @{$self->{nodes}};
    }
}

sub get_leaves
{
    my ($self, $leaves_ref) = @_;

    if ($self->{node_or_leaf} eq "leaf")
    {
        push(@$leaves_ref, $self);
    }

    foreach my $n (@{$self->{nodes}})
    {
        $n->get_leaves($leaves_ref);
    }
}

sub get_parent_path
{
    my ($self) = @_;

    my $path = "";
    my $parent = $self->{parent};
    while ($parent != 0)
    {
        $path = "$parent->{id}/$path";
        $parent = $parent->{parent};
    }

    return $path;
}

sub uid
{
    my ($self) = @_;
    return $self->get_parent_path() . "$self->{id}";
}

sub uid_with_no_pool_path
{
    my ($self, $pool_path) = @_;

    my ($pre, $id) = $self->uid() =~ /($pool_path)\/(.*)/;

    return $id;
}

sub remove_far_node
{
    my ($self, $path) = @_;

    my $id = "";
    my $rest = "";
    if ($path =~ /(.*?)\/(.*)/)
    {
        $id = $1;
        $rest = $2;
    }
    else
    {
        $self->remove($path); # Removed if found
        return 1;
    }

    # Look deeper...
    foreach my $node (@{$self->{nodes}})
    {
        if ($node->{id} eq $id)
        {
            if (defined($rest))
            {
                if ($node->remove_far_node($rest))
                {
                    return 1;
                }
            }
        }
    }

    return 0;
}

1;


package NonMPCCompliantContent;

sub new
{
    my ($class,
        $id,
        $dir_or_file,
        $path) = @_;

    my $self =
    {
        id => $id,
        dir_or_file => $dir_or_file
    };

    bless($self, $class);

    $self->{elements} = [];

    if (defined($path))
    {
        my @content;
        if (DPOUtils::get_dir_content($path, \@content))
        {
            foreach my $x (@content)
            {
                my $complete = "$path/$x";

                if (-d $complete)
                {
                    my $element = NonMPCCompliantContent->new($x, "dir", $complete);
                    push(@{$self->{elements}}, $element);
                }
                else
                {
                    if (-f $complete) # Just to be sure that's a file.
                    {
                        my $element = NonMPCCompliantContent->new($x, "file");
                        push(@{$self->{elements}}, $element);
                    }
                }
            }
        }
    }

    return $self;
}

1;

package DPOMPBInfo;

sub new
{
    my ($class,
        $id,
        $lib_id,
        $mpc_includes) = @_;

    my $self =
    {
        id => $id,
        lib_id => $lib_id,
        mpc_includes => $mpc_includes
    };

    bless($self, $class);

    return $self;
}


package DPOMPCCompliantModule;

sub new
{
    my ($class,
        $module_name,
        $path) = @_;

    my $self =
    {
        module_name => $module_name,
        path => $path,
        mpbs_infos => [],
        type => "",
        build_config => DPOUtils::BUILD_CONFIG_NOT_SET,
        lib_id => "",
        plugin => 0,
        relevant_mpbs_infos => []
    };

    bless($self, $class);

    return $self;
}

1;


package DPOPanelExternalProductMigration;

use Wx qw[:everything];
use base qw(Wx::Panel);
use Wx::Locale 'gettext' => '_T', 'gettext_noop' => 'gettext_noop';

use constant
{
    NON_MPC_COMPLIANT_NEW_DIRECTORY => 0,
    NON_MPC_COMPLIANT_REMOVE => 1,
    NON_MPC_COMPLIANT_RENAME => 2
};

use constant
{
    LIST_CTR_NON_MPC_COMPLIANT_COL_ID => 0,
    LIST_CTRL_NON_MPC_COMPLIANT_COL_TYPE => 1,
    LIST_CTRL_NON_MPC_COMPLIANT_COL_BUILD_CONFIG => 2,
    LIST_CTRL_NON_MPC_COMPLIANT_COL_MPB => 3,
    LIST_CTRL_NON_MPC_COMPLIANT_COL_PLUGIN => 4,
    LIST_CTRL_NON_MPC_COMPLIANT_MENU_STATIC => 5,
    LIST_CTRL_NON_MPC_COMPLIANT_MENU_DYNAMIC => 6,
    LIST_CTRL_NON_MPC_COMPLIANT_MENU_DEBUG => 7,
    LIST_CTRL_NON_MPC_COMPLIANT_MENU_RELEASE => 8,
    LIST_CTRL_NON_MPC_COMPLIANT_MENU_DEBUG_RELEASE => 9,
    LIST_CTRL_NON_MPC_COMPLIANT_MENU_PLUGIN => 10
};


sub new {
    my( $self, $parent, $id, $pos, $size, $style, $name ) = @_;
    $parent = undef              unless defined $parent;
    $id     = -1                 unless defined $id;
    $pos    = wxDefaultPosition  unless defined $pos;
    $size   = wxDefaultSize      unless defined $size;
    $name   = ""                 unless defined $name;

    # begin wxGlade: DPOPanelExternalProductMigration::new
    $style = wxTAB_TRAVERSAL
        unless defined $style;

    $self = $self->SUPER::new( $parent, $id, $pos, $size, $style, $name );
    $self->{notebook_non_dpo_compliant} = Wx::Notebook->new($self, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
    $self->{notebook_non_dpo_compliant_pane_mpc_compliant} = Wx::Panel->new($self->{notebook_non_dpo_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{combo_box_known_mpc_compliant_products} = Wx::ComboBox->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN|wxCB_READONLY);
    $self->{sizer_25_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Known products") );
    $self->{text_ctrl_mpc_compliant_product_root_path} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{button_browse_mpc_compliant_product_root_path} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("..."));
    $self->{sizer_7_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Root path") );
    $self->{text_ctrl_mpc_compliant_product_pool_path} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("vanilla"), wxDefaultPosition, wxDefaultSize, );
    $self->{button_browse_mpc_compliant_product_pool_path} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("..."));
    $self->{sizer_16_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Pool path (parent)") );
    $self->{button_mpc_compliant_product_load} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Load"));
    $self->{sizer_18_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Get it") );
    $self->{list_ctrl_mpc_compliant_libs} = Wx::ListCtrl->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{button_select_all} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Select all"));
    $self->{static_line_1} = Wx::StaticLine->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{button_mpc_compliant_as_static} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Static"));
    $self->{button_mpc_compliant_as_dynamic} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Dynamic"));
    $self->{button_mpc_compliant_as_debug} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Debug"));
    $self->{button_mpc_compliant_as_release} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Release"));
    $self->{button_mpc_compliant_plugins} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Plugin"));
    $self->{text_ctrl_mpc_compliant_product_name} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{sizer_31_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Product name") );
    $self->{text_ctrl_mpc_compliant_product_version} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{sizer_32_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Version") );
    $self->{text_ctrl_mpc_compliant_product_flavour} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("vanilla"), wxDefaultPosition, wxDefaultSize, );
    $self->{sizer_33_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Flavour") );
    $self->{button_mpc_compliant_set_product} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, wxID_ANY, _T("Set product"));
    $self->{notebook_non_dpo_compliant_pane_non_mpc_compliant} = Wx::Panel->new($self->{notebook_non_dpo_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{text_ctrl_non_mpc_compliant_root_path} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{button_non_mpc_compliant_browse_root_path} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("..."));
    $self->{sizer_40_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Root path") );
    $self->{text_ctrl_non_mpc_compliant_pool_path} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{button_non_mpc_compliant_browse_pool_path} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("..."));
    $self->{sizer_41_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Pool path (parent)") );
    $self->{text_ctrl_non_mpc_compliant_product_name} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{sizer_43_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Product name") );
    $self->{text_ctrl_non_mpc_compliant_product_version} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{sizer_44_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Product version") );
    $self->{text_ctrl_non_mpc_compliant_product_flavour} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{sizer_45_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Product flavour") );
    $self->{button_non_mpc_compliant_load} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Load"));
    $self->{button_non_mpc_compliant_reset} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Reset"));
    $self->{combo_box_non_mpc_compliant_test} = Wx::ComboBox->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [_T("no test"), _T("wxWidgets"), _T("External1")], wxCB_DROPDOWN);
    $self->{text_ctrl_non_mpc_compliant_tree_filter} = Wx::TextCtrl->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{button_non_mpc_compliant_tree_filter} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Filter"));
    $self->{sizer_24_staticbox} = Wx::StaticBox->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Filters on extensions") );
    $self->{tree_ctrl_non_mpc_compliant_tree_root_path} = Wx::TreeCtrl->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_MULTIPLE|wxTR_HIDE_ROOT|wxTR_MULTIPLE|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{button_collapse_all} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Collapse all"));
    $self->{notebook_non_mpc_compliant} = Wx::Notebook->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
    $self->{notebook_non_mpc_pane_info} = Wx::Panel->new($self->{notebook_non_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{text_ctrl_info} = Wx::TextCtrl->new($self->{notebook_non_mpc_pane_info}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE|wxTE_READONLY);
    $self->{notebook_non_mpc_pane_include} = Wx::Panel->new($self->{notebook_non_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_non_mpc_compliant_include} = Wx::TreeCtrl->new($self->{notebook_non_mpc_pane_include}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_EDIT_LABELS|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{notebook_non_mpc_pane_lib} = Wx::Panel->new($self->{notebook_non_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{splitter_lib} = Wx::SplitterWindow->new($self->{notebook_non_mpc_pane_lib}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_3D|wxSP_BORDER);
    $self->{splitter_lib_tree} = Wx::Panel->new($self->{splitter_lib}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_non_mpc_compliant_lib} = Wx::TreeCtrl->new($self->{splitter_lib_tree}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_EDIT_LABELS|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{splitter_lib_list} = Wx::Panel->new($self->{splitter_lib}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{list_ctrl_non_mpc_compliant_libs} = Wx::ListCtrl->new($self->{splitter_lib_list}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{checkbox_show_dll} = Wx::CheckBox->new($self->{splitter_lib_list}, wxID_ANY, _T("Show DLL"), wxDefaultPosition, wxDefaultSize, );
    $self->{button_mpb} = Wx::Button->new($self->{splitter_lib_list}, wxID_ANY, _T("MPB..."));
    $self->{notebook_non_mpc_pane_bin} = Wx::Panel->new($self->{notebook_non_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_non_mpc_compliant_bin} = Wx::TreeCtrl->new($self->{notebook_non_mpc_pane_bin}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_EDIT_LABELS|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{notebook_non_mpc_pane_etc} = Wx::Panel->new($self->{notebook_non_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_non_mpc_compliant_etc} = Wx::TreeCtrl->new($self->{notebook_non_mpc_pane_etc}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_EDIT_LABELS|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{notebook_non_mpc_pane_var} = Wx::Panel->new($self->{notebook_non_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_non_mpc_compliant_var} = Wx::TreeCtrl->new($self->{notebook_non_mpc_pane_var}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_EDIT_LABELS|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{notebook_non_mpc_pane_doc} = Wx::Panel->new($self->{notebook_non_mpc_compliant}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_non_mpc_compliant_doc} = Wx::TreeCtrl->new($self->{notebook_non_mpc_pane_doc}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_EDIT_LABELS|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{button_non_mpc_compliant_set_product} = Wx::Button->new($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, wxID_ANY, _T("Set product"));

    $self->__set_properties();
    $self->__do_layout();

    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_known_mpc_compliant_products}->GetId, \&on_combo_box_known_mpc_compliant_products);
    Wx::Event::EVT_TEXT($self, $self->{text_ctrl_mpc_compliant_product_root_path}->GetId, \&on_text_ctrl_mpc_compliant_product_root_path);
    Wx::Event::EVT_BUTTON($self, $self->{button_browse_mpc_compliant_product_root_path}->GetId, \&on_button_browse_mpc_compliant_product_root_path);
    Wx::Event::EVT_TEXT($self, $self->{text_ctrl_mpc_compliant_product_pool_path}->GetId, \&on_text_ctrl_mpc_compliant_product_pool_path);
    Wx::Event::EVT_BUTTON($self, $self->{button_browse_mpc_compliant_product_pool_path}->GetId, \&on_button_browse_mpc_compliant_product_pool_path);
    Wx::Event::EVT_BUTTON($self, $self->{button_mpc_compliant_product_load}->GetId, \&on_button_mpc_compliant_product_load);
    Wx::Event::EVT_LIST_COL_CLICK($self, $self->{list_ctrl_mpc_compliant_libs}->GetId, \&on_list_ctrl_mpc_compliant_libs_col_click);
    Wx::Event::EVT_BUTTON($self, $self->{button_select_all}->GetId, \&on_button_mpc_compliant_select_all);
    Wx::Event::EVT_BUTTON($self, $self->{button_mpc_compliant_as_static}->GetId, \&on_button_mpc_compliant_as_static);
    Wx::Event::EVT_BUTTON($self, $self->{button_mpc_compliant_as_dynamic}->GetId, \&on_button_mpc_compliant_as_dynamic);
    Wx::Event::EVT_BUTTON($self, $self->{button_mpc_compliant_as_debug}->GetId, \&on_button_mpc_compliant_as_debug);
    Wx::Event::EVT_BUTTON($self, $self->{button_mpc_compliant_as_release}->GetId, \&on_button_mpc_compliant_as_release);
    Wx::Event::EVT_BUTTON($self, $self->{button_mpc_compliant_plugins}->GetId, \&on_button_mpc_compliant_as_plugin);
    Wx::Event::EVT_BUTTON($self, $self->{button_mpc_compliant_set_product}->GetId, \&on_button_mpc_compliant_set_product);
    Wx::Event::EVT_BUTTON($self, $self->{button_non_mpc_compliant_browse_root_path}->GetId, \&on_button_non_mpc_compliant_browse_root_path);
    Wx::Event::EVT_BUTTON($self, $self->{button_non_mpc_compliant_browse_pool_path}->GetId, \&on_button_non_mpc_compliant_browse_pool_path);
    Wx::Event::EVT_BUTTON($self, $self->{button_non_mpc_compliant_load}->GetId, \&on_button_non_mpc_compliant_load);
    Wx::Event::EVT_BUTTON($self, $self->{button_non_mpc_compliant_reset}->GetId, \&on_button_non_mpc_compliant_reset);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_non_mpc_compliant_test}->GetId, \&on_combo_box_non_mpc_compliant_test);
    Wx::Event::EVT_BUTTON($self, $self->{button_non_mpc_compliant_tree_filter}->GetId, \&on_button_non_mpc_compliant_tree_filter);
    Wx::Event::EVT_TREE_BEGIN_DRAG($self, $self->{tree_ctrl_non_mpc_compliant_tree_root_path}->GetId, \&on_tree_ctrl_non_mpc_compliant_tree_root_path_begin_drag);
    Wx::Event::EVT_BUTTON($self, $self->{button_collapse_all}->GetId, \&on_button_collapse_all);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_non_mpc_compliant_include}->GetId, \&on_tree_ctrl_non_mpc_compliant_include_key_down);
    Wx::Event::EVT_TREE_END_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_include}->GetId, \&on_tree_ctrl_non_mpc_compliant_include_end_label_edit);
    Wx::Event::EVT_TREE_BEGIN_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_include}->GetId, \&on_tree_ctrl_non_mpc_compliant_include_begin_label_edit);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_non_mpc_compliant_lib}->GetId, \&on_tree_ctrl_non_mpc_compliant_lib_key_down);
    Wx::Event::EVT_TREE_END_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_lib}->GetId, \&on_tree_ctrl_non_mpc_compliant_lib_end_label_edit);
    Wx::Event::EVT_TREE_BEGIN_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_lib}->GetId, \&on_tree_ctrl_non_mpc_compliant_lib_begin_label_edit);
    Wx::Event::EVT_LIST_COL_CLICK($self, $self->{list_ctrl_non_mpc_compliant_libs}->GetId, \&list_ctrl_non_mpc_compliant_libs_col_click);
    Wx::Event::EVT_LIST_ITEM_RIGHT_CLICK($self, $self->{list_ctrl_non_mpc_compliant_libs}->GetId, \&list_ctrl_non_mpc_compliant_libs_right_click);
    Wx::Event::EVT_LIST_KEY_DOWN($self, $self->{list_ctrl_non_mpc_compliant_libs}->GetId, \&list_ctrl_non_mpc_compliant_libs_key_down);
    Wx::Event::EVT_CHECKBOX($self, $self->{checkbox_show_dll}->GetId, \&on_checkbox_show_dll);
    Wx::Event::EVT_BUTTON($self, $self->{button_mpb}->GetId, \&on_button_mpb);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_non_mpc_compliant_bin}->GetId, \&on_tree_ctrl_non_mpc_compliant_bin_key_down);
    Wx::Event::EVT_TREE_END_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_bin}->GetId, \&on_tree_ctrl_non_mpc_compliant_bin_end_label_edit);
    Wx::Event::EVT_TREE_BEGIN_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_bin}->GetId, \&on_tree_ctrl_non_mpc_compliant_bin_begin_label_edit);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_non_mpc_compliant_etc}->GetId, \&on_tree_ctrl_non_mpc_compliant_etc_key_down);
    Wx::Event::EVT_TREE_END_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_etc}->GetId, \&on_tree_ctrl_non_mpc_compliant_etc_end_label_edit);
    Wx::Event::EVT_TREE_BEGIN_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_etc}->GetId, \&on_tree_ctrl_non_mpc_compliant_etc_begin_label_edit);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_non_mpc_compliant_var}->GetId, \&on_tree_ctrl_non_mpc_compliant_var_key_down);
    Wx::Event::EVT_TREE_END_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_var}->GetId, \&on_tree_ctrl_non_mpc_compliant_var_end_label_edit);
    Wx::Event::EVT_TREE_BEGIN_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_var}->GetId, \&on_tree_ctrl_non_mpc_compliant_var_begin_label_edit);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_non_mpc_compliant_doc}->GetId, \&on_tree_ctrl_non_mpc_compliant_doc_key_down);
    Wx::Event::EVT_TREE_END_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_doc}->GetId, \&on_tree_ctrl_non_mpc_compliant_doc_end_label_edit);
    Wx::Event::EVT_TREE_BEGIN_LABEL_EDIT($self, $self->{tree_ctrl_non_mpc_compliant_doc}->GetId, \&on_tree_ctrl_non_mpc_compliant_doc_begin_label_edit);
    Wx::Event::EVT_NOTEBOOK_PAGE_CHANGED($self, $self->{notebook_non_mpc_compliant}->GetId, \&on_notebook_non_mpc_compliant_changed);
    Wx::Event::EVT_BUTTON($self, $self->{button_non_mpc_compliant_set_product}->GetId, \&on_button_non_mpc_compliant_set_product);

    # end wxGlade

    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_non_mpc_compliant_include}->GetId, \&on_tree_ctrl_non_mpc_compliant_menu);
    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_non_mpc_compliant_lib}->GetId, \&on_tree_ctrl_non_mpc_compliant_menu);
    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_non_mpc_compliant_bin}->GetId, \&on_tree_ctrl_non_mpc_compliant_menu);
    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_non_mpc_compliant_etc}->GetId, \&on_tree_ctrl_non_mpc_compliant_menu);
    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_non_mpc_compliant_var}->GetId, \&on_tree_ctrl_non_mpc_compliant_menu);
    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_non_mpc_compliant_doc}->GetId, \&on_tree_ctrl_non_mpc_compliant_menu);
    Wx::Event::EVT_MENU($self, NON_MPC_COMPLIANT_NEW_DIRECTORY, \&on_non_mpc_compliant_new_directory);
    Wx::Event::EVT_MENU($self, NON_MPC_COMPLIANT_REMOVE, \&on_non_mpc_compliant_remove);
    Wx::Event::EVT_MENU($self, NON_MPC_COMPLIANT_RENAME, \&on_non_mpc_compliant_rename);

    Wx::Event::EVT_MENU($self, LIST_CTRL_NON_MPC_COMPLIANT_MENU_STATIC, \&on_menu_static);
    Wx::Event::EVT_MENU($self, LIST_CTRL_NON_MPC_COMPLIANT_MENU_DYNAMIC, \&on_menu_dynamic);
    Wx::Event::EVT_MENU($self, LIST_CTRL_NON_MPC_COMPLIANT_MENU_DEBUG, \&on_menu_debug);
    Wx::Event::EVT_MENU($self, LIST_CTRL_NON_MPC_COMPLIANT_MENU_RELEASE, \&on_menu_release);
    Wx::Event::EVT_MENU($self, LIST_CTRL_NON_MPC_COMPLIANT_MENU_DEBUG_RELEASE, \&on_menu_debug_release);
    Wx::Event::EVT_MENU($self, LIST_CTRL_NON_MPC_COMPLIANT_MENU_PLUGIN, \&on_menu_plugin);

    # Non DPO compliant but MPC compliant
    $self->create_list_ctrl_mpc_compliant_libs();

    $self->{list_ctrl_mpc_compliant_libs_order_col_0} = 1;
    $self->{list_ctrl_mpc_compliant_libs_order_col_1} = 1;
    # $self->{list_ctrl_mpc_compliant_libs_order_col_2} = 1;
    $self->{list_ctrl_mpc_compliant_libs_order_col_3} = 1;
    $self->{list_ctrl_mpc_compliant_libs_order_col_4} = 1;
    $self->{list_ctrl_mpc_compliant_libs_order_col_5} = 1;

    # Non DPO compliant and non MPC compliant
    $self->create_list_ctrl_non_mpc_compliant_libs();

    $self->{list_ctrl_non_mpc_compliant_libs_order_col_id} = 1;
    $self->{list_ctrl_non_mpc_compliant_libs_order_col_type} = 1;
    $self->{list_ctrl_non_mpc_compliant_libs_order_col_plugin} = 1;
    $self->{list_ctrl_non_mpc_compliant_libs_order_col_build_config} = 1;
    $self->{list_ctrl_non_mpc_compliant_libs_order_col_mpb} = 1;

    $self->SetDropTarget(DPONewProductFrameDropTarget->new($self));

    $self->{combo_box_known_mpc_compliant_products}->Append("ACE");
    $self->{combo_box_known_mpc_compliant_products}->Append("OpenDDS");

    $self->{image_list} = Wx::ImageList->new(16, 16, 1);
    my $env_var_id =  "\$(DPO_CORE_ROOT)/scripts";
    my $dpo_scripts_path = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$dpo_scripts_path))
    {
        Wx::MessageBox("DPO_CORE_ROOT not defined", "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }
    $self->{image_list}->Add(Wx::Icon->new("$dpo_scripts_path/folder.ico", wxBITMAP_TYPE_ICO));
    $self->{image_list}->Add(Wx::Icon->new("$dpo_scripts_path/file.ico", wxBITMAP_TYPE_ICO));

    $self->{tree_ctrl_non_mpc_compliant_tree_root_path}->SetImageList($self->{image_list});
    $self->{tree_ctrl_non_mpc_compliant_include}->SetImageList($self->{image_list});
    $self->{tree_ctrl_non_mpc_compliant_lib}->SetImageList($self->{image_list});
    $self->{tree_ctrl_non_mpc_compliant_bin}->SetImageList($self->{image_list});
    $self->{tree_ctrl_non_mpc_compliant_etc}->SetImageList($self->{image_list});
    $self->{tree_ctrl_non_mpc_compliant_var}->SetImageList($self->{image_list});
    $self->{tree_ctrl_non_mpc_compliant_doc}->SetImageList($self->{image_list});

    $self->{text_ctrl_mpc_compliant_product_flavour}->SetValue("vanilla");
    $self->{text_ctrl_non_mpc_compliant_product_flavour}->SetValue("vanilla");

    my $dpo_pool_path =  "\$(DPO_POOL_ROOT)/vc10/thirdparty";
    DPOEnvVars::expand_env_var(\$dpo_pool_path);
    $self->{text_ctrl_non_mpc_compliant_pool_path}->SetValue($dpo_pool_path);

    $self->set_filter_text("info");

    $self->{text_ctrl_info}->SetValue(
        "At this stage, we have to select all the files to copy to make ".
        "the product useful both for the compilation and runtime.\n\n".
        "Click on each tab to view the files that are likely ".
        "to be part of the product. They will appear in the tree ".
        "at the left. From this tree we can filter the display by ".
        "entering file extensions separated by comma. For example: .lib; .dll. ".
        "Once the files are displayed in the tree, we can drag them into ".
        "the selected tab.\n\n".
        "For the 'lib' tab, we have to do extra work. For each library (.lib ".
        "only in Windows), we have to determine if ".
        "the library is static or dynamic and possibly a plugin (a module ".
        "loaded explicitly at runtime). Once all libraries have been defined ".
        "as static/dynamic, we have to define the associated MPB file by ".
        "clicking on 'MPB...' button.\n\n".
        "For other stuff than include/lib/bin/etc/var/doc, please copy it manually.\n\n".
        "Once all the files have been selected, we can click on 'Set product' ".
        "button to actually copy the files.");

    $self->{button_mpb}->Enable(0);

    $self->{notebook_non_mpc_compliant}->Enable(0);

    if ($^O =~ /Win/)
    {
        $self->{checkbox_show_dll}->Show(1);
    }
    else
    {
        $self->{checkbox_show_dll}->Show(0);
    }

    $self->{button_non_mpc_compliant_reset}->Enable(0);

    $self->{previous_non_mpc_compliant_root_path} = "";
    $self->{previous_non_mpc_compliant_pool_path} = $dpo_pool_path;
    $self->{previous_non_mpc_compliant_product_name} = "";
    $self->{previous_non_mpc_compliant_product_version} = "";
    $self->{previous_non_mpc_compliant_product_flavour} = "";
    $self->{previous_non_mpc_compliant_test_choice} = "";

    $self->{combo_box_non_mpc_compliant_test}->SetValue("no test");
    $self->{previous_non_mpc_compliant_test_choice} = "no test";

    # TESTS: use Show(1)
    $self->{combo_box_non_mpc_compliant_test}->Show(1);

    return $self;
}


sub __set_properties {
    my $self = shift;
    # begin wxGlade: DPOPanelExternalProductMigration::__set_properties
    $self->{combo_box_known_mpc_compliant_products}->SetMinSize(Wx::Size->new(100, -1));
    $self->{combo_box_known_mpc_compliant_products}->SetSelection(-1);
    $self->{text_ctrl_mpc_compliant_product_root_path}->SetMinSize(Wx::Size->new(350, -1));
    $self->{text_ctrl_mpc_compliant_product_root_path}->SetToolTipString(_T("Choose the right version of ACE. If you edit version manually, press enter to accept."));
    $self->{button_browse_mpc_compliant_product_root_path}->SetMinSize(Wx::Size->new(20, -1));
    $self->{text_ctrl_mpc_compliant_product_pool_path}->SetMinSize(Wx::Size->new(350, -1));
    $self->{button_browse_mpc_compliant_product_pool_path}->SetMinSize(Wx::Size->new(20, -1));
    $self->{button_non_mpc_compliant_browse_root_path}->SetMinSize(Wx::Size->new(20, -1));
    $self->{button_non_mpc_compliant_browse_pool_path}->SetMinSize(Wx::Size->new(20, -1));
    $self->{combo_box_non_mpc_compliant_test}->SetSelection(-1);
    $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetToolTipString(_T("Separated by ';'"));
    $self->{button_non_mpc_compliant_tree_filter}->SetBackgroundColour(Wx::Colour->new(212, 208, 200));
    $self->{tree_ctrl_non_mpc_compliant_include}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
    $self->{splitter_lib}->SetMinSize(Wx::Size->new(818, 349));
    # end wxGlade
}

sub __do_layout {
    my $self = shift;
    # begin wxGlade: DPOPanelExternalProductMigration::__do_layout
    $self->{sizer_1} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_3} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_19} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_26} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_14} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_12} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_5} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_42} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_6} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_113} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_15} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_111} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_36} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_46} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_35} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_48} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_24_staticbox}->Lower();
    $self->{sizer_24} = Wx::StaticBoxSizer->new($self->{sizer_24_staticbox}, wxHORIZONTAL);
    $self->{sizer_123} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_38} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_45_staticbox}->Lower();
    $self->{sizer_45} = Wx::StaticBoxSizer->new($self->{sizer_45_staticbox}, wxHORIZONTAL);
    $self->{sizer_44_staticbox}->Lower();
    $self->{sizer_44} = Wx::StaticBoxSizer->new($self->{sizer_44_staticbox}, wxHORIZONTAL);
    $self->{sizer_43_staticbox}->Lower();
    $self->{sizer_43} = Wx::StaticBoxSizer->new($self->{sizer_43_staticbox}, wxHORIZONTAL);
    $self->{sizer_39} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_41_staticbox}->Lower();
    $self->{sizer_41} = Wx::StaticBoxSizer->new($self->{sizer_41_staticbox}, wxHORIZONTAL);
    $self->{sizer_40_staticbox}->Lower();
    $self->{sizer_40} = Wx::StaticBoxSizer->new($self->{sizer_40_staticbox}, wxHORIZONTAL);
    $self->{sizer_9} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_8} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_11} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_27} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_30} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_34} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_33_staticbox}->Lower();
    $self->{sizer_33} = Wx::StaticBoxSizer->new($self->{sizer_33_staticbox}, wxHORIZONTAL);
    $self->{sizer_32_staticbox}->Lower();
    $self->{sizer_32} = Wx::StaticBoxSizer->new($self->{sizer_32_staticbox}, wxHORIZONTAL);
    $self->{sizer_31_staticbox}->Lower();
    $self->{sizer_31} = Wx::StaticBoxSizer->new($self->{sizer_31_staticbox}, wxHORIZONTAL);
    $self->{sizer_28} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_29} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_17} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_18_staticbox}->Lower();
    $self->{sizer_18} = Wx::StaticBoxSizer->new($self->{sizer_18_staticbox}, wxHORIZONTAL);
    $self->{sizer_16_staticbox}->Lower();
    $self->{sizer_16} = Wx::StaticBoxSizer->new($self->{sizer_16_staticbox}, wxHORIZONTAL);
    $self->{sizer_7_staticbox}->Lower();
    $self->{sizer_7} = Wx::StaticBoxSizer->new($self->{sizer_7_staticbox}, wxHORIZONTAL);
    $self->{sizer_25_staticbox}->Lower();
    $self->{sizer_25} = Wx::StaticBoxSizer->new($self->{sizer_25_staticbox}, wxHORIZONTAL);
    $self->{sizer_25}->Add($self->{combo_box_known_mpc_compliant_products}, 0, 0, 0);
    $self->{sizer_17}->Add($self->{sizer_25}, 0, 0, 0);
    $self->{sizer_7}->Add($self->{text_ctrl_mpc_compliant_product_root_path}, 1, 0, 0);
    $self->{sizer_7}->Add($self->{button_browse_mpc_compliant_product_root_path}, 0, wxLEFT, 3);
    $self->{sizer_17}->Add($self->{sizer_7}, 1, wxLEFT, 5);
    $self->{sizer_16}->Add($self->{text_ctrl_mpc_compliant_product_pool_path}, 1, wxEXPAND, 0);
    $self->{sizer_16}->Add($self->{button_browse_mpc_compliant_product_pool_path}, 0, wxLEFT, 3);
    $self->{sizer_17}->Add($self->{sizer_16}, 1, wxLEFT, 5);
    $self->{sizer_18}->Add($self->{button_mpc_compliant_product_load}, 0, wxALIGN_BOTTOM, 0);
    $self->{sizer_17}->Add($self->{sizer_18}, 0, wxLEFT|wxEXPAND, 5);
    $self->{sizer_8}->Add($self->{sizer_17}, 0, wxALL|wxEXPAND, 5);
    $self->{sizer_28}->Add($self->{list_ctrl_mpc_compliant_libs}, 1, wxALL|wxEXPAND, 10);
    $self->{sizer_29}->Add($self->{button_select_all}, 0, wxALL, 5);
    $self->{sizer_29}->Add($self->{static_line_1}, 0, wxTOP|wxBOTTOM|wxEXPAND, 5);
    $self->{sizer_29}->Add($self->{button_mpc_compliant_as_static}, 0, wxALL, 5);
    $self->{sizer_29}->Add($self->{button_mpc_compliant_as_dynamic}, 0, wxALL, 5);
    $self->{sizer_29}->Add($self->{button_mpc_compliant_as_debug}, 0, wxALL, 5);
    $self->{sizer_29}->Add($self->{button_mpc_compliant_as_release}, 0, wxALL, 5);
    $self->{sizer_29}->Add($self->{button_mpc_compliant_plugins}, 0, wxALL, 5);
    $self->{sizer_28}->Add($self->{sizer_29}, 0, wxRIGHT|wxALIGN_CENTER_VERTICAL, 5);
    $self->{sizer_27}->Add($self->{sizer_28}, 1, wxEXPAND, 0);
    $self->{sizer_31}->Add($self->{text_ctrl_mpc_compliant_product_name}, 1, wxEXPAND, 0);
    $self->{sizer_30}->Add($self->{sizer_31}, 1, wxEXPAND, 0);
    $self->{sizer_32}->Add($self->{text_ctrl_mpc_compliant_product_version}, 1, wxEXPAND, 0);
    $self->{sizer_30}->Add($self->{sizer_32}, 1, wxLEFT|wxEXPAND, 3);
    $self->{sizer_33}->Add($self->{text_ctrl_mpc_compliant_product_flavour}, 1, wxEXPAND, 0);
    $self->{sizer_30}->Add($self->{sizer_33}, 1, wxLEFT|wxEXPAND, 3);
    $self->{sizer_34}->Add($self->{button_mpc_compliant_set_product}, 0, wxLEFT|wxRIGHT|wxTOP|wxALIGN_CENTER_VERTICAL, 10);
    $self->{sizer_30}->Add($self->{sizer_34}, 0, wxEXPAND, 0);
    $self->{sizer_27}->Add($self->{sizer_30}, 0, wxALL|wxEXPAND, 10);
    $self->{sizer_11}->Add($self->{sizer_27}, 2, wxEXPAND, 0);
    $self->{sizer_8}->Add($self->{sizer_11}, 1, wxEXPAND, 0);
    $self->{sizer_9}->Add($self->{sizer_8}, 1, wxEXPAND, 0);
    $self->{notebook_non_dpo_compliant_pane_mpc_compliant}->SetSizer($self->{sizer_9});
    $self->{sizer_40}->Add($self->{text_ctrl_non_mpc_compliant_root_path}, 1, wxEXPAND, 0);
    $self->{sizer_40}->Add($self->{button_non_mpc_compliant_browse_root_path}, 0, 0, 0);
    $self->{sizer_39}->Add($self->{sizer_40}, 1, 0, 0);
    $self->{sizer_41}->Add($self->{text_ctrl_non_mpc_compliant_pool_path}, 1, wxEXPAND, 0);
    $self->{sizer_41}->Add($self->{button_non_mpc_compliant_browse_pool_path}, 0, 0, 0);
    $self->{sizer_39}->Add($self->{sizer_41}, 1, wxEXPAND, 0);
    $self->{sizer_3}->Add($self->{sizer_39}, 0, wxEXPAND, 5);
    $self->{sizer_43}->Add($self->{text_ctrl_non_mpc_compliant_product_name}, 1, wxEXPAND, 0);
    $self->{sizer_38}->Add($self->{sizer_43}, 1, wxEXPAND, 0);
    $self->{sizer_44}->Add($self->{text_ctrl_non_mpc_compliant_product_version}, 1, wxEXPAND, 0);
    $self->{sizer_38}->Add($self->{sizer_44}, 1, wxEXPAND, 0);
    $self->{sizer_45}->Add($self->{text_ctrl_non_mpc_compliant_product_flavour}, 1, wxEXPAND, 0);
    $self->{sizer_38}->Add($self->{sizer_45}, 1, wxEXPAND, 0);
    $self->{sizer_3}->Add($self->{sizer_38}, 0, wxTOP|wxBOTTOM|wxEXPAND, 5);
    $self->{sizer_123}->Add($self->{button_non_mpc_compliant_load}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{sizer_123}->Add($self->{button_non_mpc_compliant_reset}, 0, wxLEFT, 5);
    $self->{sizer_123}->Add($self->{combo_box_non_mpc_compliant_test}, 0, wxLEFT, 3);
    $self->{sizer_3}->Add($self->{sizer_123}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{sizer_24}->Add($self->{text_ctrl_non_mpc_compliant_tree_filter}, 1, 0, 0);
    $self->{sizer_24}->Add($self->{button_non_mpc_compliant_tree_filter}, 0, wxLEFT, 3);
    $self->{sizer_48}->Add($self->{sizer_24}, 0, wxEXPAND, 0);
    $self->{sizer_48}->Add($self->{tree_ctrl_non_mpc_compliant_tree_root_path}, 1, wxALL|wxEXPAND, 5);
    $self->{sizer_48}->Add($self->{button_collapse_all}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{sizer_26}->Add($self->{sizer_48}, 1, wxEXPAND, 0);
    $self->{sizer_35}->Add($self->{text_ctrl_info}, 1, wxEXPAND, 0);
    $self->{notebook_non_mpc_pane_info}->SetSizer($self->{sizer_35});
    $self->{sizer_46}->Add($self->{tree_ctrl_non_mpc_compliant_include}, 1, wxEXPAND, 0);
    $self->{sizer_36}->Add($self->{sizer_46}, 1, wxEXPAND, 0);
    $self->{notebook_non_mpc_pane_include}->SetSizer($self->{sizer_36});
    $self->{sizer_111}->Add($self->{tree_ctrl_non_mpc_compliant_lib}, 1, wxEXPAND, 0);
    $self->{splitter_lib_tree}->SetSizer($self->{sizer_111});
    $self->{sizer_113}->Add($self->{list_ctrl_non_mpc_compliant_libs}, 1, wxEXPAND, 0);
    $self->{sizer_15}->Add($self->{checkbox_show_dll}, 0, wxALIGN_CENTER_VERTICAL, 5);
    $self->{sizer_15}->Add($self->{button_mpb}, 0, wxALL, 5);
    $self->{sizer_113}->Add($self->{sizer_15}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{splitter_lib_list}->SetSizer($self->{sizer_113});
    $self->{splitter_lib}->SplitVertically($self->{splitter_lib_tree}, $self->{splitter_lib_list}, );
    $self->{sizer_6}->Add($self->{splitter_lib}, 1, wxEXPAND, 0);
    $self->{notebook_non_mpc_pane_lib}->SetSizer($self->{sizer_6});
    $self->{sizer_42}->Add($self->{tree_ctrl_non_mpc_compliant_bin}, 1, wxEXPAND, 0);
    $self->{notebook_non_mpc_pane_bin}->SetSizer($self->{sizer_42});
    $self->{sizer_5}->Add($self->{tree_ctrl_non_mpc_compliant_etc}, 1, wxEXPAND, 0);
    $self->{notebook_non_mpc_pane_etc}->SetSizer($self->{sizer_5});
    $self->{sizer_12}->Add($self->{tree_ctrl_non_mpc_compliant_var}, 1, wxEXPAND, 0);
    $self->{notebook_non_mpc_pane_var}->SetSizer($self->{sizer_12});
    $self->{sizer_14}->Add($self->{tree_ctrl_non_mpc_compliant_doc}, 1, wxEXPAND, 0);
    $self->{notebook_non_mpc_pane_doc}->SetSizer($self->{sizer_14});
    $self->{notebook_non_mpc_compliant}->AddPage($self->{notebook_non_mpc_pane_info}, _T("info"));
    $self->{notebook_non_mpc_compliant}->AddPage($self->{notebook_non_mpc_pane_include}, _T("include"));
    $self->{notebook_non_mpc_compliant}->AddPage($self->{notebook_non_mpc_pane_lib}, _T("lib"));
    $self->{notebook_non_mpc_compliant}->AddPage($self->{notebook_non_mpc_pane_bin}, _T("bin"));
    $self->{notebook_non_mpc_compliant}->AddPage($self->{notebook_non_mpc_pane_etc}, _T("etc"));
    $self->{notebook_non_mpc_compliant}->AddPage($self->{notebook_non_mpc_pane_var}, _T("var"));
    $self->{notebook_non_mpc_compliant}->AddPage($self->{notebook_non_mpc_pane_doc}, _T("doc"));
    $self->{sizer_26}->Add($self->{notebook_non_mpc_compliant}, 2, wxALL|wxEXPAND, 5);
    $self->{sizer_3}->Add($self->{sizer_26}, 1, wxTOP|wxEXPAND, 5);
    $self->{sizer_19}->Add($self->{button_non_mpc_compliant_set_product}, 0, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_3}->Add($self->{sizer_19}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 10);
    $self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}->SetSizer($self->{sizer_3});
    $self->{notebook_non_dpo_compliant}->AddPage($self->{notebook_non_dpo_compliant_pane_mpc_compliant}, _T("MPC Compliant"));
    $self->{notebook_non_dpo_compliant}->AddPage($self->{notebook_non_dpo_compliant_pane_non_mpc_compliant}, _T("Non MPC Compliant"));
    $self->{sizer_1}->Add($self->{notebook_non_dpo_compliant}, 1, wxEXPAND, 0);
    $self->SetSizer($self->{sizer_1});
    $self->{sizer_1}->Fit($self);
    # end wxGlade
}

sub create_list_ctrl_mpc_compliant_libs
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetText("Module name");
    $col->SetWidth(150);
    $self->{list_ctrl_mpc_compliant_libs}->InsertColumn(0, $col);

    $col = Wx::ListItem->new();
    $col->SetText("Library ID");
    $col->SetWidth(150);
    $self->{list_ctrl_mpc_compliant_libs}->InsertColumn(1, $col);

    $col->SetText("mpbs");
    $col->SetWidth(200);
    $self->{list_ctrl_mpc_compliant_libs}->InsertColumn(2, $col);

    $col->SetText("Static/Dynamic");
    $col->SetWidth(100);
    $self->{list_ctrl_mpc_compliant_libs}->InsertColumn(3, $col);

    $col->SetText("Debug/Release");
    $col->SetWidth(100);
    $self->{list_ctrl_mpc_compliant_libs}->InsertColumn(4, $col);

    $col->SetText("Plugins");
    $col->SetWidth(100);
    $self->{list_ctrl_mpc_compliant_libs}->InsertColumn(5, $col);
}

sub create_list_ctrl_non_mpc_compliant_libs
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetText("Libraries");
    $col->SetWidth(200);
    $self->{list_ctrl_non_mpc_compliant_libs}->InsertColumn(LIST_CTR_NON_MPC_COMPLIANT_COL_ID, $col);

    $col->SetText("Static/Dynamic");
    $col->SetWidth(100);
    $self->{list_ctrl_non_mpc_compliant_libs}->InsertColumn(LIST_CTRL_NON_MPC_COMPLIANT_COL_TYPE, $col);

    $col->SetText("Debug/Release");
    $col->SetWidth(100);
    $self->{list_ctrl_non_mpc_compliant_libs}->InsertColumn(LIST_CTRL_NON_MPC_COMPLIANT_COL_BUILD_CONFIG, $col);

    $col->SetText("MPB file");
    $col->SetWidth(150);
    $self->{list_ctrl_non_mpc_compliant_libs}->InsertColumn(LIST_CTRL_NON_MPC_COMPLIANT_COL_MPB, $col);

    $col->SetText("Plugin");
    $col->SetWidth(60);
    $self->{list_ctrl_non_mpc_compliant_libs}->InsertColumn(LIST_CTRL_NON_MPC_COMPLIANT_COL_PLUGIN, $col);
}

sub set_filter_text
{
    my ($self, $page_text) = @_;

    if ($^O =~ /Win/)
    {
        if ($page_text eq "info")
        {
            $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue("");
        }

        if ($page_text eq "include")
        {
            $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue(".h;.hpp;.h++;.hh");

            if ($self->{text_ctrl_non_mpc_compliant_product_name}->GetValue() eq "wxWidgets")
            {
                my $actual_values = $self->{text_ctrl_non_mpc_compliant_tree_filter}->GetValue();
                $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue("$actual_values;.cpp");
            }
        }

        if ($page_text eq "lib")
        {
            $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue(".lib;.dll");
        }

        if ($page_text eq "bin")
        {
            $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue(".exe");
        }

        if ($page_text eq "etc")
        {
            $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue("");
        }

        if ($page_text eq "var")
        {
            $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue("");
        }

        if ($page_text eq "doc")
        {
            $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue("");
        }
    }
    else
    {
        # TO_DO: linux
        if ($page_text eq "lib")
        {
            $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue(".a; *.so");
        }
    }
}

sub drag_copy
{
    my ($self, $x, $y, $source) = @_;

    my $tree_ctrl = 0;
    my $node = 0;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    my @point = $self->ClientToScreen($x, $y);
    if (!DPOUtils::point_in_widget($tree_ctrl, \@point))
    {
        return;
    }

    my @tree_point = $tree_ctrl->ScreenToClient($point[0], $point[1]);
    my ($target_item, $flag) = $tree_ctrl->HitTest(\@tree_point);
    if ($target_item->IsOk())
    {
        my $target_item_path = DPOUtils::get_tree_item_path($tree_ctrl, $target_item);
        my $target_node = $node->find_node($target_item_path);

        if ($target_node
            && $target_node->{node_or_leaf} eq "node")
        {
            my @selections = $self->{tree_ctrl_non_mpc_compliant_tree_root_path}->GetSelections();
            foreach my $sel (@selections)
            {
                my $sel_text = $self->{tree_ctrl_non_mpc_compliant_tree_root_path}->GetItemText($sel);
                my $root_path = $self->{text_ctrl_non_mpc_compliant_root_path}->GetValue();
                $root_path =~ s/\\/\//g;
                my $relative_path = $root_path . "/" . DPOUtils::get_tree_item_path($self->{tree_ctrl_non_mpc_compliant_tree_root_path}, $sel);

                my $node_or_leaf = "node";
                if (-f $relative_path)
                {
                    $node_or_leaf = "leaf";
                }
                my $new_node = $target_node->add($sel_text, $node_or_leaf, 0, $relative_path, 0);
                if ($new_node)
                {
                    $self->non_mpc_compliant_add_sub_nodes($new_node, $tree_ctrl, $sel, $relative_path);
                }
            }

            $self->fill_tree_ctrl_non_mpc_compliant($tree_ctrl, $node, [$target_item_path]);

            if ($tree_ctrl == $self->{tree_ctrl_non_mpc_compliant_lib})
            {
                $self->fill_list_ctrl_non_mpc_compliant_libs();
            }
        }
    }
    else
    {
        Wx::MessageBox("You must aim a node.");
        return;
    }
}

sub fill_tree_ctrl_non_mpc_compliant
{
    my ($self, $tree_ctrl, $non_mpc_compliant_node_ref, $ensure_visible_paths_ref) = @_;

    $tree_ctrl->DeleteAllItems();

    my $root = $tree_ctrl->AddRoot($self->non_mpc_compliant_pool_path());
    $tree_ctrl->SetItemImage($root, 0, wxTreeItemIcon_Normal);

    my @ensure_visible_items;

    foreach my $node (@{$non_mpc_compliant_node_ref->{nodes}})
    {
        my $new_item = $tree_ctrl->AppendItem($root, $node->{id});

        if ($node->{node_or_leaf} eq "node")
        {
            $tree_ctrl->SetItemImage($new_item, 0, wxTreeItemIcon_Normal);
        }
        else
        {
            $tree_ctrl->SetItemImage($new_item, 1, wxTreeItemIcon_Normal);
        }

        my $path = DPOUtils::get_tree_item_path($tree_ctrl, $new_item);
        foreach my $ensure_visible_path (@{$ensure_visible_paths_ref})
        {
            if ($path eq $ensure_visible_path
                || $non_mpc_compliant_node_ref->{id} eq $ensure_visible_path)
            {
                push(@ensure_visible_items, $new_item);
            }
        }

        $self->fill_tree_ctrl_non_mpc_compliant_node($tree_ctrl, $node, $new_item, $ensure_visible_paths_ref, \@ensure_visible_items);
    }

    if (scalar(@ensure_visible_items))
    {
        foreach my $ensure_visible_item (@ensure_visible_items)
        {
            $tree_ctrl->Expand($ensure_visible_item);
        }
        $tree_ctrl->EnsureVisible($ensure_visible_items[0]);
    }
}

sub fill_tree_ctrl_non_mpc_compliant_node
{
    my ($self, $tree_ctrl, $node, $item, $ensure_visible_paths_ref, $ensure_visible_items_ref) = @_;

    foreach my $n (@{$node->{nodes}})
    {
        my $new_item = $tree_ctrl->AppendItem($item, $n->{id});
        if ($n->{node_or_leaf} eq "node")
        {
            $tree_ctrl->SetItemImage($new_item, 0, wxTreeItemIcon_Normal);
        }
        else
        {
            $tree_ctrl->SetItemImage($new_item, 1, wxTreeItemIcon_Normal);
        }

        my $path = DPOUtils::get_tree_item_path($tree_ctrl, $new_item);
        foreach my $ensure_visible_path (@{$ensure_visible_paths_ref})
        {
            if ($path eq $ensure_visible_path)
            {
                push(@$ensure_visible_items_ref, $new_item);
            }
        }

        $self->fill_tree_ctrl_non_mpc_compliant_node($tree_ctrl, $n, $new_item, $ensure_visible_paths_ref, $ensure_visible_items_ref);
    }
}

sub fill_list_ctrl_non_mpc_compliant_libs
{
    my ($self, $col) = @_;

    $self->determine_debug_release();

    my $list_ctrl = $self->{list_ctrl_non_mpc_compliant_libs};

    $list_ctrl->DeleteAllItems();

    my $tree_ctrl;
    my $node;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    my $pool_path = $self->non_mpc_compliant_pool_path();

    my @leaves;
    $node->get_leaves(\@leaves);
    if (defined($col))
    {
        $self->non_mpc_compliant_sort_leaves($col, $pool_path, \@leaves);
    }

    foreach my $leaf (@leaves)
    {
        my $item_text = $leaf->get_parent_path();
        my ($pre, $path) = $item_text =~ /($pool_path\/)(.*)/;

        my $include = 1;

        if ($^O =~ /Win/)
        {
            if ("$path$leaf->{id}" =~ /\.dll$/)  # TO_DO: linux ?
            {
                if ($self->{checkbox_show_dll}->GetValue() == 0)
                {
                    $include = 0;
                }
            }
        }

        if ($include)
        {
            my $item = Wx::ListItem->new();
            $item->SetId($list_ctrl->GetItemCount());
            $item->SetText("$path$leaf->{id}");
            $list_ctrl->InsertItem($item);
            $list_ctrl->SetItem($list_ctrl->GetItemCount() - 1, LIST_CTRL_NON_MPC_COMPLIANT_COL_TYPE, $leaf->{type});
            if ("$path$leaf->{id}" =~ /\.dll$/)  # TO_DO: linux
            {
                $list_ctrl->SetItemBackgroundColour($list_ctrl->GetItemCount() - 1, Wx::Colour->new(192, 192, 192))
            }

            my $build_config = "";
            if ($leaf->{build_config} == DPOUtils::BUILD_CONFIG_DEBUG)
            {
                $build_config = "Debug";
            }
            if ($leaf->{build_config} == DPOUtils::BUILD_CONFIG_RELEASE)
            {
                $build_config = "Release";
            }
            if ($leaf->{build_config} == DPOUtils::BUILD_CONFIG_DEBUG_RELEASE)
            {
                $build_config = "Debug/Release";
            }
            $list_ctrl->SetItem($list_ctrl->GetItemCount() - 1, LIST_CTRL_NON_MPC_COMPLIANT_COL_BUILD_CONFIG, $build_config);
            $list_ctrl->SetItem($list_ctrl->GetItemCount() - 1, LIST_CTRL_NON_MPC_COMPLIANT_COL_MPB, $leaf->{mpb_file});
            $list_ctrl->SetItem($list_ctrl->GetItemCount() - 1, LIST_CTRL_NON_MPC_COMPLIANT_COL_PLUGIN, $leaf->{plugin} ? "plugin" : "");
        }
    }

    $self->{button_mpb}->Enable($self->is_type_set_for_all_libs() && $self->is_build_config_set_for_all_libs());
}

sub validate_root_path
{
    my ($self, $root_path) = @_;

    unless (-d $root_path)
    {
        Wx::MessageBox("$root_path does not exist",
                        "Root path validation",
                        Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    if (!($root_path=~ /\d+.\d+.\d+$/))
    {
        Wx::MessageBox(
            "You have to select a directory with \"major.minor.patch\" format",
            "New product version",
            Wx::wxOK | Wx::wxICON_ERROR,
            undef);
        return 0;
    }

    my $msg;
    if (!$self->{mpc_compliant_product}->validate_root_path(\$msg))
    {
        Wx::MessageBox($msg,
                        "Root path validation",
                        Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    return 1;
}

sub validate_pool_path
{
    my ($self, $pool_path, $root_path) = @_;

    if (!DPOUtils::in_dpo_pool($pool_path))
    {
        my $dpo_dir = DPOUtils::dpo_pool_dir();
        Wx::MessageBox(
            "$pool_path is not a sub path of dpo_pool dir (".
            "$dpo_dir).",
            "Product DPO directory",
            Wx::wxOK | Wx::wxICON_ERROR);

        return 0;
    }

    my $msg;
    if (!$self->{mpc_compliant_product}->validate_pool_path($pool_path, \$msg))
    {
        Wx::MessageBox($msg,
                        "Pool path validation",
                        Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    return 1;
}

sub get_mpc_compliant_mpbs
{
    my ($self, $path, $mpbs_ref) =  @_;

    my @content;
    if (DPOUtils::get_dir_content($path, \@content))
    {
        foreach my $elem (@content)
        {
            my $complete = "$path/$elem";

            if (-d $complete && $elem ne "." && $elem ne "..")
            {
                if (!$self->get_mpc_compliant_mpbs($complete, $mpbs_ref))
                {
                    Wx::MessageBox("Failed to get mpb from $complete.", "", Wx::wxOK | Wx::wxICON_ERROR);
                    return 0;
                }
            }
            else
            {
                if ($elem =~ /\.mpb$/)
                {
                    my ($mpb_id) = $elem =~ /(.*)\.mpb$/;
                    $path =~ s/\\/\//g;
                    my $x = MPCCompliantNode->new($path, $mpb_id);

                    my @libs_ids;
                    my $level = 0;
                    my @mpc_includes = $path;
                    my $err;
                    if (!DPOMpb::get_libs_ids(0, $x->{id}, \@mpc_includes, \@libs_ids, \$level, \$err))
                    {
                        Wx::MessageBox("Failed to get libs ids for $x->{id}.", "", Wx::wxOK | Wx::wxICON_ERROR);
                        return 0;
                    }

                    $x->{libs_ids} = \@libs_ids;

                    push(@$mpbs_ref, $x);
                }
            }
        }
    }
    else
    {
        Wx::MessageBox("Failed to get directory content of $path.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    return 1;
}

sub get_mpc_compliant_modules
{
    my ($self, $path, $modules_ref) =  @_;

    my @content;
    if (DPOUtils::get_dir_content($path, \@content))
    {
        foreach my $elem (@content)
        {
            my $complete = "$path/$elem";

            if (-d $complete && $elem ne "." && $elem ne "..")
            {
                if (!$self->get_mpc_compliant_modules($complete, $modules_ref))
                {
                    Wx::MessageBox("Failed to get compliant modules from $complete.", "", Wx::wxOK | Wx::wxICON_ERROR);
                    return 0;
                }
            }
            else
            {
                my $ext;
                if ($^O =~ /Win/)
                {
                    $ext = "lib";
                }
                else
                {
                    $ext = "so"; # TO_DO: linux
                }

                if ($elem =~ /\.$ext$/)
                {
                    my ($module_name) = $elem =~ /(.*)\.$ext$/;

                    if ($^O =~ /Win/)
                    {
                        my $dll = "$path/$module_name.dll";
                        if (-f $dll)
                        {
                            $module_name .= ".dll";
                        }
                        else
                        {
                            $module_name .= ".lib";
                        }
                    }

                    unless ($self->{mpc_compliant_product}->exclude_module($module_name))
                    {
                        my $mpc_compliant_module = DPOMPCCompliantModule->new($module_name, $path);
                        push(@$modules_ref, $mpc_compliant_module);
                    }
                }
            }
        }
    }
    else
    {
        Wx::MessageBox("Failed to get directory content of $path.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    return 1;
}

sub fill_list_ctrl_mpc_compliant_libs
{
    my ($self) = @_;

    $self->{list_ctrl_mpc_compliant_libs}->DeleteAllItems();

    foreach my $mpc_compliant_module (@{$self->{mpc_compliant_modules}})
    {
        my $item = Wx::ListItem->new();

        $item->SetId($self->{list_ctrl_mpc_compliant_libs}->GetItemCount());
        $item->SetText($mpc_compliant_module->{module_name});
        $self->{list_ctrl_mpc_compliant_libs}->InsertItem($item);

        my $sep = "";
        my $mpbs = "";
        foreach my $x (@{$mpc_compliant_module->{relevant_mpbs_infos}})
        {
            $mpbs .= $sep . $x->{id};
            $sep = ";";
        }
        $self->{list_ctrl_mpc_compliant_libs}->SetItem($self->{list_ctrl_mpc_compliant_libs}->GetItemCount() - 1, 1, $mpc_compliant_module->{lib_id});
        $self->{list_ctrl_mpc_compliant_libs}->SetItem($self->{list_ctrl_mpc_compliant_libs}->GetItemCount() - 1, 2, $mpbs);
        $self->{list_ctrl_mpc_compliant_libs}->SetItem($self->{list_ctrl_mpc_compliant_libs}->GetItemCount() - 1, 3, $mpc_compliant_module->{type});

        my $build_config = "";
        if ($mpc_compliant_module->{build_config} == DPOUtils::BUILD_CONFIG_DEBUG)
        {
            $build_config = "Debug";
        }
        if ($mpc_compliant_module->{build_config} == DPOUtils::BUILD_CONFIG_RELEASE)
        {
            $build_config = "Release";
        }
        if ($mpc_compliant_module->{build_config} == DPOUtils::BUILD_CONFIG_DEBUG_RELEASE)
        {
            $build_config = "Debug/Release";
        }
        $self->{list_ctrl_mpc_compliant_libs}->SetItem($self->{list_ctrl_mpc_compliant_libs}->GetItemCount() - 1, 4, $build_config);
        $self->{list_ctrl_mpc_compliant_libs}->SetItem($self->{list_ctrl_mpc_compliant_libs}->GetItemCount() - 1, 5, $mpc_compliant_module->{plugin} ? "plugin" : "");
    }
}

sub copy_dpo_product_xml_template
{
    my ($self, $target) = @_;

    if (!DPOUtils::make_path($target))
    {
        return 0;
    }

    my $env_var_id =  "\$(DPO_CORE_ROOT)/scripts";
    my $path = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$path))
    {
        Wx::MessageBox("DPO_CORE_ROOT not defined", "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    my $file = "$path/DPOProduct.xml";

    $target .= "/DPOProduct.xml";

    if (!File::Copy::copy($file, $target))
    {
        Wx::MessageBox("Failed to copy $file to $target: $!", "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    return 1;
}

sub pair_local_and_pool_mpc_includes
{
    my ($self, $product_name, $product_path, $path, $mpc_includes_ref, $new_mpc_includes_ref) = @_;

    foreach my $mpc_include (@$mpc_includes_ref)
    {
        my ($remaining_path) = $path =~ /$product_path\/(.*)/;
        if (defined($remaining_path))
        {
            if ($mpc_include =~ /$remaining_path$/)
            {
                #~ print "$mpc_include VS $remaining_path\n";
                my $sep = "";
                if ($$new_mpc_includes_ref ne "")
                {
                    $sep =";";
                }
                my $env_var_id = uc($product_name) . "_ROOT";
                $$new_mpc_includes_ref .= "$sep\$($env_var_id)/$remaining_path";
            }
        }
    }

    my @content;
    if (DPOUtils::get_dir_content($path, \@content))
    {
        foreach my $elem (@content)
        {
            my $complete = "$path/$elem";
            if (-d $complete)
            {
                $self->pair_local_and_pool_mpc_includes($product_name, $product_path, $complete, $mpc_includes_ref, $new_mpc_includes_ref);
            }
        }
    }
}

sub validate_non_mpc_compliant_parameters
{
    my ($self) = @_;

    my $root_path = $self->{text_ctrl_non_mpc_compliant_root_path}->GetValue();
    $root_path =~ s/\\/\//g;
    my $pool_path = $self->{text_ctrl_non_mpc_compliant_pool_path}->GetValue();
    $pool_path =~ s/\\/\//g;
    my $name = $self->{text_ctrl_non_mpc_compliant_product_name}->GetValue();
    my $version = $self->{text_ctrl_non_mpc_compliant_product_version}->GetValue();
    my $flavour = $self->{text_ctrl_non_mpc_compliant_product_flavour}->GetValue();

    # Validate
    my @invalid;

    if ($root_path eq "")
    {
        my $msg_content = "Root path";
        unless (-d $root_path)
        {
            $msg_content .= " (does not exist)";
        }
        push(@invalid, $msg_content);
    }

    if ($pool_path eq "")
    {
        my $msg_content = "Pool path";
        unless (-d $pool_path)
        {
            $msg_content .= " (does not exist)";
        }
        push(@invalid, $msg_content);
    }

    if ($name eq "")
    {
        push(@invalid, "Product name");
    }

    if ($version eq "")
    {
        push(@invalid, "Product version");
    }

    if ($flavour eq "")
    {
        push(@invalid, "Product flavour");
    }

    if (scalar(@invalid) != 0)
    {
        my $msg = "Missing fields:\n\n";

        foreach my $field (@invalid)
        {
            $msg .= "- $field\n";
        }

        if (List::MoreUtils::any {$_ eq "Product flavour"} @invalid)
        {
            $msg .= "\nIf you want an empty flavour, inscribe 'vanilla'.";
        }

        Wx::MessageBox($msg, "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    return 1;
}

sub fill_non_mpc_compliant_tree_root_path
{
    my ($self, $non_mpc_compliant_content, $tree_item_parent) = @_;

    my $filters_text = $self->{text_ctrl_non_mpc_compliant_tree_filter}->GetValue();
    my @filters = split(/;/, $filters_text);

    my $tree_ctrl =  $self->{tree_ctrl_non_mpc_compliant_tree_root_path};

    foreach my $element (@{$non_mpc_compliant_content->{elements}})
    {
        my $append = 0;
        my $append_filter = 0;

        if ($element->{dir_or_file} eq "file")
        {
            my ($path_file, $ext) = $element->{id} =~ /(.*)(\..*)$/;
            if (defined($ext))
            {
                if (List::MoreUtils::any {$_ eq $ext} @filters)
                {
                    $append = 1;
                    $append_filter = 1;
                }
                else
                {
                    if (scalar(@filters) == 0)
                    {
                        $append = 1;
                        $append_filter = 1;
                    }
                }
            }
            else
            {
                if (scalar(@filters) == 0)
                {
                    $append = 1;
                    $append_filter = 1;
                }
            }
        }

        if ($element->{dir_or_file} eq "dir")
        {
            $append = 1;
        }

        my $new_item;
        if ($append)
        {
            $new_item = $tree_ctrl->AppendItem($tree_item_parent, $element->{id});

            if ($append_filter)
            {
                my $root_item = $tree_ctrl->GetRootItem();
                my $parent_item = $tree_ctrl->GetItemParent($new_item);
                while ($parent_item != $root_item)
                {
                    $tree_ctrl->Expand($parent_item);
                    $parent_item = $tree_ctrl->GetItemParent($parent_item);
                }
            }
        }

        if ($element->{dir_or_file} eq "dir")
        {
            $tree_ctrl->SetItemImage($new_item, 0, wxTreeItemIcon_Normal);
        }
        else
        {
            if ($append)
            {
                $tree_ctrl->SetItemImage($new_item, 1, wxTreeItemIcon_Normal);
            }
        }

        $self->fill_non_mpc_compliant_tree_root_path($element, $new_item);
    }
}

sub non_mpc_compliant_update_type
{
    my ($self, $leaf, $name, $type) = @_;

    (my $name_without_ext, my $ext) = $name =~ /(.*)\.(.*)/;

    my $x = $leaf->uid_with_no_pool_path($self->non_mpc_compliant_pool_path());
    (my $x_without_ext, my $ext2) = $x =~ /(.*)\.(.*)/;

    if ($x_without_ext eq $name_without_ext)
    {
        if ($type eq "plugin")
        {
            if ($leaf->{plugin})
            {
                $leaf->{plugin} = 0;
            }
            else
            {
                $leaf->{plugin} = 1;
            }
        }
        else
        {
            $leaf->{type} = $type;
        }
    }
}

sub non_mpc_compliant_update_build_config
{
    my ($self, $leaf, $name, $build_config) = @_;

    (my $name_without_ext, my $ext) = $name =~ /(.*)\.(.*)/;

    my $x = $leaf->uid_with_no_pool_path($self->non_mpc_compliant_pool_path());
    (my $x_without_ext, my $ext2) = $x =~ /(.*)\.(.*)/;

    if ($x_without_ext eq $name_without_ext)
    {
        $leaf->{build_config} = $build_config;
    }
}

sub copy_non_mpc_compliant_elements
{
    my ($self, $product_path, $node) = @_;

    if (!defined($node))
    {
        return 1;
    }

    my @leaves;
    $node->get_leaves(\@leaves);

    foreach my $leaf (@leaves)
    {
        my $target_path = $leaf->get_parent_path();

        if (!DPOUtils::make_path($target_path))
        {
            return 0;
        }

        my $target = "$target_path$leaf->{id}";

        if (!File::Copy::copy($leaf->{source}, $target))
        {
            Wx::MessageBox("Failed to copy $leaf->{source} to $target: $!", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }
    }

    return 1;
}

sub is_type_set_for_all_libs
{
    my ($self) = @_;

    my $defined = 0;
    my $valid_item_count = 0;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_non_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        my $candidate_for_mpb_file = $self->candidate_for_mpb_file($self->{list_ctrl_non_mpc_compliant_libs}->GetItemText($i));

        if ($candidate_for_mpb_file)
        {
            $valid_item_count++;
        }

        my $type = $self->{list_ctrl_non_mpc_compliant_libs}->GetItem($i, 1)->GetText();
        if ($type ne "")
        {
            if ($candidate_for_mpb_file)
            {
                $defined++;
            }
        }
    }

    my $rc = 1;
    if ($defined != $valid_item_count)
    {
        $rc = 0;
    }

    return $rc;
}

sub is_build_config_set_for_all_libs
{
    my ($self) = @_;

    my $build_config_defined = 0;
    my $item_count = 0;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_non_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        my $item_build_config = $self->{list_ctrl_non_mpc_compliant_libs}->GetItem($i, LIST_CTRL_NON_MPC_COMPLIANT_COL_BUILD_CONFIG);
        my $build_config = $item_build_config->GetText();

        if ($build_config ne "")
        {
            $build_config_defined++;
        }

        $item_count++;
    }

    if ($build_config_defined != $item_count)
    {
        return 0;
    }

    return 1;
}

sub set_non_mpc_compliant_type
{
    my ($self, $type) = @_;

    my @selected_indexes;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_non_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $lib = $self->{list_ctrl_non_mpc_compliant_libs}->GetItemText($i);

        my $tree_ctrl;
        my $node;
        $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

        my @leaves;
        $node->get_leaves(\@leaves);

        foreach my $leaf (@leaves)
        {
            $self->non_mpc_compliant_update_type($leaf, $lib, $type);
        }

        push(@selected_indexes, $i);
    }

    if (scalar(@selected_indexes) == 0)
    {
        Wx::MessageBox("No selection");
        return;
    }

    $self->fill_list_ctrl_non_mpc_compliant_libs();

    foreach my $sel (@selected_indexes)
    {
        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_non_mpc_compliant_libs}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_DONTCARE);
            if ( $i == -1 )
            {
                last;
            }

            if ($i == $sel)
            {
                $self->{list_ctrl_non_mpc_compliant_libs}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);
                $self->{list_ctrl_non_mpc_compliant_libs}->EnsureVisible($i);
            }
        }
    }
}

sub candidate_for_mpb_file
{
    my ($self, $lib_id) = @_;

    my $relevant_ext = 1;
    if ($^O =~ /Win/)
    {
        if ($lib_id !~ /\.lib/)
        {
            $relevant_ext = 0;
        }
    }
    else
    {
        # TO_DO: linux
    }

    return $relevant_ext;
}

sub non_mpc_compliant_pool_path
{
    my ($self) = @_;

    my $pool_path = $self->{text_ctrl_non_mpc_compliant_pool_path}->GetValue();
    $pool_path =~ s/\\/\//g;
    my $product_name = $self->{text_ctrl_non_mpc_compliant_product_name}->GetValue();
    my $product_version = $self->{text_ctrl_non_mpc_compliant_product_version}->GetValue();
    my $product_flavor = $self->{text_ctrl_non_mpc_compliant_product_flavour}->GetValue();
    my $root_name = "$pool_path/$product_name/$product_flavor/$product_version";

    return $root_name;
}

sub non_mpc_compliant_remove
{
    my ($self, $event) = @_;

    my $tree_ctrl = 0;
    my $node = 0;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    if ($tree_ctrl)
    {
        if ($self->{non_mpc_compliant_target} eq $self->non_mpc_compliant_pool_path())
        {
            Wx::MessageBox("Can't remove project's pool path root");
            return;
        }

        my $parent_item = $tree_ctrl->GetItemParent($tree_ctrl->GetSelection());
        my $parent_path = DPOUtils::get_tree_item_path($tree_ctrl, $parent_item);

        my $parent_node = $node->find_node($parent_path);
        if ($parent_node)
        {
            my $node_to_remove = $node->find_node($self->{non_mpc_compliant_target});
            if ($node_to_remove)
            {
                if (!$node_to_remove->{reserved})
                {
                    my $rc = Wx::MessageBox(
                                "Do you really want to remove $self->{non_mpc_compliant_target}?",
                                "Removing",
                                Wx::wxYES_NO | Wx::wxICON_QUESTION);
                    if ($rc == Wx::wxYES)
                    {
                        $parent_node->remove($node_to_remove->{id});
                        $self->fill_tree_ctrl_non_mpc_compliant($tree_ctrl, $node, [$parent_path]);
                        if ($tree_ctrl == $self->{tree_ctrl_non_mpc_compliant_lib})
                        {
                            $self->fill_list_ctrl_non_mpc_compliant_libs();
                        }
                    }
                }
                else
                {
                    Wx::MessageBox("Reserved node. Can't remove.", "", Wx::wxOK | Wx::wxICON_INFORMATION);
                }
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["$parent_path node not found"]);
        }
    }
}

sub non_mpc_compliant_notebook_page_tree_ctrl_and_node
{
    my ($self, $tree_ctrl_ref, $node_ref) = @_;

    my $selected_page = $self->{notebook_non_mpc_compliant}->GetSelection();
    my $current_page_text = $self->{notebook_non_mpc_compliant}->GetPageText($selected_page);

    if ($current_page_text eq "include")
    {
        $$tree_ctrl_ref = $self->{tree_ctrl_non_mpc_compliant_include};
        $$node_ref = $self->{non_mpc_compliant_node_include};
    }

    if ($current_page_text eq "lib")
    {
        $$tree_ctrl_ref = $self->{tree_ctrl_non_mpc_compliant_lib};
        $$node_ref = $self->{non_mpc_compliant_node_lib};
    }

    if ($current_page_text eq "bin")
    {
        $$tree_ctrl_ref = $self->{tree_ctrl_non_mpc_compliant_bin};
        $$node_ref = $self->{non_mpc_compliant_node_bin};
    }

    if ($current_page_text eq "etc")
    {
        $$tree_ctrl_ref = $self->{tree_ctrl_non_mpc_compliant_etc};
        $$node_ref = $self->{non_mpc_compliant_node_etc};
    }

    if ($current_page_text eq "var")
    {
        $$tree_ctrl_ref = $self->{tree_ctrl_non_mpc_compliant_var};
        $$node_ref = $self->{non_mpc_compliant_node_var};
    }

    if ($current_page_text eq "doc")
    {
        $$tree_ctrl_ref = $self->{tree_ctrl_non_mpc_compliant_doc};
        $$node_ref = $self->{non_mpc_compliant_node_doc};
    }
}

sub non_mpc_compliant_add_sub_nodes
{
    my ($self, $node, $tree_ctrl, $item, $parent_path) = @_;

    my ($child, $cookie) = $tree_ctrl->GetFirstChild($item);
    while ($child && $child->IsOk())
    {
        my $item_text = $tree_ctrl->GetItemText($child);

        my $node_or_leaf = "node";
        if (-f "$parent_path/$item_text")
        {
            $node_or_leaf = "leaf";
        }

        my $new_node = $node->add($item_text, $node_or_leaf, 0, "$parent_path/$item_text", 0);
        if ($new_node)
        {
            $self->non_mpc_compliant_add_sub_nodes($new_node, $tree_ctrl, $child, "$parent_path/$item_text");
        }

        ($child, $cookie) = $tree_ctrl->GetNextChild($item, $cookie);
    }
}

sub non_mpc_compliant_reset_tree_ctrl
{
    my ($self, $page_text) = @_;

    if ($page_text eq "info")
    {
        return;
    }

    my $pool_path = $self->non_mpc_compliant_pool_path();

    my $tree_ctrl;
    my $subdir;
    my $non_mpc_compliant_node;

    my $unnameable = 0;
    my $empty_source = "";
    my $no_parent = 0;

    if ($page_text eq "include")
    {
        $tree_ctrl = $self->{tree_ctrl_non_mpc_compliant_include};
        $subdir = "include";

        if (!defined($self->{non_mpc_compliant_node_include}))
        {
            $self->{non_mpc_compliant_node_include} = NonMPCCompliantNode->new($pool_path, "node", $unnameable, $empty_source, $no_parent, 1);
        }

        $non_mpc_compliant_node = $self->{non_mpc_compliant_node_include};

        $self->{non_mpc_compliant_target_include} = $subdir;
    }

    if ($page_text eq "lib")
    {
        $self->{splitter_lib}->SetMinimumPaneSize(50);
        my ($w, $h) = $self->{notebook_non_mpc_pane_lib}->GetSizeWH();
        $self->{splitter_lib}->SetSashPosition(0.25 * $w);

        $tree_ctrl = $self->{tree_ctrl_non_mpc_compliant_lib};
        $subdir = "lib";

        if (!defined($self->{non_mpc_compliant_node_lib}))
        {
            $self->{non_mpc_compliant_node_lib} = NonMPCCompliantNode->new($pool_path, "node", $unnameable, $empty_source, $no_parent, 1);
        }

        $non_mpc_compliant_node = $self->{non_mpc_compliant_node_lib};

        $self->{non_mpc_compliant_target_lib} = $subdir;
    }

    if ($page_text eq "bin")
    {
        $tree_ctrl = $self->{tree_ctrl_non_mpc_compliant_bin};
        $subdir = "bin";

        if (!defined($self->{non_mpc_compliant_node_bin}))
        {
            $self->{non_mpc_compliant_node_bin} = NonMPCCompliantNode->new($pool_path, "node", $unnameable, $empty_source, $no_parent, 1);
        }

        $non_mpc_compliant_node = $self->{non_mpc_compliant_node_bin};

        $self->{non_mpc_compliant_target_bin} = $subdir;
    }

    if ($page_text eq "etc")
    {
        $tree_ctrl = $self->{tree_ctrl_non_mpc_compliant_etc};
        $subdir = "etc";

        if (!defined($self->{non_mpc_compliant_node_etc}))
        {
            $self->{non_mpc_compliant_node_etc} = NonMPCCompliantNode->new($pool_path, "node", $unnameable, $empty_source, $no_parent, 1);
        }

        $non_mpc_compliant_node = $self->{non_mpc_compliant_node_etc};

        $self->{non_mpc_compliant_target_etc} = $subdir;
    }

    if ($page_text eq "var")
    {
        $tree_ctrl = $self->{tree_ctrl_non_mpc_compliant_var};
        $subdir = "var";

        if (!defined($self->{non_mpc_compliant_node_var}))
        {
            $self->{non_mpc_compliant_node_var} = NonMPCCompliantNode->new($pool_path, "node", $unnameable, $empty_source, $no_parent, 1);
        }

        $non_mpc_compliant_node = $self->{non_mpc_compliant_node_var};

        $self->{non_mpc_compliant_target_var} = $subdir;
    }

    if ($page_text eq "doc")
    {
        $tree_ctrl = $self->{tree_ctrl_non_mpc_compliant_doc};
        $subdir = "doc";

        if (!defined($self->{non_mpc_compliant_node_doc}))
        {
            $self->{non_mpc_compliant_node_doc} = NonMPCCompliantNode->new($pool_path, "node", $unnameable, $empty_source, $no_parent, 1);
        }

        $non_mpc_compliant_node = $self->{non_mpc_compliant_node_doc};

        $self->{non_mpc_compliant_target_doc} = $subdir;
    }

    my $new_node = 0;

    my ($child, $cookie) = $tree_ctrl->GetFirstChild($tree_ctrl->GetRootItem());
    if (!$child->IsOk())
    {
        $non_mpc_compliant_node->add($subdir, "node", 0, "", 1);
        my $root = $tree_ctrl->AddRoot($pool_path);
        $tree_ctrl->SetItemImage($root, 0, wxTreeItemIcon_Normal);
        my $new_item = $tree_ctrl->AppendItem($root, $subdir);
        $tree_ctrl->SetItemImage($new_item, 0, wxTreeItemIcon_Normal);
        $tree_ctrl->EnsureVisible($new_item);
    }
}

sub non_mpc_compliant_tree_item_begin_edit_label
{
    my ($self, $event) = @_;

    my $tree_ctrl;
    my $node;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    my $item = $tree_ctrl->GetSelection();
    my $item_path = DPOUtils::get_tree_item_path($tree_ctrl, $item);

    my $sub_node = $node->find_node($item_path);
    if ($sub_node)
    {
        if ($sub_node->{nameable})
        {
            $self->{non_mpc_compliant_tree_item_editing_label} = $item_path;
        }
        else
        {
            $event->Veto();
        }
    }
    else
    {
        $event->Veto();
    }
}

sub non_mpc_compliant_tree_item_end_edit_label
{
    my ($self, $event) = @_;

    my $tree_ctrl;
    my $node;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    my $id_to_change = $self->{non_mpc_compliant_tree_item_editing_label};

    if (defined($id_to_change)
        && $id_to_change ne "")
    {
        my $node_to_change = $node->find_node($id_to_change);
        if ($node_to_change)
        {
            if ($node_to_change->{nameable})
            {
                my $event_label = $event->GetLabel();
                if (defined($event_label)
                    && $event_label ne "")
                {
                    $node_to_change->{id} = $event_label;
                }
                else
                {
                    $event->Veto();
                }
            }
        }
    }
}

sub non_mpc_compliant_tree_item_key_down
{
    my ($self, $event) = @_;

    my $key_code = $event->GetKeyCode();

    my $tree_ctrl;
    my $node;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    if ($key_code == WXK_DELETE)
    {
        my $item = $tree_ctrl->GetSelection();
        $self->{non_mpc_compliant_target} = DPOUtils::get_tree_item_path($tree_ctrl, $item);

        $self->non_mpc_compliant_remove();

        $self->{non_mpc_compliant_target} = "";
    }

    if ($key_code == WXK_F2)
    {
        my $item = $tree_ctrl->GetSelection();
        $tree_ctrl->EditLabel($item);
    }
}

sub non_mpc_compliant_sort_leaves
{
    my ($self, $col, $pool_path, $leaves_ref) = @_;

    if ($col == LIST_CTR_NON_MPC_COMPLIANT_COL_ID)
    {
        if ($self->{list_ctrl_non_mpc_compliant_libs_order_col_id} == 0)
        {
            @{$leaves_ref} = sort {$a->uid_with_no_pool_path($pool_path) cmp $b->uid_with_no_pool_path($pool_path)} @{$leaves_ref};
            $self->{list_ctrl_non_mpc_compliant_libs_order_col_id} = 1;
        }
        else
        {
            @{$leaves_ref} = sort {$b->uid_with_no_pool_path($pool_path) cmp $a->uid_with_no_pool_path($pool_path)} @{$leaves_ref};
            $self->{list_ctrl_non_mpc_compliant_libs_order_col_id} = 0;
        }
    }
    else
    {
        if ($col == LIST_CTRL_NON_MPC_COMPLIANT_COL_TYPE)
        {
            if ($self->{list_ctrl_non_mpc_compliant_libs_order_col_type} == 0)
            {
                @{$leaves_ref} = sort {$a->{type} cmp $b->{type}} @{$leaves_ref};
                $self->{list_ctrl_non_mpc_compliant_libs_order_col_type} = 1;
            }
            else
            {
                @{$leaves_ref} = sort {$b->{type} cmp $a->{type}} @{$leaves_ref};
                $self->{list_ctrl_non_mpc_compliant_libs_order_col_type} = 0;
            }
        }
        else
        {
            if ($col == LIST_CTRL_NON_MPC_COMPLIANT_COL_PLUGIN)
            {
                if ($self->{list_ctrl_non_mpc_compliant_libs_order_col_plugin} == 0)
                {
                    @{$leaves_ref} = sort {$a->{plugin} cmp $b->{plugin}} @{$leaves_ref};
                    $self->{list_ctrl_non_mpc_compliant_libs_order_col_plugin} = 1;
                }
                else
                {
                    @{$leaves_ref} = sort {$b->{plugin} cmp $a->{plugin}} @{$leaves_ref};
                    $self->{list_ctrl_non_mpc_compliant_libs_order_col_plugin} = 0;
                }
            }
            else
            {
                if ($col == LIST_CTRL_NON_MPC_COMPLIANT_COL_BUILD_CONFIG)
                {
                    if ($self->{list_ctrl_non_mpc_compliant_libs_order_col_build_config} == 0)
                    {
                        @{$leaves_ref} = sort {$a->{build_config} cmp $b->{build_config}} @{$leaves_ref};
                        $self->{list_ctrl_non_mpc_compliant_libs_order_col_build_config} = 1;
                    }
                    else
                    {
                        @{$leaves_ref} = sort {$b->{build_config} cmp $a->{build_config}} @{$leaves_ref};
                        $self->{list_ctrl_non_mpc_compliant_libs_order_col_build_config} = 0;
                    }
                }
                else
                {
                    if ($col == LIST_CTRL_NON_MPC_COMPLIANT_COL_MPB)
                    {
                        if ($self->{list_ctrl_non_mpc_compliant_libs_order_col_mpb} == 0)
                        {
                            @{$leaves_ref} = sort {$a->{mpb_file} cmp $b->{mpb_file}} @{$leaves_ref};
                            $self->{list_ctrl_non_mpc_compliant_libs_order_col_mpb} = 1;
                        }
                        else
                        {
                            @{$leaves_ref} = sort {$b->{mpb_file} cmp $a->{mpb_file}} @{$leaves_ref};
                            $self->{list_ctrl_non_mpc_compliant_libs_order_col_mpb} = 0;
                        }
                    }
                }
            }
        }
    }
}

sub call_fill_non_mpc_compliant_tree_root_path
{
    my ($self) = @_;

    my $locker = Wx::WindowUpdateLocker->new($self);

    my $tree = $self->{tree_ctrl_non_mpc_compliant_tree_root_path};
    $tree->DeleteAllItems();
    my $root = $tree->GetRootItem();
    if (!$root->IsOk())
    {
        $root = $tree->AddRoot("");
    }

    $self->fill_non_mpc_compliant_tree_root_path($self->{non_mpc_compliant_content}, $root);

    my ($child, $cookie) = $tree->GetFirstChild($root);
    if ($child && $child->IsOk())
    {
        $tree->EnsureVisible($child);
    }
}

sub reset_nodes_and_trees
{
    my ($self) = @_;

    # include
    undef $self->{non_mpc_compliant_node_include};
    $self->non_mpc_compliant_reset_tree_ctrl("include");
    $self->{tree_ctrl_non_mpc_compliant_include}->DeleteAllItems();

    # lib
    undef $self->{non_mpc_compliant_node_lib};
    $self->non_mpc_compliant_reset_tree_ctrl("lib");
    $self->{tree_ctrl_non_mpc_compliant_lib}->DeleteAllItems();
    $self->{list_ctrl_non_mpc_compliant_libs}->DeleteAllItems();

    # bin
    undef $self->{non_mpc_compliant_node_bin};
    $self->non_mpc_compliant_reset_tree_ctrl("bin");
    $self->{tree_ctrl_non_mpc_compliant_bin}->DeleteAllItems();

    # etc
    undef $self->{non_mpc_compliant_node_etc};
    $self->non_mpc_compliant_reset_tree_ctrl("etc");
    $self->{tree_ctrl_non_mpc_compliant_etc}->DeleteAllItems();

    # var
    undef $self->{non_mpc_compliant_node_var};
    $self->non_mpc_compliant_reset_tree_ctrl("var");
    $self->{tree_ctrl_non_mpc_compliant_var}->DeleteAllItems();

    # doc
    undef $self->{non_mpc_compliant_node_doc};
    $self->non_mpc_compliant_reset_tree_ctrl("doc");
    $self->{tree_ctrl_non_mpc_compliant_doc}->DeleteAllItems();
}

sub determine_debug_release
{
    my ($self) = @_;

    my $tree_ctrl = 0;
    my $node = 0;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    my @leaves;
    $node->get_leaves(\@leaves);

    foreach my $leaf (@leaves)
    {
        if ($leaf->{build_config} == DPOUtils::BUILD_CONFIG_NOT_SET)
        {
            my $debug = $self->exist_debug($leaf->{id}, \@leaves);
            my $release = $self->exist_release($leaf->{id}, \@leaves);

            if ($debug && $release)
            {
                $leaf->{build_config} = DPOUtils::BUILD_CONFIG_DEBUG_RELEASE;
            }
            else
            {
                if ($debug)
                {
                    $leaf->{build_config} = DPOUtils::BUILD_CONFIG_RELEASE;
                }
                if ($release)
                {
                    $leaf->{build_config} = DPOUtils::BUILD_CONFIG_DEBUG;
                }
            }
        }
    }
}

sub exist_debug
{
    my ($self, $lib, $libs_ref) = @_;

    my ($fname) = $lib =~ /(.*)\..*/;

    foreach my $elem (@$libs_ref)
    {
        if ($elem->{id} =~ /(.*)\..*/)
        {
            my $elem_name = $1;
            if ($elem_name eq $fname . "d")
            {
                return 1;
            }
        }
    }

    return 0;
}

sub exist_release
{
    my ($self, $lib, $libs_ref) = @_;

    my ($fname) = $lib =~ /(.*)\..*/;

    foreach my $elem (@$libs_ref)
    {
        if ($elem->{id} =~ /(.*)\..*/)
        {
            my $elem_name = $1;
            if ($fname =~ /($elem_name)d$/)
            {
                return 1;
            }
        }
    }

    return 0;
}

sub set_build_config
{
    my ($self, $build_config) = @_;

    my @selected_indexes;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_non_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $lib = $self->{list_ctrl_non_mpc_compliant_libs}->GetItemText($i);

        my $tree_ctrl;
        my $node;
        $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

        my @leaves;
        $node->get_leaves(\@leaves);

        foreach my $leaf (@leaves)
        {
            $self->non_mpc_compliant_update_build_config($leaf, $lib, $build_config);
        }

        push(@selected_indexes, $i);
    }

    if (scalar(@selected_indexes) == 0)
    {
        Wx::MessageBox("No selection");
        return;
    }

    $self->fill_list_ctrl_non_mpc_compliant_libs();

    foreach my $sel (@selected_indexes)
    {
        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_non_mpc_compliant_libs}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_DONTCARE);
            if ( $i == -1 )
            {
                last;
            }

            if ($i == $sel)
            {
                $self->{list_ctrl_non_mpc_compliant_libs}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);
                $self->{list_ctrl_non_mpc_compliant_libs}->EnsureVisible($i);
            }
        }
    }
}



## Eeeeeeevent handlers
sub on_combo_box_known_mpc_compliant_products
{
    my ($self, $event) = @_;

    my $product = $event->GetString();

    if ($product eq "ACE")
    {
        my $ace_root_path = "C:/usr/Vanderbilt/ace/6.3.1";
        my $ace_pool_path = "C:/dev/dpo_pool-x86_64-windows/vc10/thirdparty/Vanderbilt/ACE";

        my ($ace_version) = $ace_root_path =~ /.*\/(\d+.\d+.\d+)/;

        $self->{text_ctrl_mpc_compliant_product_root_path}->SetValue($ace_root_path);
        $self->{text_ctrl_mpc_compliant_product_pool_path}->SetValue($ace_pool_path);

        unless (-d $ace_root_path)
        {
            $self->{text_ctrl_mpc_compliant_product_root_path}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
        }

        unless (-d $ace_pool_path)
        {
            $self->{text_ctrl_mpc_compliant_product_pool_path}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
        }

        $self->{mpc_compliant_product} = DPONewProductACE->new($ace_root_path, $ace_version, $self->{frame});
    }
    else
    {
        if ($product eq "OpenDDS")
        {
            my $dds_root_path = "C:/usr/OCI/DDS/3.6.0";
            my $dds_pool_path = "C:/dev/dpo_pool-x86_64-windows/vc10/thirdparty/OCI/DDS";

            my ($dds_version) = $dds_root_path =~ /.*\/(\d+.\d+.\d+)/;

            $self->{text_ctrl_mpc_compliant_product_root_path}->SetValue($dds_root_path);
            $self->{text_ctrl_mpc_compliant_product_pool_path}->SetValue($dds_pool_path);

            $self->{mpc_compliant_product} = DPONewProductOpenDDS->new($dds_root_path, $dds_version, $self->{frame});
        }
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_combo_box_known_mpc_compliant_products <event_handler>
    warn "Event handler (on_combo_box_known_mpc_compliant_products) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_text_ctrl_mpc_compliant_product_root_path
{
    my ($self, $event) = @_;

    my $text = $self->{text_ctrl_mpc_compliant_product_root_path}->GetValue();

    if (-d $text)
    {
        $self->{text_ctrl_mpc_compliant_product_root_path}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
    }
    else
    {
        $self->{text_ctrl_mpc_compliant_product_root_path}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_text_ctrl_mpc_compliant_product_root_path <event_handler>
    warn "Event handler (on_text_ctrl_mpc_compliant_product_root_path) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_browse_mpc_compliant_product_root_path
{
    my ($self, $event) = @_;

    my $path = "/";

    my $product_path = $self->{text_ctrl_mpc_compliant_product_root_path}->GetValue();
    while ( !(-d $product_path) && $product_path ne "" )
    {
        ($product_path) = $product_path =~ /(.*)\/.*/;
        if (!defined($product_path))
        {
            $product_path = ""; # to assure that $product_path is defined.
            last;
        }
    }

    if (-d $product_path)
    {
        $path = $product_path;
    }

    my $dlg = Wx::DirDialog->new($self, "Select Product root path", $path);
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $root_path = $dlg->GetPath();
        $root_path =~ s/\\/\//g;
        $self->{text_ctrl_mpc_compliant_product_root_path}->SetValue($root_path);

        $self->{text_ctrl_mpc_compliant_product_root_path}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_browse_mpc_compliant_product_root_path <event_handler>
    warn "Event handler (on_button_browse_mpc_compliant_product_root_path) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_text_ctrl_mpc_compliant_product_pool_path
{
    my ($self, $event) = @_;

    my $text = $self->{text_ctrl_mpc_compliant_product_pool_path}->GetValue();

    if (-d $text)
    {
        $self->{text_ctrl_mpc_compliant_product_pool_path}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
    }
    else
    {
        $self->{text_ctrl_mpc_compliant_product_pool_path}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_text_ctrl_mpc_compliant_product_pool_path <event_handler>
    warn "Event handler (on_text_ctrl_mpc_compliant_product_pool_path) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_browse_mpc_compliant_product_pool_path
{
    my ($self, $event) = @_;

    my $env_var_id =  "\$(DPO_POOL_ROOT)";
    my $dpo_pool_root = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$dpo_pool_root))
    {
        Wx::MessageBox("DPO_POOL_ROOT not defined", "", Wx::wxOK | Wx::wxICON_ERROR);
        $dpo_pool_root = "/";
    }

    my $path = $dpo_pool_root;

    my $product_pool_path = $self->{text_ctrl_mpc_compliant_product_pool_path}->GetValue();
    while ( !(-d $product_pool_path) && $product_pool_path ne "" )
    {
        ($product_pool_path) = $product_pool_path =~ /(.*)\/.*/;
        if (!defined($product_pool_path))
        {
            $product_pool_path = ""; # to assure that $product_path is defined.
            last;
        }
    }

    if (-d $product_pool_path)
    {
        $path = $product_pool_path;
    }

    my $dlg = Wx::DirDialog->new($self, "Select product pool path", $path);
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $pool_path = $dlg->GetPath();
        $pool_path =~ s/\\/\//g;
        $self->{text_ctrl_mpc_compliant_product_pool_path}->SetValue($pool_path);

        $self->{text_ctrl_mpc_compliant_product_pool_path}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_browse_mpc_compliant_product_pool_path <event_handler>
    warn "Event handler (on_button_browse_mpc_compliant_product_pool_path) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_mpc_compliant_product_load
{
    my ($self, $event) = @_;

    my $known_mpc_product = $self->{combo_box_known_mpc_compliant_products}->GetValue();
    if ($known_mpc_product eq "")
    {
        Wx::MessageBox("Known MPC product is missing.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    my $root_path = $self->{text_ctrl_mpc_compliant_product_root_path}->GetValue();
    if ($root_path eq "")
    {
        Wx::MessageBox("Root path is missing.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    $root_path =~ s/\\/\//g;
    $self->{mpc_compliant_product}->{source_path} = $root_path;

    my $pool_path = $self->{text_ctrl_mpc_compliant_product_pool_path}->GetValue();
    if ($pool_path eq "")
    {
        Wx::MessageBox("Pool path is missing.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    $pool_path =~ s/\\/\//g;
    $self->{mpc_compliant_product}->{pool_path} = $pool_path;

    my ($version) = $root_path =~ /.*\/(\d+.\d+.\d+)$/;
    $self->{mpc_compliant_product}->{version} = $version;


    if (!$self->validate_root_path($root_path))
    {
        return;
    }

    if (!$self->validate_pool_path($pool_path, $root_path, 1))
    {
        return 0;
    }

    $self->{mpc_compliant_product}->{version} = $version;

    my $wait = Wx::BusyCursor->new();

    # MPBs
    my @mpbs_dirs;
    $self->{mpc_compliant_product}->get_mpc_compliant_mpbs_dirs(\@mpbs_dirs);

    my @mpc_compliant_mpbs;
    foreach my $dir (@mpbs_dirs)
    {
        if (!$self->get_mpc_compliant_mpbs($dir, \@mpc_compliant_mpbs))
        {
            Wx::MessageBox("Failed to get mpb from $dir.", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }
    }

    # MPC compliant modules
    my @modules_dirs;
    $self->{mpc_compliant_product}->get_mpc_compliant_modules_dirs(\@modules_dirs);

    my @mpc_compliant_modules;
    foreach my $dir (@modules_dirs)
    {
        if (!$self->get_mpc_compliant_modules($dir, \@mpc_compliant_modules))
        {
            Wx::MessageBox("Failed to get compliant modules from $dir.", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }
    }

    # Associate mpb infos to mpc compliant modules
    foreach my $mpc_compliant_module (@mpc_compliant_modules)
    {
        foreach my $mpb (@mpc_compliant_mpbs)
        {
            foreach my $lib_id (@{$mpb->{libs_ids}})
            {
                if ($lib_id->{level} == 0)
                {
                    if ($mpc_compliant_module->{module_name} =~ /$lib_id->{id}/)
                    {
                        if (!List::MoreUtils::any {$_->{id} eq $mpb->{id}} @{$mpc_compliant_module->{mpbs_infos}})
                        {
                            my $mpb_info = DPOMPBInfo->new($mpb->{id}, $lib_id->{id}, $mpb->{path});
                            push(@{$mpc_compliant_module->{mpbs_infos}}, $mpb_info);
                        }
                        else
                        {
                            foreach my $mpb_info (@{$mpc_compliant_module->{mpbs_infos}})
                            {
                                if (length($lib_id->{id}) > length($mpb_info->{lib_id}))
                                {
                                    $mpb_info->{lib_id} = $lib_id->{id};
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    # Assign type (static/dynamic), build config (Debug/Release)
    # and keep relevant MPBs infos.
    foreach my $mpc_compliant_module (@mpc_compliant_modules)
    {
        if ($^O =~ /Win/)
        {
            if ($mpc_compliant_module->{module_name} =~ /\.lib$/)
            {
                $mpc_compliant_module->{type} = "static";
            }
            else
            {
                $mpc_compliant_module->{type} = "dynamic";
            }

            # Since DPO uses default MPC lib_modifiers, and that we are
            # processing an MPC compliant product, we can rely on lib_modifier
            # to determine the build configuration (Release/Debug).
            my ($module_name, $ext) = $mpc_compliant_module->{module_name} =~ /(.*)\.(.*)/;
            my $debug = $module_name . "d." . $ext;
            if (-f "$mpc_compliant_module->{path}/$debug")
            {
                $mpc_compliant_module->{build_config} = DPOUtils::BUILD_CONFIG_RELEASE;
            }
            else
            {
                $mpc_compliant_module->{build_config} = DPOUtils::BUILD_CONFIG_DEBUG;
            }
        }
        else
        {
            # TO_DO: linux
            # In Linux, MPC doesn't use debug lib_modifier. Will we treat debug and
            # release modules seperately?
        }

        my $found = 0;
        my @not_found;

        foreach my $mpb_info (@{$mpc_compliant_module->{mpbs_infos}})
        {
            my $module_name_uc = uc($mpc_compliant_module->{module_name});
            my $mpb_uc = uc($mpb_info->{id});
            if ($module_name_uc =~ /$mpb_uc/)
            {
                $found = $mpb_info;
            }
            else
            {
                push(@not_found, $mpb_info);
            }
        }

        if ($found)
        {
            $mpc_compliant_module->{lib_id} = $found->{lib_id};
            $mpc_compliant_module->{mpbs_infos} = [];
            push(@{$mpc_compliant_module->{relevant_mpbs_infos}}, $found);
        }
        else
        {
            my $special_mpb_name;
            my $special_mpb_name_lib_id;
            if ($self->{mpc_compliant_product}->special_mpb_name($mpc_compliant_module->{module_name}, \$special_mpb_name, \$special_mpb_name_lib_id))
            {
                $mpc_compliant_module->{lib_id} = $special_mpb_name_lib_id;
                my $mpc_includes = "";
                foreach my $not_found (@not_found)
                {
                    if ($not_found->{lib_id} eq $special_mpb_name_lib_id)
                    {
                        $mpc_includes = $not_found->{mpc_includes};
                        last;
                    }
                }
                my $mpb_info = DPOMPBInfo->new($special_mpb_name, $special_mpb_name_lib_id, $mpc_includes);
                push(@{$mpc_compliant_module->{relevant_mpbs_infos}}, $mpb_info);
            }
            else
            {
                foreach my $mpb_info (@not_found)
                {
                    $mpc_compliant_module->{lib_id} = $mpb_info->{lib_id};
                    push(@{$mpc_compliant_module->{relevant_mpbs_infos}}, $mpb_info);
                    $mpc_compliant_module->{mpbs_infos} = [];
                }
            }
        }
    }

    $self->{mpc_compliant_modules} = \@mpc_compliant_modules;

    $self->fill_list_ctrl_mpc_compliant_libs();

    $self->{text_ctrl_mpc_compliant_product_name}->SetValue($self->{mpc_compliant_product}->get_product_name());
    $self->{text_ctrl_mpc_compliant_product_version}->SetValue($version);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_mpc_compliant_product_load <event_handler>
    warn "Event handler (on_button_mpc_compliant_product_load) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_mpc_compliant_libs_col_click
{
    my ($self, $event) = @_;

    if ($event->GetColumn() == 0)
    {
        if ($self->{list_ctrl_mpc_compliant_libs_order_col_0} == 0)
        {
            @{$self->{mpc_compliant_modules}} = sort {$a->{module_name} cmp $b->{module_name}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_0} = 1;
        }
        else
        {
            @{$self->{mpc_compliant_modules}} = sort {$b->{module_name} cmp $a->{module_name}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_0} = 0;
        }
    }

    if ($event->GetColumn() == 1)
    {
        if ($self->{list_ctrl_mpc_compliant_libs_order_col_1} == 0)
        {
            @{$self->{mpc_compliant_modules}} = sort {$a->{lib_id} cmp $b->{lib_id}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_1} = 1;
        }
        else
        {
            @{$self->{mpc_compliant_modules}} = sort {$b->{lib_id} cmp $a->{lib_id}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_1} = 0;
        }
    }

    if ($event->GetColumn() == 3)
    {
        if ($self->{list_ctrl_mpc_compliant_libs_order_col_3} == 0)
        {
            @{$self->{mpc_compliant_modules}} = sort {$a->{type} cmp $b->{type}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_3} = 1;
        }
        else
        {
            @{$self->{mpc_compliant_modules}} = sort {$b->{type} cmp $a->{type}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_3} = 0;
        }
    }

    if ($event->GetColumn() == 4)
    {
        if ($self->{list_ctrl_mpc_compliant_libs_order_col_4} == 0)
        {
            @{$self->{mpc_compliant_modules}} = sort {$a->{build_config} cmp $b->{build_config}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_4} = 1;
        }
        else
        {
            @{$self->{mpc_compliant_modules}} = sort {$b->{build_config} cmp $a->{build_config}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_4} = 0;
        }
    }

    if ($event->GetColumn() == 5)
    {
        if ($self->{list_ctrl_mpc_compliant_libs_order_col_5} == 0)
        {
            @{$self->{mpc_compliant_modules}} = sort {$a->{plugin} cmp $b->{plugin}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_5} = 1;
        }
        else
        {
            @{$self->{mpc_compliant_modules}} = sort {$b->{plugin} cmp $a->{plugin}} @{$self->{mpc_compliant_modules}};
            $self->{list_ctrl_mpc_compliant_libs_order_col_5} = 0;
        }
    }

    $self->fill_list_ctrl_mpc_compliant_libs();

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_list_ctrl_mpc_compliant_libs_col_click <event_handler>
    warn "Event handler (on_list_ctrl_mpc_compliant_libs_col_click) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_mpc_compliant_select_all
{
    my ($self, $event) = @_;

    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        $self->{list_ctrl_mpc_compliant_libs}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_mpc_compliant_select_all <event_handler>
    warn "Event handler (on_button_mpc_compliant_select_all) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_mpc_compliant_as_static
{
    my ($self, $event) = @_;

    my @selected_indexes;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $lib = $self->{list_ctrl_mpc_compliant_libs}->GetItemText($i);

        foreach my $mpc_compliant_lib (@{$self->{mpc_compliant_modules}})
        {
            if ($mpc_compliant_lib->{module_name} eq $lib)
            {
                $mpc_compliant_lib->{type} = "static";
                last;
            }
        }

        push(@selected_indexes, $i);
    }

    $self->fill_list_ctrl_mpc_compliant_libs();

    foreach my $sel (@selected_indexes)
    {
        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_DONTCARE);
            if ( $i == -1 )
            {
                last;
            }

            if ($i == $sel)
            {
                $self->{list_ctrl_mpc_compliant_libs}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);

                last;
            }
        }
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_mpc_compliant_as_static <event_handler>
    warn "Event handler (on_button_mpc_compliant_as_static) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_mpc_compliant_as_dynamic
{
    my ($self, $event) = @_;

    my @selected_indexes;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $lib = $self->{list_ctrl_mpc_compliant_libs}->GetItemText($i);

        foreach my $x (@{$self->{mpc_compliant_modules}})
        {
            if ($x->{module_name} eq $lib)
            {
                $x->{type} = "dynamic";
                last;
            }
        }

        push(@selected_indexes, $i);
    }

    $self->fill_list_ctrl_mpc_compliant_libs();

    foreach my $sel (@selected_indexes)
    {
        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_DONTCARE);
            if ( $i == -1 )
            {
                last;
            }

            if ($i == $sel)
            {
                $self->{list_ctrl_mpc_compliant_libs}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);

                last;
            }
        }
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_mpc_compliant_as_dynamic <event_handler>
    warn "Event handler (on_button_mpc_compliant_as_dynamic) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_mpc_compliant_as_debug
{
    my ($self, $event) = @_;

    my @selected_indexes;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $lib = $self->{list_ctrl_mpc_compliant_libs}->GetItemText($i);

        foreach my $x (@{$self->{mpc_compliant_modules}})
        {
            if ($x->{module_name} eq $lib)
            {
                $x->{build_config} = DPOUtils::BUILD_CONFIG_DEBUG;
                last;
            }
        }

        push(@selected_indexes, $i);
    }

    $self->fill_list_ctrl_mpc_compliant_libs();

    foreach my $sel (@selected_indexes)
    {
        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_DONTCARE);
            if ( $i == -1 )
            {
                last;
            }

            if ($i == $sel)
            {
                $self->{list_ctrl_mpc_compliant_libs}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);

                last;
            }
        }
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_mpc_compliant_as_debug <event_handler>
    warn "Event handler (on_button_mpc_compliant_as_debug) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_mpc_compliant_as_release
{
    my ($self, $event) = @_;

    my @selected_indexes;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $lib = $self->{list_ctrl_mpc_compliant_libs}->GetItemText($i);

        foreach my $x (@{$self->{mpc_compliant_modules}})
        {
            if ($x->{module_name} eq $lib)
            {
                $x->{build_config} = DPOUtils::BUILD_CONFIG_RELEASE;
                last;
            }
        }

        push(@selected_indexes, $i);
    }

    $self->fill_list_ctrl_mpc_compliant_libs();

    foreach my $sel (@selected_indexes)
    {
        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_DONTCARE);
            if ( $i == -1 )
            {
                last;
            }

            if ($i == $sel)
            {
                $self->{list_ctrl_mpc_compliant_libs}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);

                last;
            }
        }
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_mpc_compliant_as_release <event_handler>
    warn "Event handler (on_button_mpc_compliant_as_release) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_mpc_compliant_as_plugin
{
    my ($self, $event) = @_;

    my @selected_indexes;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $lib = $self->{list_ctrl_mpc_compliant_libs}->GetItemText($i);

        foreach my $x (@{$self->{mpc_compliant_modules}})
        {
            if ($x->{module_name} eq $lib)
            {
                if ($x->{plugin})
                {
                    $x->{plugin} = 0;
                }
                else
                {
                    $x->{plugin} = 1;
                }
                last;
            }
        }

        push(@selected_indexes, $i);
    }

    $self->fill_list_ctrl_mpc_compliant_libs();

    foreach my $sel (@selected_indexes)
    {
        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_DONTCARE);
            if ( $i == -1 )
            {
                last;
            }

            if ($i == $sel)
            {
                $self->{list_ctrl_mpc_compliant_libs}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);

                last;
            }
        }
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_mpc_compliant_as_plugin <event_handler>
    warn "Event handler (on_button_mpc_compliant_as_plugin) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_mpc_compliant_set_product
{
    my ($self, $event) = @_;

    my $wait = Wx::BusyCursor->new();

    my $all_mpbs_type_defined = 1;

    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_mpc_compliant_libs}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        my $item = $self->{list_ctrl_mpc_compliant_libs}->GetItem($i, 2);
        my $type = $item->GetText();
        if ($type eq "")
        {
            $all_mpbs_type_defined = 0;
            last;
        }
    }

    if (!$all_mpbs_type_defined)
    {
        Wx::MessageBox("Not all libs are assigned to static and/or dynamic.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    my $flavour = $self->{text_ctrl_mpc_compliant_product_flavour}->GetValue();
    if ($flavour eq "")
    {
        Wx::MessageBox("If you want an empty flavour, inscribe 'vanilla'.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    my $flavour_sub_path = "$flavour/";

    my $version = $self->{text_ctrl_mpc_compliant_product_version}->GetValue();

    my $product_path = $self->{text_ctrl_mpc_compliant_product_pool_path}->GetValue() . "/$flavour_sub_path$version";

    if (-d $product_path)
    {
        # compare versions
        my @dir_content=();
        if (!DPOUtils::get_dir_content($product_path, \@dir_content))
        {
            Wx::MessageBox(
                "Can not get content of $product_path.",
                "DPO directory",
                Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }

        foreach(@dir_content)
        {
            my $complete = "$product_path/$_";

            if (-d $complete && $_ ne "." && $_ ne ".." && $_ ne ".svn")
            {
                my ($dpo_version) = $complete =~ /.*\/(\d+.\d+.\d+)$/;
                if ($dpo_version)
                {
                    if ($dpo_version eq $self->{mpc_compliant_product}->get_product_version())
                    {
                        Wx::MessageBox(
                            "You cannot apply \n\n". $self->{mpc_compliant_product}->get_product_version() . "\n\non ".
                                        "existing \n\n$complete.",
                            "DPO directory",
                            Wx::wxOK | Wx::wxICON_ERROR);
                            return 0;
                    }
                }
            }
        }
    }

    if (!$self->copy_dpo_product_xml_template($product_path))
    {
        return;
    }

    my $product;
    my $config_product = DPOProductConfig->new("$product_path/DPOProduct.xml");
    if ($config_product)
    {
        if (!$config_product->get_product(\$product))
        {
            Wx::MessageBox("Failed to get product", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }

        $product->{name} = $self->{mpc_compliant_product}->get_product_name();
        $product->{version} = $version;
        $product->{flavour} = $flavour;
        $product->{dpo_compliant_product}->{value} = 0;
        $product->{dpo_compliant_product}->{mpc_compliant} = 1;

        my $mpc_includes = "";
        my $sep_mpc_includes = "";

        my @libs;
        foreach my $mpc_compliant_module (@{$self->{mpc_compliant_modules}})
        {
            my $non_compliant_lib = 0;

            foreach my $lib (@libs)
            {
                if ($lib->{lib_id} eq $mpc_compliant_module->{lib_id})
                {
                    $non_compliant_lib = $lib;
                    last;
                }
            }

            if ($non_compliant_lib == 0)
            {
                $non_compliant_lib = DPONonCompliantLib->new($mpc_compliant_module->{lib_id}, "");
                push(@libs, $non_compliant_lib);
                push(@{$product->{dpo_compliant_product}->{non_compliant_lib_seq}}, $non_compliant_lib);
            }

            my $mpbs_ids = "";
            my $sep = "";
            foreach my $mpb_info (@{$mpc_compliant_module->{relevant_mpbs_infos}})
            {
                $mpbs_ids .= "$sep$mpb_info->{id}";
                $sep = ";";

                if ($mpc_includes !~ /$mpb_info->{mpc_includes}/)
                {
                    $mpc_includes .= "$sep_mpc_includes$mpb_info->{mpc_includes}";
                    $sep_mpc_includes = ";";
                }
            }
            $non_compliant_lib->{mpb_name} = $mpbs_ids;

            if ($mpc_compliant_module->{type} eq "static"
                && $mpc_compliant_module->{build_config} eq DPOUtils::BUILD_CONFIG_DEBUG)
            {
                $non_compliant_lib->{static_debug_lib} = $mpc_compliant_module->{module_name};
            }

            if ($mpc_compliant_module->{type} eq "static"
                && $mpc_compliant_module->{build_config} eq DPOUtils::BUILD_CONFIG_RELEASE)
            {
                $non_compliant_lib->{static_release_lib} = $mpc_compliant_module->{module_name};
            }

            if ($mpc_compliant_module->{type} eq "dynamic")
            {
                if ($mpc_compliant_module->{build_config} eq DPOUtils::BUILD_CONFIG_DEBUG)
                {
                    $non_compliant_lib->{dynamic_debug_lib} = $mpc_compliant_module->{module_name};
                    if ($mpc_compliant_module->{module_name} =~ /\.dll$/)
                    {
                        $non_compliant_lib->{dynamic_debug_dll} = $mpc_compliant_module->{module_name};
                        my ($fname, $ext) = $mpc_compliant_module->{module_name} =~ /(.*)\.(.*)/;
                        $non_compliant_lib->{dynamic_debug_lib} = "$fname.lib";
                    }
                }

                if ($mpc_compliant_module->{build_config} eq DPOUtils::BUILD_CONFIG_RELEASE)
                {
                    $non_compliant_lib->{dynamic_release_lib} = $mpc_compliant_module->{module_name};
                    if ($mpc_compliant_module->{module_name} =~ /\.dll$/)
                    {
                        $non_compliant_lib->{dynamic_release_dll} = $mpc_compliant_module->{module_name};
                        my ($fname, $ext) = $mpc_compliant_module->{module_name} =~ /(.*)\.(.*)/;
                        $non_compliant_lib->{dynamic_release_lib} = "$fname.lib";
                    }
                }
            }

            if (!$non_compliant_lib->{plugin})
            {
                $non_compliant_lib->{plugin} = $mpc_compliant_module->{plugin};
            }
        }

        if (!$self->{mpc_compliant_product}->copy($product_path))
        {
            Wx::MessageBox("Can't copy (see output). Reverting...", "", Wx::wxOK | Wx::wxICON_ERROR);
            $self->{mpc_compliant_product}->rollback($product_path);
            return;
        }

        my @mpc_includes = split(/;/, $mpc_includes);
        my $new_mpc_includes = "";
        $self->pair_local_and_pool_mpc_includes($product->{name}, $product_path, $product_path, \@mpc_includes, \$new_mpc_includes);

        $product->{mpc_includes} = $new_mpc_includes;

        if (!$config_product->save($product, 1))
        {
            Wx::MessageBox("Can't update $product_path/DPOProduct.xml", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }

        # set new product env. var.
        my @listEnvVarValues;
        my $product_env_var = DPOEnvVar->new(uc($product->{name}) . "_ROOT", $product_path);
        push(@listEnvVarValues, $product_env_var);

        my $rc = DPOEnvVars::system_set_env_vars(\@listEnvVarValues);
        if (!$rc)
        {
            Wx::MessageBox("Failed to set $product->{name} environment variable.", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }
    }
    else
    {
        Wx::MessageBox("Failed to load product", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    Wx::MessageBox("Product set.");

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_mpc_compliant_set_product <event_handler>
    warn "Event handler (on_button_mpc_compliant_set_product) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_non_mpc_compliant_browse_root_path
{
    my ($self, $event) = @_;

    my $dlg = Wx::DirDialog->new($self, "Select the root path of the product");
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        $self->{text_ctrl_non_mpc_compliant_root_path}->SetValue($path);
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_non_mpc_compliant_browse_root_path <event_handler>
    warn "Event handler (on_button_non_mpc_compliant_browse_root_path) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_non_mpc_compliant_browse_pool_path
{
    my ($self, $event) = @_;

    my $env_var_id =  "\$(DPO_POOL_ROOT)";
    my $dpo_pool_root = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$dpo_pool_root))
    {
        Wx::MessageBox("DPO_POOL_ROOT not defined", "", Wx::wxOK | Wx::wxICON_ERROR);
        $dpo_pool_root = "/";
    }

    my $path = $dpo_pool_root;

    my $product_path = $self->{text_ctrl_non_mpc_compliant_pool_path}->GetValue();
    if (-d $product_path)
    {
        $path = $product_path;
    }

    $path =~ s/\\/\//g;

    my $dlg = Wx::DirDialog->new($self, "Select the pool path of the product", $path);
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        $self->{text_ctrl_non_mpc_compliant_pool_path}->SetValue($path);
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_non_mpc_compliant_browse_pool_path <event_handler>
    warn "Event handler (on_button_non_mpc_compliant_browse_pool_path) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_non_mpc_compliant_load
{
    my ($self, $event) = @_;

    my $root_path = $self->{text_ctrl_non_mpc_compliant_root_path}->GetValue();
    my $pool_path = $self->{text_ctrl_non_mpc_compliant_pool_path}->GetValue();
    my $product_name = $self->{text_ctrl_non_mpc_compliant_product_name}->GetValue();
    my $product_version = $self->{text_ctrl_non_mpc_compliant_product_version}->GetValue();
    my $product_flavour = $self->{text_ctrl_non_mpc_compliant_product_flavour}->GetValue();

    if ($root_path eq ""
        || $pool_path eq ""
        || $product_name eq ""
        || $product_version eq ""
        || $product_flavour eq "")
    {
        Wx::MessageBox("Missing field");
        return;
    }

    $self->reset_nodes_and_trees();

    $self->{notebook_non_mpc_compliant}->SetSelection(0);

    my $wait = Wx::BusyCursor->new();

    $root_path =~ s/\\/\//g;
    $self->{non_mpc_compliant_content} = NonMPCCompliantContent->new("/", "dir", $root_path);

    $self->call_fill_non_mpc_compliant_tree_root_path();

    my $locker = Wx::WindowUpdateLocker->new($self);
    $self->{tree_ctrl_non_mpc_compliant_tree_root_path}->CollapseAll();
    my $root = $self->{tree_ctrl_non_mpc_compliant_tree_root_path}->GetRootItem();
    my ($child, $cookie) = $self->{tree_ctrl_non_mpc_compliant_tree_root_path}->GetFirstChild($root);
    if ($child && $child->IsOk())
    {
        $self->{tree_ctrl_non_mpc_compliant_tree_root_path}->EnsureVisible($child);
    }

    $self->{notebook_non_mpc_compliant}->Enable(1);

    $self->{text_ctrl_non_mpc_compliant_root_path}->Enable(0);
    $self->{text_ctrl_non_mpc_compliant_pool_path}->Enable(0);
    $self->{text_ctrl_non_mpc_compliant_product_name}->Enable(0);
    $self->{text_ctrl_non_mpc_compliant_product_version}->Enable(0);
    $self->{text_ctrl_non_mpc_compliant_product_flavour}->Enable(0);
    $self->{button_non_mpc_compliant_load}->Enable(0);

    $self->{notebook_non_mpc_compliant}->Enable();
    $self->{button_non_mpc_compliant_reset}->Enable();

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_non_mpc_compliant_load <event_handler>
    warn "Event handler (on_button_non_mpc_compliant_load) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_non_mpc_compliant_reset
{
    my ($self, $event) = @_;

    $self->reset_nodes_and_trees();

    $self->{text_ctrl_non_mpc_compliant_root_path}->Enable();
    $self->{text_ctrl_non_mpc_compliant_pool_path}->Enable();
    $self->{text_ctrl_non_mpc_compliant_product_name}->Enable();
    $self->{text_ctrl_non_mpc_compliant_product_version}->Enable();
    $self->{text_ctrl_non_mpc_compliant_product_flavour}->Enable();
    $self->{button_non_mpc_compliant_load}->Enable();

    $self->{notebook_non_mpc_compliant}->SetSelection(0);
    $self->{notebook_non_mpc_compliant}->Enable(0);
    $self->{button_non_mpc_compliant_reset}->Enable(0);
    $self->{text_ctrl_non_mpc_compliant_tree_filter}->SetValue("");

    $self->{tree_ctrl_non_mpc_compliant_tree_root_path}->DeleteAllItems();

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_non_mpc_compliant_reset <event_handler>
    warn "Event handler (on_button_non_mpc_compliant_reset) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_non_mpc_compliant_tree_filter
{
    my ($self, $event) = @_;

    my $wait = Wx::BusyCursor->new();

    $self->call_fill_non_mpc_compliant_tree_root_path();

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_non_mpc_compliant_tree_filter <event_handler>
    warn "Event handler (on_button_non_mpc_compliant_tree_filter) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_tree_root_path_begin_drag
{
    my ($self, $event) = @_;

    my $text_obj = Wx::TextDataObject->new("tree_ctrl_non_mpc_compliant_tree_root_path");

    my $source = Wx::DropSource->new($self->{tree_ctrl_non_mpc_compliant_tree_root_path});
    $source->SetData($text_obj);

    my $drop_result = $source->DoDragDrop();

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_tree_root_path_begin_drag <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_tree_root_path_begin_drag) not implemented";
    $event->Skip;
    # end wxGlade
}


sub list_ctrl_non_mpc_compliant_libs_col_click
{
    my ($self, $event) = @_;

    $self->fill_list_ctrl_non_mpc_compliant_libs($event->GetColumn());

    return;

    # wxGlade: DPOPanelExternalProductMigration::list_ctrl_non_mpc_compliant_libs_col_click <event_handler>
    warn "Event handler (list_ctrl_non_mpc_compliant_libs_col_click) not implemented";
    $event->Skip;
    # end wxGlade
}


sub list_ctrl_non_mpc_compliant_libs_key_down
{
    my ($self, $event) = @_;

    my $key_code = $event->GetKeyCode();

    if ($key_code == WXK_DELETE)
    {
        my @paths;

        my @selections;

        my $to_remove;

        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_non_mpc_compliant_libs}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_SELECTED);
            if ( $i == -1 )
            {
                last;
            }

            my $sel_text = $self->{list_ctrl_non_mpc_compliant_libs}->GetItemText($i);
            $to_remove .= "\n- $sel_text";
            push(@selections, $sel_text);

            push(@paths, $sel_text);
        }

        my $rc = Wx::MessageBox(
                    "Removing\n$to_remove.\n\n".
                    "Do you really want to proceed ?",
                    "Removing",
                    Wx::wxYES_NO | Wx::wxICON_QUESTION);
        if ($rc == Wx::wxYES)
        {
            foreach my $sel_text (@selections)
            {
                $self->{non_mpc_compliant_node_lib}->remove_far_node($sel_text);
            }

            $self->fill_list_ctrl_non_mpc_compliant_libs();

            my $tree_ctrl;
            my $node;
            $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

            my @parent_paths;
            foreach my $path (@paths)
            {
                my ($parent_path) = $path =~ /(.*)\/(.*)$/;
                push(@parent_paths, "$node->{id}/$parent_path");
            }

            $self->fill_tree_ctrl_non_mpc_compliant($tree_ctrl, $node, \@parent_paths);
        }
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::list_ctrl_non_mpc_compliant_libs_key_down <event_handler>
    warn "Event handler (list_ctrl_non_mpc_compliant_libs_key_down) not implemented";
    $event->Skip;
    # end wxGlade
}

sub on_notebook_non_mpc_compliant_changed
{
    my ($self, $event) = @_;

    if (!$self->validate_non_mpc_compliant_parameters())
    {
        return;
    }

    my $page_text = $self->{notebook_non_mpc_compliant}->GetPageText($event->GetSelection());

    if ($page_text eq "info")
    {
        return;
    }

    if ($page_text eq "lib") # Just to display with the right size while the tree is reset
    {
        $self->{splitter_lib}->SetMinimumPaneSize(50);
        my ($w, $h) = $self->{notebook_non_mpc_pane_lib}->GetSizeWH();
        $self->{splitter_lib}->SetSashPosition(0.30 * $w);
    }

    my $wait = Wx::BusyCursor->new();

    my $current_filter_text = $self->{text_ctrl_non_mpc_compliant_tree_filter}->GetValue();
    $self->set_filter_text($page_text);
    my $new_filter_text = $self->{text_ctrl_non_mpc_compliant_tree_filter}->GetValue();

    if ($new_filter_text ne $current_filter_text)
    {
        $self->call_fill_non_mpc_compliant_tree_root_path();
    }

    $self->non_mpc_compliant_reset_tree_ctrl($page_text);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_notebook_non_mpc_compliant_changed <event_handler>
    warn "Event handler (on_notebook_non_mpc_compliant_changed) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_non_mpc_compliant_set_product
{
    my ($self, $event) = @_;

    if (!$self->validate_non_mpc_compliant_parameters())
    {
        return;
    }

    my @leaves;
    $self->{non_mpc_compliant_node_lib}->get_leaves(\@leaves);

    foreach my $leaf (@leaves)
    {
        my $win_dll = 0;
        if ($^O =~ /Win/)
        {
            if ($leaf->{id} =~ /\.dll$/)
            {
                $win_dll = 1;
            }
        }

        # Are mpb files set ?
        if (!$win_dll && $leaf->{mpb_file} eq "")
        {
            if ($self->candidate_for_mpb_file($leaf->{id}))
            {
                Wx::MessageBox("MPB file must be set for all libraries.", "", Wx::wxOK | Wx::wxICON_ERROR);
                return;
            }
        }

        # Are types (static/dynamic) set ?
        if (!$win_dll && $leaf->{type} eq "")
        {
            Wx::MessageBox("Type (static/dynamic) must be set for all libraries.", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }

        # Are build_config (Debug/Release) set ?
        if ($leaf->{build_config} eq DPOUtils::BUILD_CONFIG_NOT_SET)
        {
            if ($self->candidate_for_mpb_file($leaf->{id}))
            {
                Wx::MessageBox("Build config (Debug/Release) must be set for all libraries.", "", Wx::wxOK | Wx::wxICON_ERROR);
                return;
            }
        }
    }

    my $wait = Wx::BusyCursor->new();

    # Set dynamic_debug_dll, dynamic_release_dll, dynamic_debug_lib, dynamic_release_lib
    my @non_compliant_libs;
    foreach my $leaf (@leaves)
    {
        my $non_compliant_lib = 0;

        foreach my $lib (@non_compliant_libs)
        {
            #~ if ($lib->{mpb_name} eq $leaf->{mpb_file}
                #~ && $lib->{type} eq $leaf->{type})
            if ($lib->{mpb_name} eq $leaf->{mpb_file})
            {
                $non_compliant_lib = $lib;
                last;
            }
        }

        if ($non_compliant_lib == 0)
        {
            if ($leaf->{mpb_file} eq "")
            {
                next;
            }

            if ($leaf->{mpb_file} =~ /(.*)_dpo$/
                || $leaf->{mpb_file} =~ /(.*)_dpo_static$/)
            {
                my $lib_id = $1;
                $non_compliant_lib = DPONonCompliantLib->new($lib_id, $leaf->{mpb_file});
                $non_compliant_lib->{type} = $leaf->{type}; # Add a new DPONonCompliantLib field to work with DPONonMPCLibAssociationDlg
                push(@non_compliant_libs, $non_compliant_lib);
            }
        }

        if ($leaf->{type} eq "static")
        {
            if ($leaf->{build_config} eq DPOUtils::BUILD_CONFIG_DEBUG
                    || $leaf->{build_config} eq DPOUtils::BUILD_CONFIG_DEBUG_RELEASE)
            {
                $non_compliant_lib->{static_debug_lib} = $leaf->{id};
            }

            if ($leaf->{build_config} eq DPOUtils::BUILD_CONFIG_RELEASE
                || $leaf->{build_config} eq DPOUtils::BUILD_CONFIG_DEBUG_RELEASE)
            {
                $non_compliant_lib->{static_release_lib} = $leaf->{id};
            }
        }

        if ($leaf->{type} eq "dynamic")
        {
            if ($leaf->{build_config} eq DPOUtils::BUILD_CONFIG_DEBUG
                || $leaf->{build_config} eq DPOUtils::BUILD_CONFIG_DEBUG_RELEASE)
            {
                if ($leaf->{id} =~ /\.dll$/)
                {
                    $non_compliant_lib->{dynamic_debug_dll} = $leaf->{id};
                }
                else
                {
                    $non_compliant_lib->{dynamic_debug_lib} = $leaf->{id};
                }
            }

            if ($leaf->{build_config} eq DPOUtils::BUILD_CONFIG_RELEASE
                || $leaf->{build_config} eq DPOUtils::BUILD_CONFIG_DEBUG_RELEASE)
            {
                if ($leaf->{id} =~ /\.dll$/)
                {
                    $non_compliant_lib->{dynamic_release_dll} = $leaf->{id};
                }
                else
                {
                    $non_compliant_lib->{dynamic_release_lib} = $leaf->{id};
                }
            }
        }

        if (!$non_compliant_lib->{plugin})
        {
            $non_compliant_lib->{plugin} = $leaf->{plugin};
        }
    }

    my $missing = 0;
    foreach my $lib (@non_compliant_libs)
    {
        if ($lib->{type} eq "dynamic")
        {
            if ($lib->{dynamic_release_dll} eq ""
                || $lib->{dynamic_debug_dll} eq "")
            {
                $missing = 1;
                last;
            }
        }
    }

    if ($missing)
    {
        my $product_name = $self->{text_ctrl_non_mpc_compliant_product_name}->GetValue();

        my $dlg = DPONonMPCLibAssociationDlg->new(
            $product_name,
            $self->{text_ctrl_non_mpc_compliant_root_path}->GetValue(),
            \@non_compliant_libs,
            undef,
            -1,
            "",
            Wx::wxDefaultPosition,
            Wx::wxDefaultSize,
            Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

        $dlg->Centre();

        my $rc = $dlg->ShowModal();
        $dlg->Destroy();
        if ($rc == Wx::wxID_CANCEL)
        {
            return;
        }
    }

    # Get product
    my $product_name = $self->{text_ctrl_non_mpc_compliant_product_name}->GetValue();
    my $flavour = $self->{text_ctrl_non_mpc_compliant_product_flavour}->GetValue();
    if ($flavour eq "")
    {
        Wx::MessageBox("If you want an empty flavour, inscribe 'vanilla'.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }
    my $flavour_sub_path = "$flavour/";
    my $version = $self->{text_ctrl_non_mpc_compliant_product_version}->GetValue();

    my $product_path = $self->{text_ctrl_non_mpc_compliant_pool_path}->GetValue() . "/$product_name/$flavour_sub_path$version";
    $product_path =~ s/\\/\//g;
    if (!$self->copy_dpo_product_xml_template($product_path))
    {
        return;
    }

    my $rc = Wx::MessageBox(
                "There is no validation on which files you enter. Be sure that all necessary stuff has been included.\n\n".
                "Do you want to set product now ?",
                "Setting product",
                Wx::wxYES_NO | Wx::wxICON_QUESTION);

    if ($rc == Wx::wxNO)
    {
        return;
    }

    # Assign product properties
    my $config_product = DPOProductConfig->new("$product_path/DPOProduct.xml");
    if ($config_product)
    {
        my $product;
        if (!$config_product->get_product(\$product))
        {
            Wx::MessageBox("Failed to get product from $config_product->{xml_file}", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }

        $product->{name} = $product_name;
        $product->{version} = $version;
        $product->{flavour} = $flavour;
        $product->{dpo_compliant_product}->{value} = 0;
        $product->{dpo_compliant_product}->{mpc_compliant} = 0;

        $product->{mpc_includes} = "\$(" . uc($product->{name}) . "_ROOT)/MPC";

        # Assign non_compliant_libs
        $product->{dpo_compliant_product}->{non_compliant_lib_seq} = \@non_compliant_libs;

        # Save product
        if (!$config_product->save($product, 1))
        {
            Wx::MessageBox("Can't update $product_path/DPOProduct.xml", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }
    }
    else
    {
        Wx::MessageBox("Failed to load product from $config_product->{xml_file}", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    # Copy...

    # includes
    if (!$self->copy_non_mpc_compliant_elements($product_path, $self->{non_mpc_compliant_node_include}))
    {
        return;
    }

    # libs
    if (!$self->copy_non_mpc_compliant_elements($product_path, $self->{non_mpc_compliant_node_lib}))
    {
        return;
    }

    # bins
    if (!$self->copy_non_mpc_compliant_elements($product_path, $self->{non_mpc_compliant_node_bin}))
    {
        return;
    }

    # etcs
    if (!$self->copy_non_mpc_compliant_elements($product_path, $self->{non_mpc_compliant_node_etc}))
    {
        return;
    }

    # vars
    if (!$self->copy_non_mpc_compliant_elements($product_path, $self->{non_mpc_compliant_node_var}))
    {
        return;
    }

    # docs
    if (!$self->copy_non_mpc_compliant_elements($product_path, $self->{non_mpc_compliant_node_doc}))
    {
        return;
    }

    # set new product env. var.
    my @listEnvVarValues;
    my $product_env_var = DPOEnvVar->new(uc($product_name) . "_ROOT", $product_path);
    push(@listEnvVarValues, $product_env_var);

    $rc = DPOEnvVars::system_set_env_vars(\@listEnvVarValues);
    if (!$rc)
    {
        Wx::MessageBox("Failed to set $product_name environment variable.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    Wx::MessageBox("Product set.");

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_non_mpc_compliant_set_product <event_handler>
    warn "Event handler (on_button_non_mpc_compliant_set_product) not implemented";
    $event->Skip;
    # end wxGlade
}

sub on_tree_ctrl_non_mpc_compliant_menu
{
    my ($self, $event) = @_;

    my $tree_ctrl;
    my $node;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    my $item = $event->GetItem();

    $self->{non_mpc_compliant_target} = DPOUtils::get_tree_item_path($tree_ctrl, $item);

    $tree_ctrl->SelectItem($item);  # $item is not necessary selected. We have
                                    # to force the item to be selected because
                                    # non_mpc_compliant_remove() refers to the
                                    # selected one.

    my $menuPopUp = Wx::Menu->new();
    $menuPopUp->Append(NON_MPC_COMPLIANT_NEW_DIRECTORY, "New subdirectory");
    $menuPopUp->Append(NON_MPC_COMPLIANT_REMOVE, "Remove");
    $menuPopUp->Append(NON_MPC_COMPLIANT_RENAME, "Rename");
    $tree_ctrl->PopupMenu($menuPopUp, $event->GetPoint());
}


sub on_non_mpc_compliant_new_directory
{
    my ($self, $event) = @_;

    my $tree_ctrl = 0;
    my $node = 0;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);
    my $sub_node = $node->find_node($self->{non_mpc_compliant_target});
    if ($sub_node)
    {
        if ($sub_node->{node_or_leaf} eq "node")
        {
            my $dlg = DPOExternalMigrationNonMPCCompliantNewDirDlg->new(
                undef,
                -1,
                "",
                Wx::wxDefaultPosition,
                Wx::wxDefaultSize,
                Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

            $dlg->Centre();

            if ($dlg->ShowModal() == Wx::wxID_OK)
            {
                    my $new_id = $dlg->{text_ctrl_new_dir}->GetValue();
                    $sub_node->add($new_id, "node", 1, "", 0);
            }
            else
            {
            }

            my $item = $tree_ctrl->GetSelection(); # Can get selection here because SelectItem() was called in on_tree_ctrl_non_mpc_compliant_menu
            my $path = DPOUtils::get_tree_item_path($tree_ctrl, $item);
            $self->fill_tree_ctrl_non_mpc_compliant($tree_ctrl, $node, [$path]);

            $dlg->Destroy();
        }
    }
    else
    {
        DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["$self->{non_mpc_compliant_target} node not found"]);
        return;
    }

    return;
}


sub on_non_mpc_compliant_remove
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_remove();
}

sub on_non_mpc_compliant_rename
{
    my ($self, $event) = @_;

    my $tree_ctrl;
    my $node;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    my $item = $tree_ctrl->GetSelection();
    $tree_ctrl->EditLabel($item);
}


sub on_menu_static
{
    my ($self, $event) = @_;

    $self->set_non_mpc_compliant_type("static");

    return;
}

sub on_menu_dynamic
{
    my ($self, $event) = @_;

    $self->set_non_mpc_compliant_type("dynamic");

    return;
}

sub on_menu_debug
{
    my ($self, $event) = @_;

    $self->set_build_config(DPOUtils::BUILD_CONFIG_DEBUG);
}

sub on_menu_release
{
    my ($self, $event) = @_;

    $self->set_build_config(DPOUtils::BUILD_CONFIG_RELEASE);
}

sub on_menu_debug_release
{
    my ($self, $event) = @_;

    $self->set_build_config(DPOUtils::BUILD_CONFIG_DEBUG_RELEASE);
}

sub on_menu_plugin
{
    my ($self, $event) = @_;

    $self->set_non_mpc_compliant_type("plugin");

    return;
}

sub on_button_mpb
{
    my ($self, $event) = @_;

    if (!$self->validate_non_mpc_compliant_parameters())
    {
        return;
    }

    my %libs;
    my @selected_indexes;
    if (!$self->is_type_set_for_all_libs())
    {
        Wx::MessageBox("Not all 'type' (static/Dynamic) have type been defined for libs", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    my $tree_ctrl;
    my $node;
    $self->non_mpc_compliant_notebook_page_tree_ctrl_and_node(\$tree_ctrl, \$node);

    my $pool_path = $self->{text_ctrl_non_mpc_compliant_pool_path}->GetValue();
    $pool_path =~ s/\\/\//g;

    my $product_name = $self->{text_ctrl_non_mpc_compliant_product_name}->GetValue();
    my $dlg = DPOAutoDiscoverMPBDlg->new(
        $node,
        $pool_path,
        $product_name,
        $self->{text_ctrl_non_mpc_compliant_product_version}->GetValue(),
        $self->{text_ctrl_non_mpc_compliant_product_flavour}->GetValue(),
        undef,
        -1,
        "",
        Wx::wxDefaultPosition,
        Wx::wxDefaultSize,
        Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

    if ($dlg != 0)
    {
        $dlg->Centre();

        if ($dlg->ShowModal() == Wx::wxID_OK)
        {
            $self->fill_list_ctrl_non_mpc_compliant_libs();
        }

        $dlg->Destroy();
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_mpb <event_handler>
    warn "Event handler (on_button_mpb) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_include_key_down
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_key_down($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_include_key_down <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_include_key_down) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_include_begin_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_begin_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_include_begin_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_include_begin_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_include_end_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_end_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_include_end_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_include_end_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_etc_key_down
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_key_down($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_etc_key_down <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_etc_key_down) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_etc_end_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_end_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_etc_end_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_etc_end_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_etc_begin_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_begin_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_etc_begin_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_etc_begin_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_var_key_down
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_key_down($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_var_key_down <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_var_key_down) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_var_end_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_end_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_var_end_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_var_end_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_var_begin_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_begin_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_var_begin_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_var_begin_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_doc_key_down
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_key_down($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_doc_key_down <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_doc_key_down) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_doc_end_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_end_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_doc_end_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_doc_end_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_doc_begin_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_begin_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_doc_begin_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_doc_begin_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_lib_key_down
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_key_down($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_lib_key_down <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_lib_key_down) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_lib_end_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_end_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_lib_end_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_lib_end_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_lib_begin_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_begin_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_lib_begin_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_lib_begin_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_bin_key_down
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_key_down($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_bin_key_down <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_bin_key_down) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_bin_end_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_end_edit_label();

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_bin_end_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_bin_end_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_non_mpc_compliant_bin_begin_label_edit
{
    my ($self, $event) = @_;

    $self->non_mpc_compliant_tree_item_begin_edit_label($event);

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_tree_ctrl_non_mpc_compliant_bin_begin_label_edit <event_handler>
    warn "Event handler (on_tree_ctrl_non_mpc_compliant_bin_begin_label_edit) not implemented";
    $event->Skip;
    # end wxGlade
}



sub list_ctrl_non_mpc_compliant_libs_right_click
{
    my ($self, $event) = @_;

    my $menuPopUp = Wx::Menu->new();
    $menuPopUp->Append(LIST_CTRL_NON_MPC_COMPLIANT_MENU_STATIC, "Static");
    $menuPopUp->Append(LIST_CTRL_NON_MPC_COMPLIANT_MENU_DYNAMIC, "Dynamic");
    $menuPopUp->Append(LIST_CTRL_NON_MPC_COMPLIANT_MENU_DEBUG, "Debug");
    $menuPopUp->Append(LIST_CTRL_NON_MPC_COMPLIANT_MENU_RELEASE, "Release");
    $menuPopUp->Append(LIST_CTRL_NON_MPC_COMPLIANT_MENU_DEBUG_RELEASE, "Debug/Release");
    $menuPopUp->Append(LIST_CTRL_NON_MPC_COMPLIANT_MENU_PLUGIN, "Plugin");
    $self->{list_ctrl_non_mpc_compliant_libs}->PopupMenu($menuPopUp, $event->GetPoint());

    return;

    # wxGlade: DPOPanelExternalProductMigration::list_ctrl_non_mpc_compliant_libs_right_click <event_handler>
    warn "Event handler (list_ctrl_non_mpc_compliant_libs_right_click) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_checkbox_show_dll
{
    my ($self, $event) = @_;

    $self->fill_list_ctrl_non_mpc_compliant_libs();

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_checkbox_show_dll <event_handler>
    warn "Event handler (on_checkbox_show_dll) not implemented";
    $event->Skip;
    # end wxGlade
}



sub on_button_collapse_all
{
    my ($self, $event) = @_;

    my $tree_ctrl = $self->{tree_ctrl_non_mpc_compliant_tree_root_path};

    my $locker = Wx::WindowUpdateLocker->new($self);
    $tree_ctrl->CollapseAll();
    my $root = $tree_ctrl->GetRootItem();
    my ($child, $cookie) = $tree_ctrl->GetFirstChild($root);
    if ($child && $child->IsOk())
    {
        $tree_ctrl->EnsureVisible($child);
    }

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_button_collapse_all <event_handler>
    warn "Event handler (on_button_collapse_all) not implemented";
    $event->Skip;
    # end wxGlade
}



sub on_combo_box_non_mpc_compliant_test
{
    my ($self, $event) = @_;

    my $value = $self->{combo_box_non_mpc_compliant_test}->GetValue();

    if ($value eq "no test")
    {
        $self->{text_ctrl_non_mpc_compliant_root_path}->SetValue($self->{previous_non_mpc_compliant_root_path});
        $self->{text_ctrl_non_mpc_compliant_pool_path}->SetValue($self->{previous_non_mpc_compliant_pool_path});
        $self->{text_ctrl_non_mpc_compliant_product_name}->SetValue($self->{previous_non_mpc_compliant_product_name});
        $self->{text_ctrl_non_mpc_compliant_product_version}->SetValue($self->{previous_non_mpc_compliant_product_version});
        $self->{text_ctrl_non_mpc_compliant_product_flavour}->SetValue($self->{previous_non_mpc_compliant_product_flavour});
    }

    if ($value eq "wxWidgets")
    {
        my $dpo_pool_path =  "\$(DPO_POOL_ROOT)/vc10/thirdparty";
        if (!DPOEnvVars::expand_env_var(\$dpo_pool_path))
        {
            $dpo_pool_path = "";
        }

        if ($self->{previous_non_mpc_compliant_test_choice} eq "no test")
        {
            $self->{previous_non_mpc_compliant_root_path} = $self->{text_ctrl_non_mpc_compliant_root_path}->GetValue();
            $self->{previous_non_mpc_compliant_pool_path} = $self->{text_ctrl_non_mpc_compliant_pool_path}->GetValue();
            $self->{previous_non_mpc_compliant_product_name} = $self->{text_ctrl_non_mpc_compliant_product_name}->GetValue();
            $self->{previous_non_mpc_compliant_product_version} = $self->{text_ctrl_non_mpc_compliant_product_version}->GetValue();
            $self->{previous_non_mpc_compliant_product_flavour} = $self->{text_ctrl_non_mpc_compliant_product_flavour}->GetValue();
        }

        $self->{text_ctrl_non_mpc_compliant_root_path}->SetValue("C:/usr/wxWidgets-3.0.2");
        $self->{text_ctrl_non_mpc_compliant_pool_path}->SetValue($dpo_pool_path);
        $self->{text_ctrl_non_mpc_compliant_product_name}->SetValue("wxWidgets");
        $self->{text_ctrl_non_mpc_compliant_product_version}->SetValue("3.0.2");
        $self->{text_ctrl_non_mpc_compliant_product_flavour}->SetValue("has_mode_t");
    }

    if ($value eq "External1")
    {
        my $dpo_scripts_tests_path = "\$(DPO_CORE_ROOT)/scripts/tests/Externals/External1";
        if (!DPOEnvVars::expand_env_var(\$dpo_scripts_tests_path))
        {
            $dpo_scripts_tests_path = "";
        }

        my $dpo_pool_path =  "\$(DPO_POOL_ROOT)/vc10/thirdparty/htalbot";
        DPOEnvVars::expand_env_var(\$dpo_pool_path);

        if ($self->{previous_non_mpc_compliant_test_choice} eq "no test")
        {
            $self->{previous_non_mpc_compliant_root_path} = $self->{text_ctrl_non_mpc_compliant_root_path}->GetValue();
            $self->{previous_non_mpc_compliant_pool_path} = $self->{text_ctrl_non_mpc_compliant_pool_path}->GetValue();
            $self->{previous_non_mpc_compliant_product_name} = $self->{text_ctrl_non_mpc_compliant_product_name}->GetValue();
            $self->{previous_non_mpc_compliant_product_version} = $self->{text_ctrl_non_mpc_compliant_product_version}->GetValue();
            $self->{previous_non_mpc_compliant_product_flavour} = $self->{text_ctrl_non_mpc_compliant_product_flavour}->GetValue();
        }

        $self->{text_ctrl_non_mpc_compliant_root_path}->SetValue($dpo_scripts_tests_path);
        $self->{text_ctrl_non_mpc_compliant_pool_path}->SetValue($dpo_pool_path);
        $self->{text_ctrl_non_mpc_compliant_product_name}->SetValue("External1");
        $self->{text_ctrl_non_mpc_compliant_product_version}->SetValue("0.0.1");
        $self->{text_ctrl_non_mpc_compliant_product_flavour}->SetValue("vanilla");
    }

    $self->{previous_non_mpc_compliant_test_choice} = $value;

    return;

    # wxGlade: DPOPanelExternalProductMigration::on_combo_box_non_mpc_compliant_test <event_handler>
    warn "Event handler (on_combo_box_non_mpc_compliant_test) not implemented";
    $event->Skip;
    # end wxGlade
}

# end of class DPOPanelExternalProductMigration

1;

