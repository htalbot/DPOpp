use lib $ENV{DPO_CORE_ROOT} . "/scripts";

# generated by wxGlade 0.6.8 on Fri Sep 04 05:00:53 2015
#
# To get wxPerl visit http://wxPerl.sourceforge.net/
#

use Wx 0.15 qw[:allclasses];
use strict;
use List::MoreUtils;

use DPOUtils;
use DPOProduct;
use DPOProject;
use DPOEvents;
use DPOEnvVars;
use DPOActions;
use DPONewCompliantProductDlg;
use DPOProductNewProjectDlg;
use DPOProductVersionDlg;
use DPOProductStaticDynamicChoiceDlg;
use DPOProductWorkspaceProjectsVersionsDlg;
use DPOProductWorkspaceProjectSideDlg;
use DPOProductNonProductMPBDlg;
use DPOProductHighlightDlg;
use DPOLayersDlg;
use DPOFrameRecalls;
use DPOProductNonCompliantLibsDlg;

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade


package DPOPanelProductDropTarget; # Drag and drop class

use Wx qw[:everything];
#~ use Wx::DND;
use base qw( Wx::TextDropTarget );

sub new
{
    my $class = shift;
    my $panel= shift;

    my $self = $class->SUPER::new(@_);

    $self->{panel} = $panel;

    return $self;
}

sub OnDropText
{
    my ( $self, $x, $y, $source ) = @_;

    #~ print "OnDropText... $source\n";

    $self->{panel}->drag_copy($x, $y, $source);

    return 1;    # important
}

1;


package DPORuntimeDependencyToRemove;

sub new
{
    my ($class,
        $parent,
        $dep) = @_;

    my $self =
    {
        parent => $parent,
        dep => $dep
    };

    bless($self, $class);

    return $self;
}

1;


package ToCopy;

sub new
{
    my ($class,
        $version,
        $target_version,
        $flavour,
        $compliant) = @_;

    my $self =
    {
        compliant => $compliant,
        version => $version,
        target_version => $target_version,
        flavour => $flavour,
        names => []
    };

    bless($self, $class);

    return $self;
}

1;

package DPORecall;

sub new
{
    my ($class,
        $recall_text,
        $status) = @_;

    my $self =
    {
        recall_text => $recall_text,
        status => $status
    };

    bless($self, $class);

    return $self;
}

1;


package DPOPanelProduct;

use Wx qw[:everything];
use base qw(Wx::Panel);
use Wx::Locale 'gettext' => '_T', 'gettext_noop' => 'gettext_noop';

use constant
{
    DEPENDENCY_STATIC => 0,
    DEPENDENCY_DYNAMIC => 1,
    DEPENDENCY_REMOVE => 2,
    SHOW_DEPENDENCIES_ACCORDING_TO_TYPES => 3,
    SET_AS_WORKING_PROJECT => 4,
    REMOVE_FROM_WORKSPACE => 5,
    REMOVE_RUNTIME_FROM_WORKSPACE => 6,
    REMOVE_RUNTIME_IN_WORKSPACE => 7,
    GENERATE_SELECTED_PROJECTS => 8
};


my $col_red = Wx::Colour->new(255, 0, 0);
my $col_black = Wx::Colour->new(0, 0, 0);
my $col_white = Wx::Colour->new(255, 255, 255);
my $col_executable_dep = Wx::Colour->new(219, 219, 112);


sub new {
    my( $self, $parent, $id, $pos, $size, $style, $name ) = @_;
    $parent = undef              unless defined $parent;
    $id     = -1                 unless defined $id;
    $pos    = wxDefaultPosition  unless defined $pos;
    $size   = wxDefaultSize      unless defined $size;
    $name   = ""                 unless defined $name;

    # begin wxGlade: DPOPanelProduct::new
    $style = wxTAB_TRAVERSAL
        unless defined $style;

    $self = $self->SUPER::new( $parent, $id, $pos, $size, $style, $name );
    $self->{notebook_modules} = Wx::Notebook->new($self, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
    $self->{notebook_modules_pane_product} = Wx::Panel->new($self->{notebook_modules}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{label_product} = Wx::StaticText->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("MRU:"), wxDefaultPosition, wxDefaultSize, );
    $self->{combo_box_product} = Wx::ComboBox->new($self->{notebook_modules_pane_product}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{button_product_browse} = Wx::Button->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("..."));
    $self->{button_product_open} = Wx::Button->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("Open"));
    $self->{button_local_env_var} = Wx::Button->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("Local env. var."));
    $self->{radio_btn_available_projects_all} = Wx::RadioButton->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("All product projects"), wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
    $self->{radio_btn_available_projects_dependants_of} = Wx::RadioButton->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("Dependants of:"), wxDefaultPosition, wxDefaultSize, );
    $self->{combo_box_available_projects_dependants_of} = Wx::ComboBox->new($self->{notebook_modules_pane_product}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN|wxCB_SORT);
    $self->{button_available_projects_dependants_of} = Wx::Button->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("..."));
    $self->{button_available_projects_get} = Wx::Button->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("Get"));
    $self->{list_ctrl_product_projects} = Wx::ListCtrl->new($self->{notebook_modules_pane_product}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{label_project_count} = Wx::StaticText->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("Project count:"), wxDefaultPosition, wxDefaultSize, );
    $self->{text_ctrl_project_count} = Wx::TextCtrl->new($self->{notebook_modules_pane_product}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, wxTE_READONLY);
    $self->{button_project_new} = Wx::Button->new($self->{notebook_modules_pane_product}, wxID_ANY, _T("New project..."));
    $self->{notebook_modules_pane_external} = Wx::Panel->new($self->{notebook_modules}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{notebook_external} = Wx::Notebook->new($self->{notebook_modules_pane_external}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxNB_LEFT);
    $self->{notebook_runtime_pack_pane} = Wx::Panel->new($self->{notebook_external}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_external_modules} = Wx::TreeCtrl->new($self->{notebook_runtime_pack_pane}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_MULTIPLE|wxTR_HIDE_ROOT|wxTR_MULTIPLE|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{text_ctrl_external_modules_plugin} = Wx::TextCtrl->new($self->{notebook_runtime_pack_pane}, wxID_ANY, _T("Plugin"), wxDefaultPosition, wxDefaultSize, wxTE_READONLY|wxTE_CENTRE);
    $self->{text_ctrl_external_modules_executable} = Wx::TextCtrl->new($self->{notebook_runtime_pack_pane}, wxID_ANY, _T("Executable"), wxDefaultPosition, wxDefaultSize, wxTE_READONLY|wxTE_CENTRE);
    $self->{text_ctrl_external_modules_undeterminable} = Wx::TextCtrl->new($self->{notebook_runtime_pack_pane}, wxID_ANY, _T("Unknown"), wxDefaultPosition, wxDefaultSize, wxTE_READONLY|wxTE_CENTRE);
    $self->{notebook_external_pane_2} = Wx::Panel->new($self->{notebook_external}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_runtime_pack} = Wx::TreeCtrl->new($self->{notebook_external_pane_2}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_MULTIPLE|wxTR_HIDE_ROOT|wxTR_MULTIPLE|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{button_runtime_pack_expand} = Wx::Button->new($self->{notebook_external_pane_2}, wxID_ANY, _T("+"));
    $self->{sizer_modules_to_import_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("Available projects/modules") );
    $self->{notebook_workspace_runtime} = Wx::Notebook->new($self, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
    $self->{notebook_workspace_runtime_pane_workspace} = Wx::Panel->new($self->{notebook_workspace_runtime}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{combo_box_workspaces} = Wx::ComboBox->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN|wxCB_SORT);
    $self->{button_workspace_open} = Wx::Button->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Open"));
    $self->{button_recalls} = Wx::Button->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("!"));
    $self->{tree_ctrl_workspace_projects} = Wx::TreeCtrl->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_MULTIPLE|wxTR_HIDE_ROOT|wxTR_MULTIPLE|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{button_workspace_projects_expand} = Wx::Button->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("+"));
    $self->{button_versions} = Wx::Button->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Versions..."));
    $self->{text_ctrl_working_project_current_version} = Wx::TextCtrl->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, wxTE_READONLY|wxTE_CENTRE);
    $self->{sizer_71_staticbox} = Wx::StaticBox->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Current version") );
    $self->{text_ctrl_working_project_target_version} = Wx::TextCtrl->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, wxTE_CENTRE);
    $self->{sizer_72_staticbox} = Wx::StaticBox->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Target version") );
    $self->{checkbox_dynamic} = Wx::CheckBox->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Dynamic"), wxDefaultPosition, wxDefaultSize, );
    $self->{checkbox_static} = Wx::CheckBox->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Static"), wxDefaultPosition, wxDefaultSize, );
    $self->{sizer_type_staticbox} = Wx::StaticBox->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Type") );
    $self->{tree_ctrl_working_project_dynamic} = Wx::TreeCtrl->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_MULTIPLE|wxTR_HIDE_ROOT|wxTR_MULTIPLE|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{sizer_working_project_type_dynamic_staticbox} = Wx::StaticBox->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Dynamic side") );
    $self->{tree_ctrl_working_project_static} = Wx::TreeCtrl->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_MULTIPLE|wxTR_HIDE_ROOT|wxTR_MULTIPLE|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{sizer_working_project_type_static_staticbox} = Wx::StaticBox->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Static side") );
    $self->{button_working_project_expand} = Wx::Button->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("+"));
    $self->{button_layers} = Wx::Button->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Layers..."));
    $self->{sizer_working_project_staticbox} = Wx::StaticBox->new($self->{notebook_workspace_runtime_pane_workspace}, wxID_ANY, _T("Working project (*** no selection ***)") );
    $self->{notebook_workspace_runtime_pane_runtime} = Wx::Panel->new($self->{notebook_workspace_runtime}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{notebook_runtime} = Wx::Notebook->new($self->{notebook_workspace_runtime_pane_runtime}, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
    $self->{notebook_8_pane_runtime_modules} = Wx::Panel->new($self->{notebook_runtime}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_runtime} = Wx::TreeCtrl->new($self->{notebook_8_pane_runtime_modules}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_MULTIPLE|wxTR_HIDE_ROOT|wxTR_MULTIPLE|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{notebook_8_pane_2} = Wx::Panel->new($self->{notebook_runtime}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{tree_ctrl_runtime_in_workspace} = Wx::TreeCtrl->new($self->{notebook_8_pane_2}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTR_HAS_BUTTONS|wxTR_LINES_AT_ROOT|wxTR_HIDE_ROOT|wxTR_DEFAULT_STYLE|wxSUNKEN_BORDER);
    $self->{notebook_runtime_pane_1} = Wx::Panel->new($self->{notebook_runtime}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{label_2} = Wx::StaticText->new($self->{notebook_runtime_pane_1}, wxID_ANY, _T("TO_DO ?"), wxDefaultPosition, wxDefaultSize, );
    $self->{button_runtime_expand} = Wx::Button->new($self->{notebook_workspace_runtime_pane_runtime}, wxID_ANY, _T("+"));
    $self->{button_runtime_pack} = Wx::Button->new($self->{notebook_workspace_runtime_pane_runtime}, wxID_ANY, _T("Pack..."));
    $self->{sizer_product_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("Product workspace/runtime") );
    $self->{button_expand_all} = Wx::Button->new($self, wxID_ANY, _T("+"));
    $self->{button_highlight} = Wx::Button->new($self, wxID_ANY, _T("Highlight..."));
    $self->{sizer_74_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("Operations") );
    $self->{combo_box_arch} = Wx::ComboBox->new($self, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN|wxCB_READONLY);
    $self->{sizer_53_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("Architecture") );
    $self->{combo_box_os} = Wx::ComboBox->new($self, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{sizer_54_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("OS") );
    $self->{combo_box_toolchain} = Wx::ComboBox->new($self, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, [], wxCB_DROPDOWN);
    $self->{sizer_57_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("Tool chain") );
    $self->{checkbox_validate} = Wx::CheckBox->new($self, wxID_ANY, _T("Validate"), wxDefaultPosition, wxDefaultSize, );
    $self->{checkbox_set_env_vars} = Wx::CheckBox->new($self, wxID_ANY, _T("Env. vars."), wxDefaultPosition, wxDefaultSize, );
    $self->{checkbox_fetch_runtime} = Wx::CheckBox->new($self, wxID_ANY, _T("Fetch runtime"), wxDefaultPosition, wxDefaultSize, );
    $self->{checkbox_generate} = Wx::CheckBox->new($self, wxID_ANY, _T("Generate"), wxDefaultPosition, wxDefaultSize, );
    $self->{checkbox_freeze} = Wx::CheckBox->new($self, wxID_ANY, _T("Freeze"), wxDefaultPosition, wxDefaultSize, );
    $self->{checkbox_fix} = Wx::CheckBox->new($self, wxID_ANY, _T("Fix"), wxDefaultPosition, wxDefaultSize, );
    $self->{checkbox_cleanup} = Wx::CheckBox->new($self, wxID_ANY, _T("Clean"), wxDefaultPosition, wxDefaultSize, );
    $self->{button_action} = Wx::Button->new($self, wxID_ANY, _T("Action"));
    $self->{sizer_59_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("Actions") );
    $self->{button_ide} = Wx::Button->new($self, wxID_ANY, _T("Go to..."));
    $self->{sizer_ide_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("IDE") );
    $self->{sizer_generation_parent_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("Generation") );

    $self->__set_properties();
    $self->__do_layout();

    Wx::Event::EVT_TEXT($self, $self->{combo_box_product}->GetId, \&on_combo_box_product_text);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_product}->GetId, \&on_combo_box_product);
    Wx::Event::EVT_BUTTON($self, $self->{button_product_browse}->GetId, \&on_button_product_browse);
    Wx::Event::EVT_BUTTON($self, $self->{button_product_open}->GetId, \&on_button_product_open);
    Wx::Event::EVT_BUTTON($self, $self->{button_local_env_var}->GetId, \&on_button_local_env_var);
    Wx::Event::EVT_RADIOBUTTON($self, $self->{radio_btn_available_projects_all}->GetId, \&on_radio_btn_all_product_projects);
    Wx::Event::EVT_RADIOBUTTON($self, $self->{radio_btn_available_projects_dependants_of}->GetId, \&on_radio_btn_dependants_of);
    Wx::Event::EVT_BUTTON($self, $self->{button_available_projects_dependants_of}->GetId, \&on_button_available_projects_dependants_of);
    Wx::Event::EVT_BUTTON($self, $self->{button_available_projects_get}->GetId, \&on_button_product_projects_get);
    Wx::Event::EVT_LIST_BEGIN_DRAG($self, $self->{list_ctrl_product_projects}->GetId, \&on_list_ctrl_product_projects_begin_drag);
    Wx::Event::EVT_BUTTON($self, $self->{button_project_new}->GetId, \&on_button_project_new);
    Wx::Event::EVT_TREE_BEGIN_DRAG($self, $self->{tree_ctrl_external_modules}->GetId, \&on_tree_ctrl_external_modules_begin_drag);
    Wx::Event::EVT_TREE_ITEM_EXPANDING($self, $self->{tree_ctrl_external_modules}->GetId, \&on_tree_ctrl_external2_expanding);
    Wx::Event::EVT_TREE_BEGIN_DRAG($self, $self->{tree_ctrl_runtime_pack}->GetId, \&on_tree_ctrl_runtime_pack_begin_drag);
    Wx::Event::EVT_BUTTON($self, $self->{button_runtime_pack_expand}->GetId, \&on_button_runtime_pack_expand);
    Wx::Event::EVT_TEXT($self, $self->{combo_box_workspaces}->GetId, \&on_combo_box_workspaces_text);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_workspaces}->GetId, \&on_combo_box_workspaces);
    Wx::Event::EVT_BUTTON($self, $self->{button_workspace_open}->GetId, \&on_button_workspace_open);
    Wx::Event::EVT_BUTTON($self, $self->{button_recalls}->GetId, \&on_button_recall);
    Wx::Event::EVT_TREE_ITEM_ACTIVATED($self, $self->{tree_ctrl_workspace_projects}->GetId, \&on_tree_workspace_projects_activated);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_workspace_projects}->GetId, \&on_tree_workspace_projects_keydown);
    Wx::Event::EVT_BUTTON($self, $self->{button_workspace_projects_expand}->GetId, \&on_button_workspace_projects_expand);
    Wx::Event::EVT_BUTTON($self, $self->{button_versions}->GetId, \&on_button_versions);
    Wx::Event::EVT_TEXT($self, $self->{text_ctrl_working_project_target_version}->GetId, \&on_text_target_version);
    Wx::Event::EVT_CHECKBOX($self, $self->{checkbox_dynamic}->GetId, \&on_checkbox_dynamic);
    Wx::Event::EVT_CHECKBOX($self, $self->{checkbox_static}->GetId, \&on_checkbox_static);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_working_project_dynamic}->GetId, \&on_tree_working_project_dynamic_keydown);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_working_project_static}->GetId, \&on_tree_working_project_static_keydown);
    Wx::Event::EVT_BUTTON($self, $self->{button_working_project_expand}->GetId, \&on_button_working_project_expand);
    Wx::Event::EVT_BUTTON($self, $self->{button_layers}->GetId, \&on_button_layers);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_runtime}->GetId, \&on_tree_runtime_keydown);
    Wx::Event::EVT_TREE_KEY_DOWN($self, $self->{tree_ctrl_runtime_in_workspace}->GetId, \&tree_ctrl_runtime_in_workspace_keydown);
    Wx::Event::EVT_BUTTON($self, $self->{button_runtime_expand}->GetId, \&on_button_runtime_expand);
    Wx::Event::EVT_BUTTON($self, $self->{button_runtime_pack}->GetId, \&on_runtime_pack);
    Wx::Event::EVT_BUTTON($self, $self->{button_expand_all}->GetId, \&on_button_expand_all);
    Wx::Event::EVT_BUTTON($self, $self->{button_highlight}->GetId, \&on_button_highlight);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_arch}->GetId, \&on_combobox_arch);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_os}->GetId, \&on_combobox_os);
    Wx::Event::EVT_COMBOBOX($self, $self->{combo_box_toolchain}->GetId, \&on_combobox_toolchain);
    Wx::Event::EVT_CHECKBOX($self, $self->{checkbox_generate}->GetId, \&on_button_generate);
    Wx::Event::EVT_CHECKBOX($self, $self->{checkbox_freeze}->GetId, \&on_button_freeze);
    Wx::Event::EVT_CHECKBOX($self, $self->{checkbox_fix}->GetId, \&on_button_fix);
    Wx::Event::EVT_BUTTON($self, $self->{button_action}->GetId, \&on_button_action);
    Wx::Event::EVT_BUTTON($self, $self->{button_ide}->GetId, \&on_button_ide);

    # end wxGlade

    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_working_project_dynamic}->GetId, \&on_tree_ctrl_working_project_dynamic_menu);
    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_working_project_static}->GetId, \&on_tree_ctrl_working_project_static_menu);
    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_workspace_projects}->GetId, \&on_tree_ctrl_workspace_projects_menu);
    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_runtime}->GetId, \&on_tree_ctrl_runtime_menu);
    Wx::Event::EVT_TREE_ITEM_MENU($self, $self->{tree_ctrl_runtime_in_workspace}->GetId, \&on_tree_ctrl_runtime_in_workspace_menu);
    Wx::Event::EVT_MENU($self, DEPENDENCY_STATIC, \&on_dependency_static);
    Wx::Event::EVT_MENU($self, DEPENDENCY_DYNAMIC, \&on_dependency_dynamic);
    Wx::Event::EVT_MENU($self, DEPENDENCY_REMOVE, \&on_dependency_remove);
    Wx::Event::EVT_MENU($self, SHOW_DEPENDENCIES_ACCORDING_TO_TYPES, \&on_workspace_projects_menu_show_dependencies_according_to_types);
    Wx::Event::EVT_MENU($self, SET_AS_WORKING_PROJECT, \&on_workspace_projects_menu_set_as_working_project);
    Wx::Event::EVT_MENU($self, REMOVE_FROM_WORKSPACE, \&on_workspace_projects_menu_remove_from_workspace);
    Wx::Event::EVT_MENU($self, REMOVE_RUNTIME_FROM_WORKSPACE, \&on_runtime_projects_menu_remove_from_workspace);
    Wx::Event::EVT_MENU($self, REMOVE_RUNTIME_IN_WORKSPACE, \&on_runtime_in_workspace_menu_remove);
    Wx::Event::EVT_MENU($self, GENERATE_SELECTED_PROJECTS, \&on_workspace_projects_menu_generate_selected_projects);

    # Data members initialization.
    $self->{last_product_name} = "";
    $self->{last_workspace_id} = "";
    $self->{workspace_path} = "";
    $self->{workspace_projects} = [];
    $self->{working_project} = 0;
    $self->{runtime_in_workspace} = [];
    $self->{product_projects_paths} = [];
    $self->{loaded_projects} = [];
    $self->{product_runtime} = [];
    $self->{non_compliant_modules} = ();
    $self->{highlight_modules} = [];
    $self->{highlight_modules_cancel} = 0;
    $self->{runtime_products_to_select_in_tree} = {};
    $self->{mpbs_scanned} = [];
    $self->{recalls} = [];

    # Disable widgets until a product is opened.
    $self->disable_product_actions();

    # Fill the list of products with the more recently used products.
    $self->fill_mru_products();

    $self->create_list_ctrl_product_projects();

    $self->fill_arch_os_toolchain();


    $self->{text_ctrl_external_modules_plugin}->SetBackgroundColour(Wx::Colour->new(128, 255, 128));
    $self->{text_ctrl_external_modules_executable}->SetBackgroundColour(Wx::Colour->new(128, 255, 255));
    $self->{text_ctrl_external_modules_undeterminable}->SetBackgroundColour(Wx::Colour->new(255, 176, 98));

    # Activate drag & drop
    $self->SetDropTarget(DPOPanelProductDropTarget->new($self));

    # Give the focus to $self->{combo_box_product} to get the first element in
    # the list with up/down keys or by rolling the mouse.
    $self->{combo_box_product}->SetFocus();

    $self->{button_ide}->Enable(0);

    return $self;
}


sub __set_properties {
    my $self = shift;
    # begin wxGlade: DPOPanelProduct::__set_properties
    $self->{combo_box_product}->SetMinSize(Wx::Size->new(130, 21));
    $self->{combo_box_product}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    $self->{combo_box_product}->SetSelection(-1);
    $self->{button_product_browse}->SetMinSize(Wx::Size->new(20, -1));
    $self->{button_product_open}->SetMinSize(Wx::Size->new(45, -1));
    $self->{button_local_env_var}->Show(0);
    $self->{combo_box_available_projects_dependants_of}->SetSelection(-1);
    $self->{button_available_projects_dependants_of}->SetMinSize(Wx::Size->new(30, -1));
    $self->{list_ctrl_product_projects}->SetMinSize(Wx::Size->new(100,256));
    $self->{text_ctrl_project_count}->SetMinSize(Wx::Size->new(50, -1));
    $self->{button_project_new}->SetMinSize(Wx::Size->new(-1, -1));
    $self->{text_ctrl_external_modules_plugin}->SetMinSize(Wx::Size->new(60, -1));
    $self->{text_ctrl_external_modules_executable}->SetMinSize(Wx::Size->new(60, -1));
    $self->{text_ctrl_external_modules_undeterminable}->SetMinSize(Wx::Size->new(60, -1));
    $self->{button_runtime_pack_expand}->SetMinSize(Wx::Size->new(20, -1));
    $self->{notebook_modules}->SetMinSize(Wx::Size->new(250, 390));
    $self->{combo_box_workspaces}->SetMinSize(Wx::Size->new(130, 21));
    $self->{combo_box_workspaces}->SetSelection(-1);
    $self->{button_workspace_open}->SetMinSize(Wx::Size->new(50, -1));
    $self->{button_recalls}->SetMinSize(Wx::Size->new(20, -1));
    $self->{button_recalls}->SetToolTipString(_T("There is something to do..."));
    $self->{tree_ctrl_workspace_projects}->SetMinSize(Wx::Size->new(200, -1));
    $self->{button_workspace_projects_expand}->SetMinSize(Wx::Size->new(20, 20));
    $self->{button_versions}->SetMinSize(Wx::Size->new(60, 20));
    $self->{text_ctrl_working_project_current_version}->SetMinSize(Wx::Size->new(80, -1));
    $self->{text_ctrl_working_project_target_version}->SetMinSize(Wx::Size->new(80, -1));
    $self->{text_ctrl_working_project_target_version}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    $self->{tree_ctrl_working_project_dynamic}->SetMinSize(Wx::Size->new(200, -1));
    $self->{tree_ctrl_working_project_static}->SetMinSize(Wx::Size->new(200, -1));
    $self->{button_working_project_expand}->SetMinSize(Wx::Size->new(20, 20));
    $self->{button_layers}->SetMinSize(Wx::Size->new(60, 20));
    $self->{tree_ctrl_runtime}->SetMinSize(Wx::Size->new(138, -1));
    $self->{button_runtime_expand}->SetMinSize(Wx::Size->new(20, -1));
    $self->{button_runtime_pack}->SetMinSize(Wx::Size->new(40, -1));
    $self->{button_expand_all}->SetMinSize(Wx::Size->new(75, 23));
    $self->{button_highlight}->SetMinSize(Wx::Size->new(75, 23));
    $self->{combo_box_arch}->SetMinSize(Wx::Size->new(70, 21));
    $self->{combo_box_arch}->SetSelection(-1);
    $self->{combo_box_os}->SetMinSize(Wx::Size->new(70, 21));
    $self->{combo_box_os}->SetSelection(-1);
    $self->{combo_box_toolchain}->SetMinSize(Wx::Size->new(70, 21));
    $self->{combo_box_toolchain}->SetSelection(-1);
    $self->{checkbox_validate}->SetToolTipString(_T("Validates projects/workspace definitions and relations"));
    $self->{checkbox_set_env_vars}->SetToolTipString(_T("Sets all workspace's projects environment variables."));
    $self->{checkbox_fetch_runtime}->SetToolTipString(_T("Copies non workspace modules into the workspace run directory."));
    $self->{checkbox_generate}->SetToolTipString(_T("Generates projects (.sln, vcxproj, makefiles)"));
    $self->{checkbox_freeze}->SetToolTipString(_T("Pushes projects stuff into the related pool."));
    $self->{button_action}->SetMinSize(Wx::Size->new(50, -1));
    # end wxGlade
}

sub __do_layout {
    my $self = shift;
    # begin wxGlade: DPOPanelProduct::__do_layout
    $self->{sizer_top} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_actions} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_generation_parent_staticbox}->Lower();
    $self->{sizer_generation_parent} = Wx::StaticBoxSizer->new($self->{sizer_generation_parent_staticbox}, wxVERTICAL);
    $self->{sizer_generation} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_ide_staticbox}->Lower();
    $self->{sizer_ide} = Wx::StaticBoxSizer->new($self->{sizer_ide_staticbox}, wxHORIZONTAL);
    $self->{sizer_59_staticbox}->Lower();
    $self->{sizer_59} = Wx::StaticBoxSizer->new($self->{sizer_59_staticbox}, wxHORIZONTAL);
    $self->{sizer_57_staticbox}->Lower();
    $self->{sizer_57} = Wx::StaticBoxSizer->new($self->{sizer_57_staticbox}, wxHORIZONTAL);
    $self->{sizer_54_staticbox}->Lower();
    $self->{sizer_54} = Wx::StaticBoxSizer->new($self->{sizer_54_staticbox}, wxHORIZONTAL);
    $self->{sizer_53_staticbox}->Lower();
    $self->{sizer_53} = Wx::StaticBoxSizer->new($self->{sizer_53_staticbox}, wxHORIZONTAL);
    $self->{sizer_74_staticbox}->Lower();
    $self->{sizer_74} = Wx::StaticBoxSizer->new($self->{sizer_74_staticbox}, wxVERTICAL);
    $self->{sizer_75} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_main} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_product_staticbox}->Lower();
    $self->{sizer_product} = Wx::StaticBoxSizer->new($self->{sizer_product_staticbox}, wxVERTICAL);
    $self->{sizer_runtime} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_45} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_93} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_94} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_73} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_workspace_projects} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_18} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_working_project_staticbox}->Lower();
    $self->{sizer_working_project} = Wx::StaticBoxSizer->new($self->{sizer_working_project_staticbox}, wxVERTICAL);
    $self->{sizer_working_project_dependencies} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_44} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_working_project_types} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_working_project_type_static_staticbox}->Lower();
    $self->{sizer_working_project_type_static} = Wx::StaticBoxSizer->new($self->{sizer_working_project_type_static_staticbox}, wxVERTICAL);
    $self->{sizer_working_project_type_dynamic_staticbox}->Lower();
    $self->{sizer_working_project_type_dynamic} = Wx::StaticBoxSizer->new($self->{sizer_working_project_type_dynamic_staticbox}, wxVERTICAL);
    $self->{sizer_project_types} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_type_staticbox}->Lower();
    $self->{sizer_type} = Wx::StaticBoxSizer->new($self->{sizer_type_staticbox}, wxHORIZONTAL);
    $self->{sizer_72_staticbox}->Lower();
    $self->{sizer_72} = Wx::StaticBoxSizer->new($self->{sizer_72_staticbox}, wxHORIZONTAL);
    $self->{sizer_71_staticbox}->Lower();
    $self->{sizer_71} = Wx::StaticBoxSizer->new($self->{sizer_71_staticbox}, wxHORIZONTAL);
    $self->{sizer_20} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_31} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_14} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_workspace} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_modules_to_import_staticbox}->Lower();
    $self->{sizer_modules_to_import} = Wx::StaticBoxSizer->new($self->{sizer_modules_to_import_staticbox}, wxVERTICAL);
    $self->{sizer_28} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_67} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_66} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_15} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_product_projects} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_147} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_13} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_11} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_5} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_8} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_9} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_10} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_95} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_95}->Add($self->{label_product}, 0, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_95}->Add($self->{combo_box_product}, 0, 0, 0);
    $self->{sizer_95}->Add($self->{button_product_browse}, 0, wxLEFT, 3);
    $self->{sizer_95}->Add($self->{button_product_open}, 0, wxLEFT, 6);
    $self->{sizer_95}->Add($self->{button_local_env_var}, 0, wxLEFT, 15);
    $self->{sizer_product_projects}->Add($self->{sizer_95}, 0, wxALL, 5);
    $self->{sizer_10}->Add($self->{radio_btn_available_projects_all}, 0, 0, 0);
    $self->{sizer_product_projects}->Add($self->{sizer_10}, 0, wxALL|wxEXPAND, 3);
    $self->{sizer_9}->Add($self->{radio_btn_available_projects_dependants_of}, 0, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_9}->Add($self->{combo_box_available_projects_dependants_of}, 1, wxLEFT|wxEXPAND, 3);
    $self->{sizer_9}->Add($self->{button_available_projects_dependants_of}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 5);
    $self->{sizer_8}->Add($self->{sizer_9}, 0, wxEXPAND, 3);
    $self->{sizer_5}->Add($self->{sizer_8}, 1, wxEXPAND, 0);
    $self->{sizer_product_projects}->Add($self->{sizer_5}, 0, wxALL|wxEXPAND, 3);
    $self->{sizer_11}->Add($self->{button_available_projects_get}, 0, 0, 0);
    $self->{sizer_product_projects}->Add($self->{sizer_11}, 0, wxALL, 3);
    $self->{sizer_13}->Add($self->{list_ctrl_product_projects}, 1, wxEXPAND, 0);
    $self->{sizer_product_projects}->Add($self->{sizer_13}, 1, wxALL|wxEXPAND, 3);
    $self->{sizer_147}->Add($self->{label_project_count}, 0, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_147}->Add($self->{text_ctrl_project_count}, 0, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_147}->Add($self->{button_project_new}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 3);
    $self->{sizer_product_projects}->Add($self->{sizer_147}, 0, wxLEFT|wxRIGHT|wxEXPAND, 3);
    $self->{notebook_modules_pane_product}->SetSizer($self->{sizer_product_projects});
    $self->{sizer_66}->Add($self->{tree_ctrl_external_modules}, 1, wxEXPAND, 0);
    $self->{sizer_15}->Add($self->{text_ctrl_external_modules_plugin}, 0, 0, 0);
    $self->{sizer_15}->Add($self->{text_ctrl_external_modules_executable}, 0, wxLEFT, 5);
    $self->{sizer_15}->Add($self->{text_ctrl_external_modules_undeterminable}, 0, wxLEFT, 5);
    $self->{sizer_66}->Add($self->{sizer_15}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{notebook_runtime_pack_pane}->SetSizer($self->{sizer_66});
    $self->{sizer_67}->Add($self->{tree_ctrl_runtime_pack}, 1, wxEXPAND, 0);
    $self->{sizer_67}->Add($self->{button_runtime_pack_expand}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 3);
    $self->{notebook_external_pane_2}->SetSizer($self->{sizer_67});
    $self->{notebook_external}->AddPage($self->{notebook_runtime_pack_pane}, _T("Modules"));
    $self->{notebook_external}->AddPage($self->{notebook_external_pane_2}, _T("Runtime pack"));
    $self->{sizer_28}->Add($self->{notebook_external}, 1, wxEXPAND, 0);
    $self->{notebook_modules_pane_external}->SetSizer($self->{sizer_28});
    $self->{notebook_modules}->AddPage($self->{notebook_modules_pane_product}, _T("Product"));
    $self->{notebook_modules}->AddPage($self->{notebook_modules_pane_external}, _T("External"));
    $self->{sizer_modules_to_import}->Add($self->{notebook_modules}, 1, wxEXPAND, 0);
    $self->{sizer_main}->Add($self->{sizer_modules_to_import}, 1, wxALL|wxEXPAND, 3);
    $self->{sizer_workspace}->Add($self->{combo_box_workspaces}, 0, wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_workspace}->Add($self->{button_workspace_open}, 0, wxLEFT, 5);
    $self->{sizer_workspace}->Add($self->{button_recalls}, 0, wxLEFT, 3);
    $self->{sizer_20}->Add($self->{sizer_workspace}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 3);
    $self->{sizer_14}->Add($self->{tree_ctrl_workspace_projects}, 1, wxEXPAND, 0);
    $self->{sizer_20}->Add($self->{sizer_14}, 1, wxEXPAND, 0);
    $self->{sizer_31}->Add($self->{button_workspace_projects_expand}, 0, 0, 0);
    $self->{sizer_31}->Add($self->{button_versions}, 0, wxLEFT, 3);
    $self->{sizer_20}->Add($self->{sizer_31}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    $self->{sizer_18}->Add($self->{sizer_20}, 3, wxEXPAND, 0);
    $self->{sizer_71}->Add($self->{text_ctrl_working_project_current_version}, 0, 0, 0);
    $self->{sizer_project_types}->Add($self->{sizer_71}, 0, wxEXPAND, 0);
    $self->{sizer_72}->Add($self->{text_ctrl_working_project_target_version}, 0, 0, 0);
    $self->{sizer_project_types}->Add($self->{sizer_72}, 0, wxLEFT|wxEXPAND, 3);
    $self->{sizer_type}->Add($self->{checkbox_dynamic}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_type}->Add($self->{checkbox_static}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_project_types}->Add($self->{sizer_type}, 0, wxLEFT|wxEXPAND, 10);
    $self->{sizer_working_project}->Add($self->{sizer_project_types}, 0, wxEXPAND, 0);
    $self->{sizer_working_project_type_dynamic}->Add($self->{tree_ctrl_working_project_dynamic}, 1, wxEXPAND, 0);
    $self->{sizer_working_project_types}->Add($self->{sizer_working_project_type_dynamic}, 1, wxEXPAND, 0);
    $self->{sizer_working_project_type_static}->Add($self->{tree_ctrl_working_project_static}, 1, wxEXPAND, 0);
    $self->{sizer_working_project_types}->Add($self->{sizer_working_project_type_static}, 1, wxEXPAND, 0);
    $self->{sizer_working_project_dependencies}->Add($self->{sizer_working_project_types}, 1, wxEXPAND, 0);
    $self->{sizer_44}->Add($self->{button_working_project_expand}, 0, 0, 0);
    $self->{sizer_44}->Add($self->{button_layers}, 0, wxLEFT, 3);
    $self->{sizer_working_project_dependencies}->Add($self->{sizer_44}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 3);
    $self->{sizer_working_project}->Add($self->{sizer_working_project_dependencies}, 3, wxEXPAND, 0);
    $self->{sizer_18}->Add($self->{sizer_working_project}, 5, wxALL|wxEXPAND, 3);
    $self->{sizer_workspace_projects}->Add($self->{sizer_18}, 1, wxEXPAND, 0);
    $self->{notebook_workspace_runtime_pane_workspace}->SetSizer($self->{sizer_workspace_projects});
    $self->{sizer_73}->Add($self->{tree_ctrl_runtime}, 1, wxEXPAND, 0);
    $self->{notebook_8_pane_runtime_modules}->SetSizer($self->{sizer_73});
    $self->{sizer_94}->Add($self->{tree_ctrl_runtime_in_workspace}, 1, wxEXPAND, 0);
    $self->{notebook_8_pane_2}->SetSizer($self->{sizer_94});
    $self->{sizer_93}->Add($self->{label_2}, 0, 0, 0);
    $self->{notebook_runtime_pane_1}->SetSizer($self->{sizer_93});
    $self->{notebook_runtime}->AddPage($self->{notebook_8_pane_runtime_modules}, _T("External"));
    $self->{notebook_runtime}->AddPage($self->{notebook_8_pane_2}, _T("Workspace runtime modules"));
    $self->{notebook_runtime}->AddPage($self->{notebook_runtime_pane_1}, _T("etc/var"));
    $self->{sizer_runtime}->Add($self->{notebook_runtime}, 1, wxEXPAND, 0);
    $self->{sizer_45}->Add($self->{button_runtime_expand}, 0, 0, 0);
    $self->{sizer_45}->Add($self->{button_runtime_pack}, 0, wxLEFT, 5);
    $self->{sizer_runtime}->Add($self->{sizer_45}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 3);
    $self->{notebook_workspace_runtime_pane_runtime}->SetSizer($self->{sizer_runtime});
    $self->{notebook_workspace_runtime}->AddPage($self->{notebook_workspace_runtime_pane_workspace}, _T("Workspace"));
    $self->{notebook_workspace_runtime}->AddPage($self->{notebook_workspace_runtime_pane_runtime}, _T("Runtime"));
    $self->{sizer_product}->Add($self->{notebook_workspace_runtime}, 1, wxEXPAND, 0);
    $self->{sizer_main}->Add($self->{sizer_product}, 2, wxALL|wxEXPAND, 3);
    $self->{sizer_top}->Add($self->{sizer_main}, 1, wxALL|wxEXPAND, 5);
    $self->{sizer_75}->Add($self->{button_expand_all}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_75}->Add($self->{button_highlight}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_74}->Add($self->{sizer_75}, 1, wxTOP|wxEXPAND, 7);
    $self->{sizer_actions}->Add($self->{sizer_74}, 0, wxEXPAND|wxALIGN_CENTER_VERTICAL, 0);
    $self->{sizer_53}->Add($self->{combo_box_arch}, 0, 0, 0);
    $self->{sizer_generation}->Add($self->{sizer_53}, 0, wxEXPAND, 0);
    $self->{sizer_54}->Add($self->{combo_box_os}, 0, 0, 0);
    $self->{sizer_generation}->Add($self->{sizer_54}, 0, wxLEFT|wxEXPAND, 5);
    $self->{sizer_57}->Add($self->{combo_box_toolchain}, 0, 0, 0);
    $self->{sizer_generation}->Add($self->{sizer_57}, 0, wxLEFT|wxEXPAND, 5);
    $self->{sizer_59}->Add($self->{checkbox_validate}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_59}->Add($self->{checkbox_set_env_vars}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_59}->Add($self->{checkbox_fetch_runtime}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_59}->Add($self->{checkbox_generate}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_59}->Add($self->{checkbox_freeze}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_59}->Add($self->{checkbox_fix}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_59}->Add($self->{checkbox_cleanup}, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 3);
    $self->{sizer_59}->Add($self->{button_action}, 0, wxLEFT, 5);
    $self->{sizer_generation}->Add($self->{sizer_59}, 0, wxLEFT|wxEXPAND, 5);
    $self->{sizer_ide}->Add($self->{button_ide}, 0, 0, 0);
    $self->{sizer_generation}->Add($self->{sizer_ide}, 1, wxEXPAND, 0);
    $self->{sizer_generation_parent}->Add($self->{sizer_generation}, 1, wxEXPAND, 0);
    $self->{sizer_actions}->Add($self->{sizer_generation_parent}, 1, wxLEFT|wxEXPAND, 10);
    $self->{sizer_top}->Add($self->{sizer_actions}, 0, wxALL|wxALIGN_CENTER_HORIZONTAL, 5);
    $self->SetSizer($self->{sizer_top});
    $self->{sizer_top}->Fit($self);
    # end wxGlade
}

sub fill_mru_products
{
    my ($self) = @_;

    # The mru file (mru_products) is located in the directory defined by
    # DPO_CORE_ROOT env. var..
    my $env_var_id =  "\$(DPO_CORE_ROOT)";
    my $mru = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$mru))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$env_var_id]);
        return;
    }

    $mru .= "/scripts/mru_products";

    if (-e $mru)
    {
        my @lines;
        if (DPOUtils::get_file_lines($mru, \@lines))
        {
            $self->{combo_box_product}->Clear();

            foreach my $line (sort @lines)
            {
                chomp $line;
                if (!($line =~ /^$/))
                {
                    my ($product_id, $path) = $line =~ /(.*)\t(.*)/;

                    if ($product_id ne ""
                        && $path ne "")
                    {
                        if (-d "$path/$product_id")
                        {
                            # Show existing product only
                            $self->{combo_box_product}->Append($product_id);
                        }
                    }
                }
            }
        }
        else
        {
            # Should never land here because check on existance of $mru
            # has been done
            DPOLog::report_msg(DPOEvents::GET_LINES_FROM_FILE_FAILURE, [$mru]);
            return;
        }
    }
    else
    {
        # The file doesn't exist. That means that no products have been opened
        # yet.
    }
}

sub create_list_ctrl_product_projects
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("Project");
    $col->SetWidth(220);
    $self->{list_ctrl_product_projects}->InsertColumn(0, $col);

    $col = Wx::ListItem->new();
    $col->SetId(1);
    $col->SetText("Version");
    $col->SetWidth(60);
    $self->{list_ctrl_product_projects}->InsertColumn(1, $col);

    $col = Wx::ListItem->new();
    $col->SetId(2);
    $col->SetText("Target version");
    $col->SetWidth(80);
    $self->{list_ctrl_product_projects}->InsertColumn(2, $col);
}

sub fill_arch_os_toolchain
{
    my ($self) = @_;

    # Architectures
    my @architectures=();
    DPOUtils->available_architectures(\@architectures);
    foreach my $arch (@architectures)
    {
        $self->{combo_box_arch}->Append($arch);
    }

    # OSes
    my @oses=();
    DPOUtils->available_os(\@oses);
    foreach my $os (@oses)
    {
        $self->{combo_box_os}->Append($os);
    }

    # Toolchains
    my @tool_chains=();
    DPOUtils->available_tool_chains(\@tool_chains);
    foreach my $tool (@tool_chains)
    {
        $self->{combo_box_toolchain}->Append($tool);
    }

    #~ if (scalar(@tool_chains) == 1)
    #~ {
        #~ $self->{combo_box_toolchain}->SetValue($tool_chains[0]);
        #~ $self->{this_module}->{tool_chain} = $tool_chains[0];
    #~ }
}

sub disable_product_actions
{
    my ($self) = @_;

    $self->enable_actions_elements(0);
    $self->enable_working_project_elements(0);
    $self->enable_workspace_elements(0);
    $self->enable_workspace_actions(0);
    $self->enable_runtime_elements(0);
    $self->enable_product_elements(0);
}

sub enable_product_elements
{
    my ($self, $enable) = @_;

    $self->{radio_btn_available_projects_all}->Enable($enable);
    $self->{radio_btn_available_projects_dependants_of}->Enable($enable);
    $self->{combo_box_available_projects_dependants_of}->Enable($enable);
    $self->{button_available_projects_dependants_of}->Enable($enable);
    $self->{button_available_projects_get}->Enable($enable);
    $self->{list_ctrl_product_projects}->Enable($enable);
    $self->{button_project_new}->Enable($enable);
    $self->{notebook_external}->Enable($enable);

    if ($enable)
    {
        # No need to point out that a product has to be opened.
        $self->{combo_box_product}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
        $self->{combo_box_product}->Refresh();
        $self->{button_product_open}->SetBackgroundColour(Wx::SystemSettings::GetColour(wxSYS_COLOUR_BTNFACE));
    }
    else
    {
        # Point out that a product has to be opened.
        $self->{combo_box_product}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
        $self->{combo_box_product}->Refresh();
        $self->{button_product_open}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    }

    $self->enable_workspace_actions($enable);
    $self->enable_workspace_elements($enable);
    $self->enable_runtime_elements($enable);
}

sub enable_workspace_actions
{
    my ($self, $enable) = @_;

    my $color = 1;  # To set color of combo_box and button (indicating that a
                    # workspace has to be opened or not).

    # Enable/disable combo_box and button.
    if ($enable)
    {
        $self->{combo_box_workspaces}->Enable(1);
        $self->{button_workspace_open}->Enable(1);
    }
    else
    {
        if ($self->{last_product_name} eq "")
        {
            $self->{combo_box_workspaces}->Enable(0);
            $self->{button_workspace_open}->Enable(0);
            $color = 0;
        }
    }

    # Determine if we have to color.

    # According to product...
    if ($self->{last_product_name} eq "")
    {
        # No product is opened. We don't need to color (everything is disabled).
        $color = 0;
    }
    else
    {
        if ($self->{last_product_name} ne $self->{this_product}->{name})
        {
            # The selected product doesn't match with the opened one. Don't need
            # to color because we disable the opened product.
            $color = 0;
        }
    }

    # According to workspace...
    my $new_workspace_name = $self->{combo_box_workspaces}->GetValue();

    if ($self->{last_workspace_id} ne "")
    {
        # A workspace has been opened.

        if ($self->{last_workspace_id} eq $new_workspace_name)
        {
            # The opened workspace is the selected one. Don't need to ask to
            # open.
            $color = 0;
        }
    }

    # Set color of combo_box and button (indicating that a
    # workspace has to be opened or not).
    if ($color)
    {
        # Point out that a workspace has to be opened.
        $self->{button_workspace_open}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
        $self->{combo_box_workspaces}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
        $self->{combo_box_workspaces}->Refresh();
    }
    else
    {
        # No need to point out that a product has to be opened.
        $self->{button_workspace_open}->SetBackgroundColour(Wx::SystemSettings::GetColour(wxSYS_COLOUR_BTNFACE));
        $self->{combo_box_workspaces}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
        $self->{combo_box_workspaces}->Refresh();
    }
}

sub enable_workspace_elements
{
    my ($self, $enable) = @_;

    if (defined($self->{workspace_name})
        && $self->{workspace_name} ne "")
    {
        if ($self->{combo_box_workspaces}->GetValue() ne $self->{workspace_name})
        {
            $enable = 0;
        }

        # Enable or disable only when a workspace has been opened.
        $self->{tree_ctrl_workspace_projects}->Enable($enable);
        $self->{button_workspace_projects_expand}->Enable($enable);
        $self->{button_versions}->Enable($enable);

        $self->enable_working_project_elements($enable);
        $self->enable_actions_elements($enable);
    }
}

sub enable_working_project_elements
{
    my ($self, $enable) = @_;

    if ($self->{working_project} != 0
        || !$enable)
    {
        # Enable or disable only when a working project has been opened.
        # When disabling, a working project doesn't need to be opened.
        $self->{text_ctrl_working_project_current_version}->Enable($enable);
        $self->{text_ctrl_working_project_target_version}->Enable($enable);
        $self->{button_working_project_expand}->Enable($enable);
        $self->{button_layers}->Enable($enable);
        $self->{checkbox_dynamic}->Enable($enable);
        $self->{checkbox_static}->Enable($enable);
        $self->{tree_ctrl_working_project_dynamic}->Enable($enable);
        $self->{tree_ctrl_working_project_static}->Enable($enable);
    }
}

sub enable_runtime_elements
{
    my ($self, $enable) = @_;

    $self->{notebook_runtime}->Enable($enable);
    $self->{button_runtime_expand}->Enable($enable);
    $self->{button_runtime_pack}->Enable($enable);
}

sub enable_actions_elements
{
    my ($self, $enable) = @_;

    $self->{button_expand_all}->Enable($enable);
    $self->{button_highlight}->Enable($enable);
    $self->{combo_box_arch}->Enable($enable);
    $self->{combo_box_os}->Enable($enable);
    $self->{combo_box_toolchain}->Enable($enable);
    $self->{checkbox_generate}->Enable($enable);
    $self->{checkbox_validate}->Enable($enable);
    $self->{checkbox_fetch_runtime}->Enable($enable);
    $self->{checkbox_set_env_vars}->Enable($enable);
    $self->{checkbox_freeze}->Enable($enable);
    $self->{checkbox_fix}->Enable($enable);
    $self->{checkbox_cleanup}->Enable($enable);
    $self->{button_action}->Enable($enable);

    if ($self->{combo_box_toolchain}->GetValue() eq "")
    {
        $self->{combo_box_toolchain}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
    }
    else
    {
        $self->{combo_box_toolchain}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));
    }
}

sub append_product_to_mru
{
    my ($self, $product_id, $path) = @_;

    # The mru file (mru_products) is located in the directory defined by
    # DPO_CORE_ROOT env. var..
    my $env_var_id =  "\$(DPO_CORE_ROOT)";
    my $mru = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$mru))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$mru]);
        return 0;
    }

    $mru .= "/scripts/mru_products";

    my @existing;
    if (-e $mru)
    {
        my @lines;
        if (!DPOUtils::get_file_lines($mru, \@lines))
        {
            # Should never land here because check on existance of $mru
            # has been done
            DPOLog::report_msg(DPOEvents::GET_LINES_FROM_FILE_FAILURE, [$mru]);
            return 0;
        }

        foreach my $line (@lines)
        {
            chomp $line;
            my ($product_id, $path) = $line =~ /(.*)\t(.*)/;
            push(@existing, $product_id);
        }
    }

    if (!List::MoreUtils::any {$_ eq $product_id} @existing)
    {
        my $bPrintToFile = 1;  #  1: to file,  0: to console

        my $fh;
        if ($bPrintToFile)
        {
            $fh = new FileHandle();
            if (-e $mru)
            {
                if (!$fh->open(">>$mru"))
                {
                    DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, ["open (rw)", $mru, $!]);
                    return 0;
                }
            }
            else
            {
                if (!$fh->open(">$mru"))
                {
                    DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, ["open (ro)", $mru, $!]);
                    return 0;
                }
            }
        }
        else
        {
            $fh = *STDOUT;
        }

        print $fh "$product_id\t$path\n";
    }

    return 1;
}

sub open_product
{
    my ($self, $product_name) = @_;

    # Opening a product can be time consuming...
    my $wait = Wx::BusyCursor->new();

    my $env_var_id = uc($product_name) . "_ROOT";
    my $product_path = "\$($env_var_id)";
    if (DPOEnvVars::expand_env_var(\$product_path))
    {
        my $product;
        if (!DPOProductConfig::get_product_with_name($product_name, \$product))
        {
            Wx::MessageBox("Can't open product $product_name", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }

        $product->{path} = $product_path;

        $self->{this_product} = $product;

        if (!$self->load_projects_in_product($product_path))
        {
            Wx::MessageBox("Can't load projects of product $product_name", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }

        if (!$self->fill_product_projects())
        {
            return;
        }

        $self->{sizer_product_staticbox}->SetLabel("Product workspace/runtime (*** $product_name ***)");

        $self->close_workspace();

        $self->load_runtime();
        $self->fill_tree_runtime();

        # Get workspaces
        my $workspaces_path = "$product_path/workspaces";
        my @dir_content;
        if (DPOUtils::get_dir_content($workspaces_path, \@dir_content))
        {
            $self->{combo_box_workspaces}->Clear();
            foreach my $elem (@dir_content)
            {
                $self->{combo_box_workspaces}->Append($elem);
            }
        }
        else
        {
            Wx::MessageBox("Can't open project - can't get content of $workspaces_path.", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }

        $self->{last_workspace_id} = "";

        if ($self->{combo_box_workspaces}->GetCount() == 1)
        {
            my $lone_workspace = $self->{combo_box_workspaces}->GetString(0);
            $self->{combo_box_workspaces}->SetValue($lone_workspace);
            if (!$self->open_workspace())
            {
                Wx::MessageBox("Can't open project - can't open workspace $lone_workspace.", "", Wx::wxOK | Wx::wxICON_ERROR);
                return 0;
            }
        }

        if (!$self->fill_non_product_projects())
        {
            return 0;
        }

        print "Saving environment variables...\n";
        my @listEnvVarValues;
        my $product_env_var = DPOEnvVar->new(uc($self->{this_product}->{name}) . "_ROOT", $self->{this_product}->{path});

        push(@listEnvVarValues, $product_env_var);
        DPOEnvVars::system_set_env_vars(\@listEnvVarValues);

        $self->{last_product_name} = $self->{this_product}->{name};

        $self->enable_product_elements(1);
        $self->enable_runtime_elements(1);
        $self->enable_workspace_actions(1);

        $self->{combo_box_workspaces}->SetFocus();
    }
    else
    {
        Wx::MessageBox(
                    "Can't open product - $product_path doesn't exist.",
                    "",
                    Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    return 1;
}

sub load_projects_in_product
{
    my ($self, $product_path) = @_;

    $self->{product_projects_paths} = [];

    if (!DPOUtils::get_projects_paths("$product_path/projects", $self->{product_projects_paths}))
    {
        # TO_DO
        return 0;
    }

    my @listEnvVarValues; # missing env_var
    foreach my $x (sort @{$self->{product_projects_paths}})
    {
        $x =~ s/\\/\//g;

        my ($path, $project_name) = $x =~ /(.*)\/(.*)/;

        my $env_var_id = uc($project_name) . "_PRJ_ROOT";
        my $project_path = "\$($env_var_id)";
        if (!DPOEnvVars::expand_env_var(\$project_path))
        {
            my $path_dpo_env_var = DPOEnvVar->new($env_var_id, $x);
            push(@listEnvVarValues, $path_dpo_env_var);
        }
    }

    if (scalar(@listEnvVarValues) != 0)
    {
        my $rc = DPOEnvVars::system_set_env_vars(\@listEnvVarValues);
        if (!$rc)
        {
            Wx::MessageBox(
                    "Can't set environment variables.",
                    "",
                    Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }
    }

    foreach my $x (sort @{$self->{product_projects_paths}})
    {
        my ($project_name) = $x =~ /.*\/(.*)/;

        print DPOUtils::now_text(), "Loading $project_name...\n";

        my $project;
        if ($self->get_project($project_name, \$project))
        {
            if (!List::MoreUtils::any {$_->{name} eq $project->{name}} @{$self->{loaded_projects}})
            {
                push(@{$self->{loaded_projects}}, $project);
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_name]);
            return 0;
        }
    }

    return 1;
}

sub open_workspace
{
    my ($self) = @_;

    my $wait = Wx::BusyCursor->new();

    if (length($self->{combo_box_workspaces}->GetValue()) == 0)
    {
        # No workspaces, advise to select existing workspace or specify
        # new workspace name.
        Wx::MessageBox("No workspace selected.\n\n".
                        "Select one or specify new workspace name.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    # Open the workspace or create a new workspace (ask to create)
    my $workspace_name = $self->{combo_box_workspaces}->GetValue();

    if (!DPOUtils::valid_input($workspace_name))
    {
        Wx::MessageBox(
                "Invalid character in $workspace_name",
                "",
                Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    if ($workspace_name eq $self->{last_workspace_id})
    {
        my $rc = Wx::MessageBox(
                    "$workspace_name is already open.\n\n".
                    "Reopen?",
                    "",
                    Wx::wxYES_NO | Wx::wxICON_QUESTION);
        if ($rc == Wx::wxNO)
        {
            return 0;
        }
    }

    my $workspace_path = $self->{this_product}->{path} . "/workspaces/$workspace_name";

    unless (-d $workspace_path)
    {
        if (DPOUtils::make_path($workspace_path))
        {
            $self->{combo_box_workspaces}->Append($workspace_name);
        }
        else
        {
            Wx::MessageBox(
                    "Can't make path $workspace_path",
                    "",
                    Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }
    }

    $self->{workspace_path} = $workspace_path;
    $self->{workspace_name} = $workspace_name;
    $self->{workspace_projects} = [];
    $self->{runtime_in_workspace} = [];

    # Open workspace...
    my $workspace_projects_file = "$workspace_path/workspace_projects";
    if (-e $workspace_projects_file)
    {
        my @workspace_projects_names;

        my $save_now = 0;

        my @listEnvVarValues;
        my @lines;
        if (DPOUtils::get_file_lines($workspace_projects_file, \@lines))
        {
            my @list_of_paths;
            if (!DPOUtils::get_projects_paths("$self->{this_product}->{path}/projects", \@list_of_paths))
            {
                DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Can't get paths of projects"]);
                return 0;
            }

            foreach my $line (@lines)
            {
                chomp $line;

                if ($line ne "")
                {
                    my $project_name = $line;

                    push(@workspace_projects_names, $project_name);

                    foreach my $elem (@list_of_paths)
                    {
                        $elem =~ s/\\/\//g;

                        if ($elem =~ /(.*)\/$project_name$/)
                        {
                            my $env_var_id = uc($project_name) . "_PRJ_ROOT";
                            my $path_dpo_env_var = DPOEnvVar->new($env_var_id, $elem);
                            #~ print "New env. var. to define: $env_var_id --> $elem\n";
                            push(@listEnvVarValues, $path_dpo_env_var);
                            next;
                        }
                    }
                }
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::GET_LINES_FROM_FILE_FAILURE, [$workspace_projects_file]);
            return 0;
        }

        if (scalar(@listEnvVarValues) != 0)
        {
            my $rc = DPOEnvVars::system_set_env_vars(\@listEnvVarValues);
            if (!$rc)
            {
                Wx::MessageBox(
                        "Can't set environment variables.",
                        "",
                        Wx::wxOK | Wx::wxICON_ERROR);
                return 0;
            }
        }

        foreach my $project_name (@workspace_projects_names)
        {
            my $project;
            if (!$self->get_project($project_name, \$project))
            {
                my $rc = Wx::MessageBox(
                            "Can't open $project_name.\n\n".
                            "It will be removed from workspace.",
                            "", Wx::wxOK | Wx::wxICON_ERROR);
                {
                    $save_now = 1;
                }
            }
            else
            {
                push(@{$self->{workspace_projects}}, $project);
            }
        }

        if ($save_now)
        {
            if (!$self->save_workspace($self->{workspace_projects}))
            {
                Wx::MessageBox("Can't save workspace.", "", Wx::wxOK | Wx::wxICON_ERROR);
                return 0;
            }
        }
    }

    $self->fill_tree_workspace();

    # Load runtime projects that are in product but not in the workspace
    my $runtime_modules_file = "$workspace_path/runtime_modules";
    if (-e $runtime_modules_file)
    {
        my $save_now = 0;

        my @lines;
        if (DPOUtils::get_file_lines($runtime_modules_file, \@lines))
        {
            foreach my $line (@lines)
            {
                chomp $line;

                if ($line ne "")
                {
                    my $project_name = $line;

                    my $project;
                    if (!$self->get_project($project_name, \$project))
                    {
                        Wx::MessageBox("Can't open $project_name.", "", Wx::wxOK | Wx::wxICON_ERROR);
                        return 0;
                    }
                    else
                    {
                        push(@{$self->{runtime_in_workspace}}, $project);
                    }
                }
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::GET_LINES_FROM_FILE_FAILURE, [$runtime_modules_file]);
            return 0;
        }
    }

    $self->fill_tree_runtime_in_workspace();

    $self->{sizer_working_project}->GetStaticBox()->SetLabel("Working project (*** " . $self->{combo_box_workspaces}->GetValue() . " ***)");

    if (!$self->load_arch_os_toolchain())
    {
        Wx::MessageBox("Can't load 'arch/os/toolchain' from $self->{workspace_path}/arch_os_toolchain.",
                        "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    $self->validate();

    $self->set_available_product_projects_color();

    $self->{last_workspace_id} = $workspace_name;

    $self->enable_workspace_actions(1);
    $self->enable_workspace_elements(1);

    return 1;
}

sub close_workspace
{
    my ($self) = @_;

    $self->{combo_box_workspaces}->SetValue("");

    $self->{last_workspace_id} = "";
    $self->{workspace_path} = "";
    $self->{workspace_name} = "";
    $self->{workspace_projects} = [];
    if ($self->{last_product_name} ne $self->{combo_box_product}->GetValue())
    {
        # Clear only if we change product.
        $self->{combo_box_workspaces}->Clear();
    }

    $self->close_working_project();

    $self->fill_tree_workspace();
    #~ #$self->fill_tree_working();

    my $workspace_name = $self->{combo_box_workspaces}->GetValue();
    if ($workspace_name eq "")
    {
        $workspace_name = "no selection";
    }
    $self->{sizer_working_project}->GetStaticBox()->SetLabel("Workspace projects (*** " . $workspace_name . " ***)");

    $self->enable_actions_elements(0);
    $self->enable_working_project_elements(0);
    $self->enable_workspace_elements(0);
    $self->enable_workspace_actions(0);

    $self->set_available_product_projects_color();
}

sub reopen_workspace
{
    my ($self) = @_;

    my $workspace_name = $self->{workspace_name};
    $self->{last_workspace_id} = "";
    $self->{workspace_path} = "";

    $self->close_workspace();

    $self->{combo_box_workspaces}->SetValue($workspace_name);

    $self->open_workspace();
}

sub close_working_project
{
    my ($self) = @_;

    $self->{working_project} = 0;
    $self->{sizer_working_project_staticbox}->SetLabel("Working project (*** no selection ***)");
    $self->{text_ctrl_working_project_current_version}->ChangeValue("");
    $self->{text_ctrl_working_project_target_version}->ChangeValue("");
    $self->{checkbox_dynamic}->SetValue("");
    $self->{checkbox_static}->SetValue("");

    $self->{tree_ctrl_working_project_dynamic}->DeleteAllItems();
    $self->{tree_ctrl_working_project_static}->DeleteAllItems();

    $self->enable_working_project_elements(0);
}

sub fill_product_projects
{
    my ($self) = @_;

    my $wait = Wx::BusyCursor->new();

    my $other_project = "";
    if ($self->{radio_btn_available_projects_dependants_of}->GetValue())
    {
        $other_project = $self->{combo_box_available_projects_dependants_of}->GetValue();
        #~ if (!$other_project)
        #~ {
            #~ Wx::MessageBox(
                    #~ "Field not set: 'Dependants of'.\n",
                    #~ "Available projects",
                    #~ Wx::wxOK | Wx::wxICON_ERROR);
            #~ return 0;
        #~ }
    }

    my $other_project_name = "";
    my $other_project_version = "";
    if ($other_project ne "")
    {
        ($other_project_name, $other_project_version) = $other_project =~ /(.*)-(.*)/;
    }

    my $sub_path = "projects";
    if (DPOUtils::in_dpo_pool($self->{this_product}->{path}))
    {
        $sub_path = "../modules";
    }

    $self->{list_ctrl_product_projects}->DeleteAllItems();

    my $i = 0;
    # Sort by project_name
    foreach my $x (sort {$self->product_project_path($a) cmp $self->product_project_path($b)} @{$self->{product_projects_paths}})
    {
        my ($project_name) = $x =~ /.*\/(.*)/;

        my $go = 1;

        my $project;
        if ($self->get_project($project_name, \$project))
        {
            if ($self->{radio_btn_available_projects_dependants_of}->GetValue())
            {
                if (!$self->dependant_of($project, $other_project_name, $other_project_version))
                {
                    $go = 0;
                }
            }

            if ($go)
            {
                my $item = Wx::ListItem->new();

                $item->SetId($i);
                $item->SetText($project_name);
                $self->{list_ctrl_product_projects}->InsertItem( $item );
                $self->{list_ctrl_product_projects}->SetItem($i, 1, $project->{version});
                $self->{list_ctrl_product_projects}->SetItem($i, 2, $project->{target_version});

                $i++;
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_name]);
            return 0;
        }
    }

    $self->set_available_product_projects_color();

    $self->{text_ctrl_project_count}->SetValue($self->{list_ctrl_product_projects}->GetItemCount());

    return 1;
}


# This method is used to load DPO compliant projects. Non DPO compliant projects
# are loaded as dependencies (load_project_dependencies). Thus, we can't load
# non DPO compliant with this method.
sub get_project
{
    my ($self, $project_name, $project_ref) = @_;

    foreach my $loaded_project (@{$self->{loaded_projects}})
    {
        if ($loaded_project->{name} eq $project_name)
        {
            $$project_ref = $loaded_project;
            return 1;
        }
    }

    # Project not loaded yet

    # Is $project_name a new project in the product?
    my $path="";
    foreach my $p (@{$self->{product_projects_paths}})
    {
        $p =~ s/\\/\//g;
        my ($proj_name) = $p =~ /.*\/(.*)$/;
        if ($proj_name eq $project_name)
        {
            $path = $p;
            # Yes, it is a new project in the product.
            last;
        }
    }

    if ($path eq "")
    {
        # It's not a new project in this product.

        # DPO compliant project env. var. is defined as uc(<project_name>_PRJ_ROOT).
        # We can get it's path with env. var.

        # If uc(<project_name>_PRJ_ROOT) is not defined, either it's a dpo
        # compliant project for which the environment variable has not been set
        # yet or it's a non compliant project. In this case, there is a
        # problem with the logic of the program.

        my $env_var_id = uc($project_name) . "_PRJ_ROOT";
        $path = "\$($env_var_id)";
        if (!DPOEnvVars::expand_env_var(\$path))
        {
            DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$env_var_id]);
            return 0;
        }
    }

    my $file = "$path/DPOProject.xml";

    if (-e $file)
    {
        my $err;
        my $config = DPOProjectConfig->new($file, \$err);
        if ($config)
        {
            my $new_project;
            if ($config->get_project(\$new_project))
            {
                if (!$new_project->load_features())
                {
                    DPOLog::report_msg(DPOEvents::GET_FEATURES_FAILURE, [$project_name]);
                    return 0;
                }

                if (!$self->load_project_dependencies($new_project))
                {
                    DPOLog::report_msg(DPOEvents::LOAD_DYN_DEP_FAILURE, [$project_name]);
                    return 0;
                }

                push(@{$self->{loaded_projects}}, $new_project);

                $$project_ref = $new_project;
            }
            else
            {
                DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_name]);
                return 0;
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::LOAD_PROJECT_FAILURE, [$file, $err]);
            return 0;
        }
    }
    else
    {
        DPOLog::report_msg(DPOEvents::FILE_DOESNT_EXIST, [$file]);
        return 0;
    }

    return 1;
}

sub load_project_dependencies
{
    my ($self, $project) = @_;

    foreach my $dep (@{$project->{dependencies_when_dynamic}}, @{$project->{dependencies_when_static}})
    {
        if (!List::MoreUtils::any {$_->{name} eq $dep->{name}} @{$self->{loaded_projects}})
        {
            if ($dep->{dpo_compliant}->{value})
            {
                my $new_project;
                if (!$self->get_project($dep->{name}, \$new_project))
                {
                    DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$dep->{name}]);
                    return 0;
                }

                $new_project->{version} = $dep->{version};
                $new_project->{target_version} = $dep->{target_version};
            }
            else
            {
                # make $dep (DPOProjectDependency) a DPOProject
                my $new_project = DPOProject->new($dep->{name},
                                                    $dep->{version},
                                                    $dep->{target_version},
                                                    $dep->{type},
                                                    $dep->{dpo_compliant});

                # Load dependencies of the new project

                # Get product to allow load_non_compliant_dependencies getting libs types from product
                my $product;
                if (!DPOProductConfig::get_product_with_name($dep->{dpo_compliant}->{product_name}, \$product))
                {
                    DPOLog::report_msg(DPOEvents::CANT_GET_PRODUCT, [$dep->{dpo_compliant}->{product_name}]);
                    return 0;
                }

                my $dpo_mpb = DPOMpb->new($new_project->{name}, # lib_id
                                            $new_project->{dpo_compliant}->{mpb}, # mpb name
                                            $new_project->{dpo_compliant}->{mpc_includes});

                # Get dependencies of $new_project and put them into loaded_projects
                if (!$dpo_mpb->load_non_compliant_dependencies($product,
                                                            $new_project,
                                                            $self->{loaded_projects},
                                                            $self->{mpbs_scanned}))
                {
                    DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Can't get non compliant dependencies for $dep->{name}"]);
                    return 0;
                }

                if (!List::MoreUtils::any {$_->{name} eq $new_project->{name}} @{$self->{loaded_projects}})
                {
                    push(@{$self->{loaded_projects}}, $new_project);
                }
            }
        }
    }

    return 1;
}

sub dependant_of
{
    my ($self, $parent, $project_to_check_name, $project_to_check_version) = @_;

    my @deps;
    foreach my $dep (@{$parent->{dependencies_when_dynamic}})
    {
        if (!List::MoreUtils::any {$_->{name} eq $dep->{name} && $_->{version} eq $dep->{version}} @deps)
        {
            push(@deps, $dep);
        }
    }
    foreach my $dep (@{$parent->{dependencies_when_static}})
    {
        if (!List::MoreUtils::any {$_->{name} eq $dep->{name} && $_->{version} eq $dep->{version}} @deps)
        {
            push(@deps, $dep);
        }
    }

    # Is $project_to_check an immediate dependency of $parent?
    foreach my $dep (@deps)
    {
        if ($dep->{name} eq $project_to_check_name
            && $dep->{version} eq $project_to_check_version)
        {
            return 1;
        }
    }

    # Deep search
    foreach my $dep (@deps)
    {
        my $proj;
        $self->get_project($dep->{name}, \$proj);

        if ($self->dependant_of($proj, $project_to_check_name, $project_to_check_version))
        {
            return 1;
        }
    }

    return 0;
}

sub set_available_product_projects_color
{
    my ($self) = @_;

    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_product_projects}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        my $project_name = $self->{list_ctrl_product_projects}->GetItemText($i);

        if (List::MoreUtils::any {$_->{name} eq $project_name} @{$self->{workspace_projects}})
        {
            $self->{list_ctrl_product_projects}->SetItemBackgroundColour($i, Wx::Colour->new(192, 192, 192));
        }
        else
        {
            $self->{list_ctrl_product_projects}->SetItemState($i, 0, wxLIST_STATE_SELECTED);
            $self->{list_ctrl_product_projects}->SetItemBackgroundColour($i, Wx::Colour->new(255, 255, 255));
        }
    }
}

sub load_runtime
{
    my ($self) = @_;

    $self->{product_runtime} = [];

    foreach my $runtime_product_compliant (@{$self->{this_product}->{runtime}->{runtime_products_compliant}})
    {
        foreach my $project_dependency (@{$runtime_product_compliant->{dpo_project_dependencies}})
        {
            my $proj;
            if (!$self->get_project($project_dependency->{name}, \$proj))
            {
                DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_dependency->{name}]);
            }
            else
            {
                push(@{$self->{product_runtime}}, $proj->clone);
            }
        }
    }

    foreach my $runtime_product_non_compliant (@{$self->{this_product}->{runtime}->{runtime_products_non_compliant}})
    {
        my $dpo_compliant = DPOCompliant->new(0,
                                            $runtime_product_non_compliant->{name},
                                            $runtime_product_non_compliant->{flavour},
                                            "",
                                            "");

        my $proj = DPOProject->new($runtime_product_non_compliant->{name},
                                $runtime_product_non_compliant->{version},
                                $runtime_product_non_compliant->{version},
                                4,
                                $dpo_compliant); # type 4: runtime doesn't matter

        push(@{$self->{product_runtime}}, $proj);
    }
}

sub fill_tree_runtime
{
    my ($self) = @_;

    my $tree_ctrl = $self->{tree_ctrl_runtime};

    $tree_ctrl->DeleteAllItems();
    my $root = $tree_ctrl->AddRoot("");

    foreach my $runtime_product_compliant (@{$self->{this_product}->{runtime}->{runtime_products_compliant}})
    {
        my $flavour = "";
        if ($runtime_product_compliant->{flavour} ne "")
        {
            $flavour = "-$runtime_product_compliant->{flavour}";
        }
        #~ my $item = $tree_ctrl->AppendItem($root, "$runtime_product_compliant->{name}-$runtime_product_compliant->{version}$flavour");
        my $item = $tree_ctrl->AppendItem($root, "$runtime_product_compliant->{name}");

        foreach my $project_dependency (@{$runtime_product_compliant->{dpo_project_dependencies}})
        {
            my $project;
            if ($self->get_project($project_dependency->{name}, \$project))
            {
                my $sub_item = $tree_ctrl->AppendItem($item, "$project_dependency->{name}-$project_dependency->{version}");
                $self->fill_tree_dependencies($tree_ctrl, $sub_item, $project);
            }
            else
            {
                DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_dependency->{name}]);
            }
        }
    }

    foreach my $runtime_product_non_compliant (@{$self->{this_product}->{runtime}->{runtime_products_non_compliant}})
    {
        my $flavour = "";
        if ($runtime_product_non_compliant->{flavour} ne "")
        {
            $flavour = "-$runtime_product_non_compliant->{flavour}";
        }
        my $item = $tree_ctrl->AppendItem($root, "$runtime_product_non_compliant->{name}-$runtime_product_non_compliant->{version}$flavour");

        foreach my $module_name (@{$runtime_product_non_compliant->{modules_names}})
        {
            $tree_ctrl->AppendItem($item, $module_name);
        }
    }

    # Expand or not?
    my $button_ref;
    if ($tree_ctrl == $self->{tree_ctrl_workspace_projects})
    {
        $button_ref = \$self->{button_workspace_projects_expand};
    }

    if ($tree_ctrl == $self->{tree_ctrl_runtime})
    {
        $button_ref = \$self->{button_runtime_expand};
    }

    my ($child, $cookie) = $tree_ctrl->GetFirstChild($root);
    while ($child && $child->IsOk())
    {
        my $item_text = $tree_ctrl->GetItemText($child);

        if (List::MoreUtils::any {$_ eq $item_text} keys $self->{runtime_products_to_select_in_tree})
        {
            $tree_ctrl->Expand($child);

            my ($child2, $cookie2) = $tree_ctrl->GetFirstChild($child);
            while ($child2 && $child2->IsOk())
            {
                my $child2_text = $tree_ctrl->GetItemText($child2);

                if (List::MoreUtils::any {$_ eq $child2_text} @{$self->{runtime_products_to_select_in_tree}->{$item_text}})
                {
                    $tree_ctrl->SelectItem($child2);
                }

                ($child2, $cookie2) = $tree_ctrl->GetNextChild($child, $cookie2);
            }
        }

        ($child, $cookie) = $tree_ctrl->GetNextChild($root, $cookie);
    }

    if (defined($button_ref))
    {
        if ($$button_ref->GetLabel() eq "-")
        {
            $tree_ctrl->ExpandAll();
            my ($child, $cookie) = $tree_ctrl->GetFirstChild($root);
            $tree_ctrl->EnsureVisible($child);
        }
    }

    $self->{runtime_products_to_select_in_tree} = {};
}

sub fill_tree_dependencies
{
    my ($self, $tree_ctrl, $item_parent, $project) = @_;

    my @array;
    if ($project->{type} == 5)
    {
        @array = @{$project->{dependencies_when_static}};
    }
    else
    {
        if ($project->{type} == 6
            || $project->{type} == 0)
        {
            @array = @{$project->{dependencies_when_dynamic}};
        }
        else
        {
            if ($project->{type} == 7
                || $project->{type} == 1)
            {
                my %uniques;

                my %deps;
                foreach my $dep (@{$project->relevant_deps()})
                {
                    if (!defined($deps{$dep->{name}}))
                    {
                        $deps{$dep->{name}} = [];
                    }

                    push($deps{$dep->{name}}, $dep->{type});
                }

                foreach my $dep (@{$project->relevant_deps()})
                {
                    my $clone = $dep->clone;

                    my $type;
                    foreach my $t (@{$deps{$dep->{name}}})
                    {
                        $type |= $t;
                    }

                    $clone->{type} = $type;

                    if (!List::MoreUtils::any {$_->{name} eq $clone->{name}} @array)
                    {
                        push(@array, $clone);
                    }
                }
            }
        }
    }

    my @non_compliant_dep;
    foreach my $dependency (sort {$a->{name} cmp $b->{name}} @array)
    {
        my $proj;
        $self->get_project($dependency->{name}, \$proj);

        my $add = 1;

        my $type_text = "";

        if ($proj->{type} == 4)
        {
            $type_text = " (???)";
        }
        if ($proj->{type} == 5)
        {
            $type_text = " (static)";
        }
        if ($proj->{type} == 6)
        {
            $type_text = " (dynamic)";
        }
        if ($proj->{type} == 7)
        {
            $type_text = " (static/dynamic)";
        }

        if ($add)
        {
            my $item = $tree_ctrl->AppendItem($item_parent, "$proj->{name}-$proj->{target_version}$type_text");
            $self->fill_tree_dependencies($tree_ctrl, $item, $proj);
        }
    }
}

sub save_workspace
{
    my ($self, $workspace_projects_array_ref) = @_;

    my $file = "$self->{workspace_path}/workspace_projects";

    my $tmp_file = "workspace_projects.tmp";
    if (open (OUT, ">$tmp_file"))
    {
        foreach my $project (@{$workspace_projects_array_ref})
        {
            print OUT "$project->{name}\n";
        }

        close(OUT);

        if (!File::Copy::syscopy($tmp_file, $file))
        {
            DPOLog::report_msg(DPOEvents::FILE_COPY_FAILURE, [$tmp_file, $file, $!]);
        }

        unlink($tmp_file);
    }
    else
    {
        DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, ["Open", $tmp_file, $!]);
    }
}

sub fill_tree_workspace
{
    my ($self) = @_;

    my $tree_ctrl = $self->{tree_ctrl_workspace_projects};
    my $array = $self->{workspace_projects};

    $tree_ctrl->DeleteAllItems();
    my $root = $tree_ctrl->AddRoot("");

    foreach my $project (sort {$a->{name} cmp $b->{name}} @{$array})
    {
        my $type_text="";

        if ($tree_ctrl != $self->{tree_ctrl_runtime})
        {
            if ($project->{type} == 4)
            {
                $type_text = " (???)";
            }
            if ($project->{type} == 5)
            {
                $type_text = " (static)";
            }
            if ($project->{type} == 6)
            {
                $type_text = " (dynamic)";
            }
            if ($project->{type} == 7)
            {
                $type_text = " (static/dynamic)";
            }
        }

        my $item = $tree_ctrl->AppendItem($root, "$project->{name}-$project->{target_version}$type_text");
        if ($project->{type} == 4)
        {
            $tree_ctrl->SetItemBackgroundColour($item, $col_red);
            $tree_ctrl->SetItemTextColour($item, $col_white);
        }

        $self->fill_tree_dependencies($tree_ctrl, $item, $project);
    }

    # Expand or not?
    my $button_ref;
    if ($tree_ctrl == $self->{tree_ctrl_workspace_projects})
    {
        $button_ref = \$self->{button_workspace_projects_expand};
    }

    if ($tree_ctrl == $self->{tree_ctrl_runtime})
    {
        $button_ref = \$self->{button_runtime_expand};
    }

    if (defined($button_ref))
    {
        if ($$button_ref->GetLabel() eq "-")
        {
            $tree_ctrl->ExpandAllChildren($root);
            my ($child, $cookie) = $tree_ctrl->GetFirstChild($root);
            $tree_ctrl->EnsureVisible($child);
        }
    }
}

sub fill_tree_runtime_in_workspace
{
    my ($self) = @_;

    my $tree_ctrl = $self->{tree_ctrl_runtime_in_workspace};

    $tree_ctrl->DeleteAllItems();
    my $root = $tree_ctrl->AddRoot("");

    foreach my $project (@{$self->{runtime_in_workspace}})
    {
        my $item = $tree_ctrl->AppendItem($root, "$project->{name}-$project->{target_version}");
        $self->fill_tree_dependencies($tree_ctrl, $item, $project);
    }
}

sub load_arch_os_toolchain
{
    my ($self) = @_;

    my $file = "$self->{workspace_path}/arch_os_toolchain";

    my $arch;
    my $os;
    my $toolchain;

    if (-e $file)
    {
        my @lines;
        if (!DPOUtils::get_file_lines($file, \@lines))
        {
            DPOLog::report_msg(DPOEvents::GET_LINES_FROM_FILE_FAILURE, [$file]);
            return 0;
        }

        foreach my $line (@lines)
        {
            chomp $line;

            if ($line ne "")
            {
                if ($line =~ /arch=(.*)/)
                {
                    $arch = $1;
                }

                if ($line =~ /os=(.*)/)
                {
                    $os = $1;
                }

                if ($line =~ /toolchain=(.*)/)
                {
                    $toolchain = $1;
                }
            }
        }
    }
    else
    {
        if (open (OUT, ">$file"))
        {

            my $dpo_pool_root_path = DPOUtils::dpo_pool_dir();

            ($arch, $os) = $dpo_pool_root_path =~ /.*dpo_pool-(.*)-(.*)/;
            $toolchain = "";

            print OUT "arch=x86_64\n";
            print OUT "os=windows\n";
            print OUT "toolchain=\n";

            close(OUT);
        }
    }

    my $ok = 1;

    if (!defined($arch))
    {
        DPOLog::report_msg(DPOEvents::WRONG_ARCH_OS_TOOLCHAIN_FILE, [$file, "arch"]);
        $ok = 0;
    }

    if (!defined($os))
    {
        DPOLog::report_msg(DPOEvents::WRONG_ARCH_OS_TOOLCHAIN_FILE, [$file, "os"]);
        $ok = 0;
    }

    if (!defined($toolchain))
    {
        DPOLog::report_msg(DPOEvents::WRONG_ARCH_OS_TOOLCHAIN_FILE, [$file, "toolchain"]);
        $ok = 0;
    }

    if ($ok)
    {
        $self->{workspace_arch} = $arch;
        $self->{workspace_os} = $os;
        $self->{workspace_toolchain} = $toolchain;

        $self->{combo_box_arch}->SetValue($arch);
        $self->{combo_box_os}->SetValue($os);
        $self->{combo_box_toolchain}->SetValue($toolchain);
    }

    return $ok;
}

sub fill_non_product_projects
{
    my ($self) = @_;

    # External modules
    $self->{tree_ctrl_external_modules}->DeleteAllItems();
    my $root = $self->{tree_ctrl_external_modules}->AddRoot("");

    my @products;
    foreach my $x (sort keys(%ENV))
    {
        if ($x =~ /(.*)_ROOT$/)
        {
            my $product_name = $1;

            if (!defined($product_name)
                || $product_name eq "")
            {
                next;
            }

            if (uc($self->{this_product}->{name}) eq $product_name)
            {
                next;
            }

            my $product;
            if (DPOProductConfig::get_product_with_name($product_name, \$product, 1))
            {
                my $item_text = "$product->{name}-$product->{version}";

                if ($product->{flavour} ne "")
                {
                    $item_text .= "-$product->{flavour}";
                }
                my $item = $self->{tree_ctrl_external_modules}->AppendItem($root, $item_text);

                $self->{tree_ctrl_external_modules}->AppendItem($item, "");

                push(@products, $product);
            }
            else
            {
                # Don't report_msg (deliberately)
            }
        }
    }

    # Runtime packs
    $self->{tree_ctrl_runtime_pack}->DeleteAllItems();
    my $root2 = $self->{tree_ctrl_runtime_pack}->AddRoot("");

    foreach my $product (@products)
    {
        if (scalar(@{$product->{runtime}->{runtime_products_compliant}}) == 0
            && scalar(@{$product->{runtime}->{runtime_products_non_compliant}}) == 0)
        {
            next;
        }

        my $item_text = "$product->{name}-$product->{version}";
        if ($product->{flavour} ne "")
        {
            $item_text .= "-$product->{flavour}";
        }

        my $item_product = $self->{tree_ctrl_runtime_pack}->AppendItem($root2, $item_text);

        foreach my $product_compliant (@{$product->{runtime}->{runtime_products_compliant}})
        {
            my $item_text = "$product_compliant->{name}-$product_compliant->{version}";
            if ($product_compliant->{flavour} ne "")
            {
                $item_text .= "-$product_compliant->{flavour}";
            }
            my $item_runtime_product = $self->{tree_ctrl_runtime_pack}->AppendItem($item_product, $item_text);
            foreach my $project (@{$product_compliant->{dpo_project_dependencies}})
            {
                $self->{tree_ctrl_runtime_pack}->AppendItem($item_runtime_product, "$project->{name}-$project->{version}");
            }
        }

        foreach my $product_non_compliant (@{$product->{runtime}->{runtime_products_non_compliant}})
        {
            my $item_text = "$product_non_compliant->{name}-$product_non_compliant->{version}";
            if ($product_non_compliant->{flavour} ne "")
            {
                $item_text .= "-$product_non_compliant->{flavour}";
            }
            my $item_runtime_product = $self->{tree_ctrl_runtime_pack}->AppendItem($item_product, $item_text);
            foreach my $module_name (@{$product_non_compliant->{modules_names}})
            {
                $self->{tree_ctrl_runtime_pack}->AppendItem($item_runtime_product, $module_name);
            }
        }
    }

    return 1;
}

sub validate
{
    my ($self) = @_;

    my $actions = DPOActions->new(
                        DPOActions::ACTION_VALIDATE,
                        $self);

    my $rc = $actions->go();

    return $rc;
}

sub save_project
{
    my ($self, $project) = @_;

    my $path = "";
    foreach my $elem (@{$self->{product_projects_paths}})
    {
        my ($project_name) = $elem =~ /.*\/(.*)/;
        if ($project_name eq $project->{name})
        {
            $path = $elem;
            last;
        }
    }

    if ($path eq "")
    {
        if (!DPOUtils::get_project_path(
                        "$self->{this_product}->{path}/projects",
                        $project->{name},
                        \$path))
        {
            DPOLog::report_msg(DPOEvents::GET_PATH_FAILURE, [$project->{name}, "$self->{this_product}->{path}/projects"]);
            return 0;
        }
    }

    my $file = "$path/DPOProject.xml";
    my $config = DPOProjectConfig->new($file);
    if ($config)
    {
        if (!$config->save($project))
        {
            return 0;
        }
    }
    else
    {
        return 0;
    }

    return 1;
}

sub remove_from_workspace
{
    my ($self) = @_;

    my $tree_ctrl = $self->{tree_ctrl_workspace_projects};
    my @selected_items = $tree_ctrl->GetSelections();

    my $projects_ids_to_remove;
    foreach my $item (@selected_items)
    {
        my $item_text = $tree_ctrl->GetItemText($item);

        $projects_ids_to_remove .= "\n- $item_text";
    }

    my $rc = Wx::MessageBox(
                "Removing\n$projects_ids_to_remove.\n\n".
                "Do you really want to proceed ?",
                "Removing project from workspace",
                Wx::wxYES_NO | Wx::wxICON_QUESTION);
    if ($rc == Wx::wxYES)
    {
        foreach my $item (@selected_items)
        {
            my ($project_name, $target_version) = $tree_ctrl->GetItemText($item) =~ /(.*)-(\d+\.\d+\.\d+)/;
            @{$self->{workspace_projects}} = grep { "$_->{name}-$_->{target_version}" ne "$project_name-$target_version" } @{$self->{workspace_projects}};
            if (!$self->save_workspace($self->{workspace_projects}))
            {
                Wx::MessageBox("Can't save workspace.", "", Wx::wxOK | Wx::wxICON_ERROR);
            }

            if ($self->{working_project} != 0)
            {
                if ("$project_name-$target_version" eq "$self->{working_project}->{name}-$self->{working_project}->{target_version}")
                {
                    $self->close_working_project();
                }
            }
        }

        $self->fill_tree_workspace();

        $self->set_available_product_projects_color();

        return 1;
    }

    return 0;
}

sub load_working_project
{
    my ($self) =  @_;

    my $wait = Wx::BusyCursor->new();

    my @selected_items = $self->{tree_ctrl_workspace_projects}->GetSelections();

    if (scalar(@selected_items) == 0)
    {
        return;
    }

    my $selected_workspace_project_version;

    my $root_item = $self->{tree_ctrl_workspace_projects}->GetRootItem();
    foreach my $item (@selected_items)
    {
        if ($self->{tree_ctrl_workspace_projects}->GetItemParent($item) == $root_item)
        {
            # ***** Only the first selected root child item is processed *****
            $selected_workspace_project_version = $self->{tree_ctrl_workspace_projects}->GetItemText($item);
            last;
        }
        else
        {
            if (scalar(@selected_items) == 1)
            {
                $selected_workspace_project_version = $self->{tree_ctrl_workspace_projects}->GetItemText($item);
                last;
            }
        }
    }

    #~ print "load_working_project: $selected_workspace_project_version...\n";

    my ($project_name, $version) = $selected_workspace_project_version =~ /(.*)-(\d+.\d+.\d+)/;

    my $selection = 0;
    foreach my $x (@{$self->{workspace_projects}})
    {
        if ($x->{name} eq $project_name)
        {
            $selection = $x;
            last;
        }
    }

    if ($selection != 0)
    {
        $self->{working_project} = $selection;

        $self->{sizer_working_project_staticbox}->SetLabel("Working project (*** $self->{working_project}->{name} ***)");
        $self->{text_ctrl_working_project_current_version}->Enable(1);
        $self->{text_ctrl_working_project_target_version}->Enable(1);
        $self->{button_working_project_expand}->Enable(1);
        $self->{button_layers}->Enable(1);

        $self->{text_ctrl_working_project_current_version}->ChangeValue($self->{working_project}->{version});
        $self->{text_ctrl_working_project_target_version}->ChangeValue($self->{working_project}->{target_version});
        if ($self->{working_project}->is_library())
        {
            $self->{sizer_type_staticbox}->Show(1);
            $self->{checkbox_dynamic}->Enable(1);
            $self->{checkbox_static}->Enable(1);

            $self->{checkbox_dynamic}->Show(1);
            $self->{checkbox_static}->Show(1);

            if ($self->{working_project}->is_header_impl_or_abstract_class())
            {
                $self->{checkbox_dynamic}->Enable(0);
                $self->{checkbox_static}->Enable(0);
                $self->{checkbox_dynamic}->SetValue(0);
                $self->{checkbox_static}->SetValue(0);
            }
            else
            {
                $self->{checkbox_dynamic}->SetValue(0);
                $self->{checkbox_static}->SetValue(0);

                if ($self->{working_project}->is_dynamic_library())
                {
                    $self->{checkbox_dynamic}->SetValue(1);
                    $self->{sizer_working_project_types}->Show($self->{sizer_working_project_type_dynamic}, 1);
                }
                else
                {
                    $self->{sizer_working_project_types}->Show($self->{sizer_working_project_type_dynamic}, 0);
                }

                if ($self->{working_project}->is_static_library())
                {
                    $self->{checkbox_static}->SetValue(1);
                    $self->{sizer_working_project_types}->Show($self->{sizer_working_project_type_static}, 1);
                }
                else
                {
                    $self->{sizer_working_project_types}->Show($self->{sizer_working_project_type_static}, 0);
                }
            }
        }
        else
        {
            # Executable or header_impl/abstract
            $self->{sizer_type_staticbox}->Show(0);
            $self->{checkbox_dynamic}->Show(0);
            $self->{checkbox_static}->Show(0);
            $self->{sizer_working_project_types}->Show($self->{sizer_working_project_type_static}, 0);
        }

        $self->{tree_ctrl_working_project_dynamic}->Enable(1);
        $self->{tree_ctrl_working_project_static}->Enable(1);

        $self->fill_tree_working();

        $self->{sizer_working_project_types}->Layout();
    }
    else
    {
        Wx::MessageBox("$project_name is not a workspace project.", "", Wx::wxOK | Wx::wxICON_ERROR);
    }

    if (scalar(@{$self->{highlight_modules}}) != 0)
    {
        $self->highlight_tree($self->{tree_ctrl_working_project_dynamic}, $self->{button_working_project_expand});
        $self->highlight_tree($self->{tree_ctrl_working_project_static}, $self->{button_working_project_expand});
    }
}

sub fill_tree_working
{
    my ($self) = @_;

    if ($self->{working_project})
    {
        $self->fill_tree_working_ext(
                    $self->{working_project},
                    $self->{tree_ctrl_working_project_dynamic},
                    $self->{tree_ctrl_working_project_static})
    }
}

sub fill_tree_working_ext
{
    my ($self, $project, $tree_dynamic, $tree_static) = @_;

    if ($project->is_executable())
    {
        $self->fill_tree_working_spec($tree_dynamic, $project, "dynamic");
        $self->fill_tree_working_spec($tree_static, $project, "static");
    }
    else
    {
        if ($tree_dynamic != $self->{tree_ctrl_working_project_dynamic}
            || $self->{checkbox_dynamic}->GetValue() == 1
            || $self->{working_project}->is_header_impl_or_abstract_class())
        {
            $self->fill_tree_working_spec($tree_dynamic, $project, "dynamic");
        }

        if ($tree_static != $self->{tree_ctrl_working_project_static}
            || $self->{checkbox_static}->GetValue() == 1
            || $self->{working_project}->is_header_impl_or_abstract_class())
        {
            $self->fill_tree_working_spec($tree_static, $project, "static");
        }
    }
}

sub fill_tree_working_spec
{
    my ($self, $tree_ctrl, $project, $type) = @_;

    my $dependencies;
    if ($type eq "dynamic")
    {
        $dependencies = $project->{dependencies_when_dynamic};
    }

    if ($type eq "static")
    {
        $dependencies = $project->{dependencies_when_static};
    }

    $tree_ctrl->DeleteAllItems();
    my $root = $tree_ctrl->AddRoot("");

    foreach my $dep (sort {$a->{name} cmp $b->{name}} @{$dependencies})
    {
        my $proj;
        $self->get_project($dep->{name}, \$proj);

        $proj->{type} = $dep->{type};

        my $type_text="";
        if ($proj->is_executable())
        {
            $type_text = " (excutable)";
        }
        if ($proj->{type} == 4)
        {
            $type_text = " (???)";
        }
        if ($proj->{type} == 5)
        {
            $type_text = " (static)";
        }
        if ($proj->{type} == 6)
        {
            $type_text = " (dynamic)";
        }
        if ($proj->{type} == 7)
        {
            $type_text = " (??? dynamic/static ???)";
        }
        if ($proj->{type} == 8)
        {
            if ($type eq "dynamic")
            {
                $type_text = " (dynamic)";
            }
            if ($type eq "static")
            {
                $type_text = " (static)";
            }
        }

        my $item = $tree_ctrl->AppendItem($root, "$proj->{name}-$proj->{target_version}$type_text");
        if ($proj->is_executable())
        {
            $tree_ctrl->SetItemBackgroundColour($item, $col_executable_dep);
            $tree_ctrl->SetItemTextColour($item, $col_black);
        }
        if ($proj->{type} == 4)
        {
            $tree_ctrl->SetItemBackgroundColour($item, $col_red);
            $tree_ctrl->SetItemTextColour($item, $col_white);
        }
        if ($proj->{type} == 7)
        {
            $tree_ctrl->SetItemBackgroundColour($item, $col_red);
            $tree_ctrl->SetItemTextColour($item, $col_white);
        }
        $self->fill_tree_working_dependencies($tree_ctrl, $item, $proj, $type);
    }

    # Expand or not?
    if ($self->{button_working_project_expand}->GetLabel() eq "-")
    {
        $tree_ctrl->ExpandAllChildren($root);
        my ($child, $cookie) = $tree_ctrl->GetFirstChild($root);
        $tree_ctrl->EnsureVisible($child);
        $self->{button_working_project_expand}->SetLabel("+");
    }

}

sub fill_tree_working_dependencies
{
    my ($self, $tree_ctrl, $item_parent, $project, $type) = @_;

    #~ my $array = $project->relevant_deps();
    my $array;
    if ($type eq "dynamic")
    {
        $array = $project->{dependencies_when_dynamic};
    }

    if ($type eq "static")
    {
        $array = $project->{dependencies_when_static};
    }

    foreach my $dependency (sort {$a->{name} cmp $b->{name}} @{$array})
    {
        my $proj;
        $self->get_project($dependency->{name}, \$proj);

        $proj->{type} = $dependency->{type};

        my $type_text="";
        if ($proj->is_executable())
        {
            $type_text = " (excutable)";
        }
        if ($proj->{type} == 4)
        {
            $type_text = " (???)";
        }
        if ($proj->{type} == 5)
        {
            $type_text = " (static)";
        }
        if ($proj->{type} == 6)
        {
            $type_text = " (dynamic)";
        }
        if ($proj->{type} == 7)
        {
            $type_text = " (static/dynamic)";
        }
        if ($proj->{type} == 8)
        {
            $type_text = " (mpb)";
        }

        my $item = $tree_ctrl->AppendItem($item_parent, "$proj->{name}-$proj->{target_version}$type_text");
        $self->fill_tree_working_dependencies($tree_ctrl, $item, $proj, $type);
    }
}

sub highlight
{
    my ($self) = @_;

    my @working_project;
    if ($self->{working_project})
    {
        @working_project = ($self->{working_project});
    }
    my $dlg = DPOProductHighlightDlg->new(
                    $self,
                    undef,
                    -1,
                    "",
                    Wx::wxDefaultPosition,
                    Wx::wxDefaultSize,
                    Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

    my $rc = $dlg->ShowModal();

    $dlg->Destroy();

    $self->{highlight_modules} = $dlg->{selection};
    $self->{highlight_modules_cancel} = $dlg->{cancel_highlight};

    if ($rc == Wx::wxID_OK)
    {
        $self->highlight_tree($self->{tree_ctrl_workspace_projects}, $self->{button_workspace_projects_expand});
        $self->highlight_tree($self->{tree_ctrl_runtime}, $self->{button_runtime_expand});
        $self->highlight_tree($self->{tree_ctrl_working_project_dynamic}, $self->{button_working_project_expand});
        $self->highlight_tree($self->{tree_ctrl_working_project_static}, $self->{button_working_project_expand});
        $self->highlight_tree($self->{tree_ctrl_runtime_in_workspace}, $self->{button_runtime_expand});
    }
}

sub highlight_tree
{
    my ($self, $tree, $button_expand) = @_;

    my $root_item = $tree->GetRootItem();
    $self->highlight_items_in_tree($tree,
                                    $root_item,
                                    $self->{highlight_modules},
                                    $self->{highlight_modules_cancel});

    #~ $tree->ExpandAllChildren($root_item);
    #~ my ($child, $cookie) = $tree->GetFirstChild($root_item);
    #~ $tree->EnsureVisible($child);
    $button_expand->SetLabel("-");
}

sub highlight_items_in_tree
{
    my ($self, $tree, $item, $items_to_hightlight, $cancel) = @_;

    my ($child, $cookie) = $tree->GetFirstChild($item);
    while ($child && $child->IsOk())
    {
        my $text = $tree->GetItemText($child);
        my ($project_name, $version) = $text =~ /(.*)-(\d+\.\d+\.\d+)/;

        if (defined($project_name)
            && defined($version))
        {
            if (List::MoreUtils::any {$_ eq "$project_name-$version"} @{$items_to_hightlight})
            {
                if ($cancel)
                {
                    $tree->SetItemBold($child, 0);
                }
                else
                {
                    $tree->SetItemBold($child, 1);
                    $tree->EnsureVisible($child);
                }
            }

            $self->highlight_items_in_tree($tree, $child, $items_to_hightlight, $cancel);
        }

        ($child, $cookie) = $self->{tree_ctrl_workspace_projects}->GetNextChild($item, $cookie);
    }
}

sub save_working_project
{
    my ($self, $update_version_file) = @_;

    my $wait = Wx::BusyCursor->new();

    if ($self->{working_project} != 0)
    {
        if ($self->update_workspace_projects($self->{working_project}))
        {
            if ($update_version_file)
            {
                if (!$self->update_header_version_file($self->{working_project}))
                {
                    return 0;
                }
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::UPDATE_WORKSPACE_PROJECTS_FAILURE, [$self->{working_project}->{name}]);
        }

        $self->fill_product_projects();
        $self->fill_tree_working();
        $self->fill_tree_workspace();
        $self->fill_tree_runtime();
    }

    return 1;
}

sub update_workspace_projects
{
    my ($self, $new_project) = @_;

    foreach my $project (@{$self->{workspace_projects}})
    {
        my $save = 0;

        if ($project->{name} eq $new_project->{name})
        {
            $project = $new_project;
            $save = 1;
        }
        else
        {
            foreach my $dep (@{$project->{dependencies_when_dynamic}}, @{$project->{dependencies_when_static}})
            {
                if ($dep->{name} eq $new_project->{name})
                {
                    if ($dep->{version} ne $new_project->{version}
                        || $dep->{target_version} ne $new_project->{target_version}
                        || $dep->{type} != $new_project->{type}
                        || $dep->{dpo_compliant}->{value} != $new_project->{dpo_compliant}->{value}
                        || $dep->{dpo_compliant}->{product_name} ne $new_project->{dpo_compliant}->{product_name}
                        || $dep->{dpo_compliant}->{product_flavour} ne $new_project->{dpo_compliant}->{product_flavour}
                        || $dep->{dpo_compliant}->{mpb} ne $new_project->{dpo_compliant}->{mpb}
                        || $dep->{dpo_compliant}->{mpc_includes} ne $new_project->{dpo_compliant}->{mpc_includes})
                    {
                        $dep->{version} = $new_project->{version};
                        $dep->{target_version} = $new_project->{target_version};
                        $dep->{type} = $new_project->{type};
                        $dep->{dpo_compliant} = $new_project->{dpo_compliant};
                        $save = 1;
                    }
                }
            }
        }

        if ($save)
        {
            print "save $project->{name}...\n";

            if (!$self->save_project($project))
            {
                DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Can't save project $project->{name}"]);
                return 0;
            }
        }
    }

    return 1;
}

sub checkbox_dynamic_static
{
    my ($self, $type) = @_;

    my $checkbox;
    my $dependencies_when_type;
    my $dependencies_when_other_type;
    my $sizer;
    if ($type eq "dynamic")
    {
        $checkbox = $self->{checkbox_dynamic};
        $dependencies_when_type = $self->{working_project}->{dependencies_when_dynamic};
        $dependencies_when_other_type = $self->{working_project}->{dependencies_when_static};
        $sizer = $self->{sizer_working_project_type_dynamic};

        if ($checkbox->GetValue() == 1)
        {
            if ($self->{working_project}->{type} == 5)
            {
                $self->{working_project}->{type} = 7;
            }
            else
            {
                $self->{working_project}->{type} = 6;
            }
        }
        else
        {
            if ($self->{working_project}->{type} == 7)
            {
                $self->{working_project}->{type} = 5;
            }
            else
            {
                $self->{working_project}->{type} = 4;
            }
        }
    }
    else
    {
        $checkbox = $self->{checkbox_static};
        $dependencies_when_type = $self->{working_project}->{dependencies_when_static};
        $dependencies_when_other_type = $self->{working_project}->{dependencies_when_dynamic};
        $sizer = $self->{sizer_working_project_type_static};

        if ($checkbox->GetValue() == 1)
        {
            if ($self->{working_project}->{type} == 6)
            {
                $self->{working_project}->{type} = 7;
            }
            else
            {
                $self->{working_project}->{type} = 5;
            }
        }
        else
        {
            if ($self->{working_project}->{type} == 7)
            {
                $self->{working_project}->{type} = 6;
            }
            else
            {
                $self->{working_project}->{type} = 4;
            }
        }
    }

    # When we want a project to become a certain type
    # we must check if for the other type there is dependencies
    # to apply them to this certain type.
    if ($checkbox->GetValue() == 1)
    {
        my @projects_to_define_types;

        foreach my $dep (@{$dependencies_when_other_type})
        {
            if (!List::MoreUtils::any {$_->{name} eq $dep->{name}} @{$dependencies_when_type})
            {
                my $proj;
                $self->get_project($dep->{name}, \$proj);

                push(@projects_to_define_types, $proj->clone);
            }
        }

        if (!$self->add_new_projects_to_working_one(\@projects_to_define_types))
        {
            $checkbox->SetValue(!$checkbox->GetValue());
            return;
        }
    }

    if ($self->{working_project}->{type} == 4)
    {
        $self->{sizer_working_project_types}->Show($self->{sizer_working_project_type_dynamic}, $checkbox->GetValue());
        $self->{sizer_working_project_types}->Show($self->{sizer_working_project_type_static}, $checkbox->GetValue());
    }
    else
    {
        $self->{sizer_working_project_types}->Show($sizer, $checkbox->GetValue());
    }

    $self->save_working_project(0);

    $self->{sizer_working_project_types}->Layout();
}

sub add_new_projects_to_working_one
{
    my ($self, $projects_to_add_ref) = @_;

    if (scalar(@{$projects_to_add_ref}) != 0)
    {
        my $ok = 1;

        foreach my $project (@{$projects_to_add_ref})
        {
            my @libs_with_both_types;   # To choose between static and dynamic when necessary (type == 7)

            my $dep = DPOProjectDependency->new($project->{name},
                                                $project->{version},
                                                $project->{target_version},
                                                $project->{type},
                                                $project->{dpo_compliant});

            if ($dep->{type} == 7)
            {
                if (!List::MoreUtils::any {$_->{name} eq $dep->{name}}
                        @{$self->{working_project}->{dependencies_when_dynamic}}, @{$self->{working_project}->{dependencies_when_static}})
                {
                    $dep->{type} = 7;
                    push(@libs_with_both_types, $dep);
                }
            }
            else
            {
                if (!List::MoreUtils::any {$_->{name} eq $dep->{name}} @{$self->{working_project}->{dependencies_when_dynamic}})
                {
                    push(@{$self->{working_project}->{dependencies_when_dynamic}}, $dep);
                }
                if (!List::MoreUtils::any {$_->{name} eq $dep->{name}} @{$self->{working_project}->{dependencies_when_static}})
                {
                    push(@{$self->{working_project}->{dependencies_when_static}}, $dep);
                }
            }


            # In case dependency is available in static and dynamic types,
            # choose which one we want to use.
            if (scalar(@libs_with_both_types) != 0)
            {
                my $dlg = DPOProductStaticDynamicChoiceDlg->new(
                                $self->{working_project},
                                \@libs_with_both_types,
                                undef,
                                -1,
                                "",
                                Wx::wxDefaultPosition,
                                Wx::wxDefaultSize,
                                Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

                if ($dlg->ShowModal() == Wx::wxID_CANCEL)
                {
                    $ok = 0;
                }

                $dlg->Destroy();
            }
        }

        if ($ok)
        {
            $self->save_working_project(0);

            $self->fill_tree_working();
        }

        return $ok;
    }

    return 1;
}

sub tree_working_project_dynamic_keydown
{
    my ($self, $event, $type_text, $tree_ctrl) = @_;

    my $key_code = $event->GetKeyCode();

    if ($key_code == Wx::WXK_DELETE)
    {
        $self->prepare_actions_on_working_project_tree($type_text, $event, 0);
        $self->remove_working_project_dependencies($tree_ctrl);
    }
}

sub prepare_actions_on_working_project_tree
{
    my ($self, $type, $event, $popup) = @_;

    my $tree_ctrl;
    my $deps;

    if ($type eq "dynamic")
    {
        $tree_ctrl = $self->{tree_ctrl_working_project_dynamic};
        $deps = $self->{working_project}->{dependencies_when_dynamic};
    }
    else
    {
        $tree_ctrl = $self->{tree_ctrl_working_project_static};
        $deps = $self->{working_project}->{dependencies_when_static};
    }

    my $root_item = $tree_ctrl->GetRootItem();

    my @sel = $tree_ctrl->GetSelections();

    $self->{dependencies_to_take_action_on} = [];

    foreach my $item (@sel)
    {
        if ($tree_ctrl->GetItemParent($item) == $root_item)
        {
            my $text = $tree_ctrl->GetItemText($item);

            my ($project_name, $version) = $text =~ /(.*)-(\d+\.\d+\.\d+)/;

            foreach my $dep (@{$deps})
            {
                if ($dep->{name} eq $project_name)
                {
                    push(@{$self->{dependencies_to_take_action_on}}, $dep);
                }
            }
        }
    }

    if (scalar(@{$self->{dependencies_to_take_action_on}}) != 0
        && $popup)
    {
        $self->{working_project_tree} = $tree_ctrl;

        my $menuPopUp = Wx::Menu->new();
        $menuPopUp->Append(DEPENDENCY_STATIC, "Static");
        $menuPopUp->Append(DEPENDENCY_DYNAMIC, "Dynamic");
        $menuPopUp->Append(DEPENDENCY_REMOVE, "Remove");

        $tree_ctrl->PopupMenu($menuPopUp, $event->GetPoint());
    }
}

sub remove_working_project_dependencies
{
    my ($self, $tree_ctrl) = @_;

    if (scalar(@{$self->{dependencies_to_take_action_on}}) == 0)
    {
        return;
    }

    my $msg = "Do you really want to remove these dependencies ?\n";
    foreach my $x (@{$self->{dependencies_to_take_action_on}})
    {
        $msg .= "\n" . $x->{name} . "-" . $x->{target_version};
    }

    my $rc = Wx::MessageBox(
                $msg,
                "Removing projects from working project",
                Wx::wxYES_NO | Wx::wxICON_QUESTION);
    if ($rc == Wx::wxNO)
    {
        return;
    }

    foreach my $x (@{$self->{dependencies_to_take_action_on}})
    {
        @{$self->{working_project}->{dependencies_when_dynamic}} = grep { "$_->{name}-$_->{target_version}" ne "$x->{name}-$x->{target_version}" } @{$self->{working_project}->{dependencies_when_dynamic}};
        @{$self->{working_project}->{dependencies_when_static}} = grep { "$_->{name}-$_->{target_version}" ne "$x->{name}-$x->{target_version}" } @{$self->{working_project}->{dependencies_when_static}};

        if (!$self->more_than_one_ref($x, $self->{workspace_projects}))
        {
            @{$self->{loaded_projects}} = grep { "$_->{name}-$_->{version}" ne "$x->{name}-$x->{version}" } @{$self->{loaded_projects}};
        }
    }

    $self->save_working_project(0);

    $self->fill_tree_working();
}

sub more_than_one_ref
{
    my ($self, $proj, $array, $count_ref) = @_;

    if (!defined($count_ref))
    {
        $$count_ref = 0;
    }

    foreach my $x (@{$array})
    {
        if ($x->{name} eq $proj->{name}
            && $x->{version} eq $proj->{version})
        {
            $$count_ref++;
        }

        if ($$count_ref > 1)
        {
            return 1;
        }

        my $project;
        if ($self->get_project($x->{name}, \$project))
        {
            my @deps;
            foreach my $dep (@{$project->{dependencies_when_dynamic}}, @{$project->{dependencies_when_static}})
            {
                if (!List::MoreUtils::any {"$_->{name}-$_->{version}" eq "$dep->{name}-$dep->{version}"} @deps)
                {
                    push(@deps, $dep);
                }
            }

            #~ my @deps = (@{$project->{dependencies_when_dynamic}}, @{$project->{dependencies_when_static}});
            if ($self->more_than_one_ref($proj, \@deps, $count_ref))
            {
                return 1;
            }
        }
        else
        {
            DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$x->{name}]);
            return 0;
        }
    }

    return 0;
}

sub expand_working_project
{
    my ($self, $expand) = @_;

    my $root = $self->{tree_ctrl_working_project_dynamic}->GetRootItem();

    if ($expand)
    {
        $self->{tree_ctrl_working_project_dynamic}->ExpandAllChildren($root);
        my ($child, $cookie) = $self->{tree_ctrl_working_project_dynamic}->GetFirstChild($root);
        $self->{tree_ctrl_working_project_dynamic}->EnsureVisible($child);

        $self->{tree_ctrl_working_project_static}->ExpandAllChildren($root);
        ($child, $cookie) = $self->{tree_ctrl_working_project_static}->GetFirstChild($root);
        $self->{tree_ctrl_working_project_static}->EnsureVisible($child);
    }
    else
    {
        $self->{tree_ctrl_working_project_dynamic}->CollapseAllChildren($root);
        $self->{tree_ctrl_working_project_static}->CollapseAllChildren($root);
    }
}

sub update_header_version_file
{
    my ($self, $project) = @_;

    my $path = "";
    foreach my $elem (@{$self->{product_projects_paths}})
    {
        my ($project_name) = $elem =~ /.*\/(.*)/;
        if ($project_name eq $project->{name})
        {
            $path = $elem;
            last;
        }
    }

    if ($path eq "")
    {
        DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Failed to save header for $project->{name}"]);
        return 0;
    }

    my $header_version_file = "$path/include/$project->{name}/version.h";

    my @lines=();
    if (!DPOUtils::get_file_lines($header_version_file, \@lines))
    {
        DPOLog::report_msg(DPOEvents::GET_LINES_FROM_FILE_FAILURE, [$header_version_file]);
        return 0;
    }

    my $tmp_file = "version.h.tmp";
    if (!open (OUT, ">$tmp_file"))
    {
        DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, ["open", $tmp_file, $!]);
        return 0;
    }

    my @tokens = split(/\./, $project->{target_version});

    my $major = $tokens[0];
    my $minor = $tokens[1];
    my $patch = $tokens[2];

    foreach(@lines)
    {
        my $updated_line=$_;

        if (/_MAJOR/)
        {
            $self->get_updated_line($_, $major, \$updated_line);
        }
        else
        {
            if (/_MINOR/)
            {
                $self->get_updated_line($_, $minor, \$updated_line);
            }
            else
            {
                if (/_PATCH/)
                {
                    $self->get_updated_line($_, $patch, \$updated_line);
                }
            }
        }

        print OUT "$updated_line";
    }

    close(OUT);

    my $ok = 1;
    if (!File::Copy::syscopy($tmp_file, $header_version_file))
    {
        DPOLog::report_msg(DPOEvents::FILE_COPY_FAILURE, [$tmp_file, $header_version_file, $!]);
        $ok = 0;
    }

    unlink($tmp_file);

    return $ok;
}

sub get_runtime_dependencies_to_remove
{
    my ($self) = @_;

    $self->{runtime_dependencies_to_remove} = [];
    $self->{remove_runtime_warnings} = ();

    my $root_item = $self->{tree_ctrl_runtime}->GetRootItem();

    my @selected_items = $self->{tree_ctrl_runtime}->GetSelections();
    foreach my $item (@selected_items)
    {
        my $item_text = $self->{tree_ctrl_runtime}->GetItemText($item);

        if ($self->{tree_ctrl_runtime}->GetItemParent($item) == $root_item)
        {
            push(@{$self->{runtime_dependencies_to_remove}}, DPORuntimeDependencyToRemove->new($item_text, undef));
        }
        else
        {
            my $parent = $self->{tree_ctrl_runtime}->GetItemParent($item);
            my $last_non_root_parent = $parent;
            if ($self->{tree_ctrl_runtime}->GetItemParent($parent) != $root_item)
            {
                while ($parent != $root_item)
                {
                    $last_non_root_parent = $parent;
                    $parent = $self->{tree_ctrl_runtime}->GetItemParent($parent);
                }
                my $parent_text = $self->{tree_ctrl_runtime}->GetItemText($last_non_root_parent);
                $self->{remove_runtime_warnings}->{$item_text} = $parent_text;
                next;
            }

            my $parent_text = $self->{tree_ctrl_runtime}->GetItemText($parent);

            push(@{$self->{runtime_dependencies_to_remove}}, DPORuntimeDependencyToRemove->new($parent_text, $item_text));
        }
    }
}

sub remove_module_from_runtime
{
    my ($self) = @_;

    my $parent;

    if (scalar(@{$self->{runtime_dependencies_to_remove}}) != 0)
    {
        my $msg = "Do you really want to remove these dependencies?\n";
        foreach my $x (@{$self->{runtime_dependencies_to_remove}})
        {
            if (defined($x->{dep}))
            {
                $msg .= "\n   - $x->{dep} ($x->{parent})";
            }
            else
            {
                $msg .= "\n   - $x->{parent}";
            }
        }

        my $rc = Wx::MessageBox(
                    $msg,
                    "Removing dependency from runtime",
                    Wx::wxYES_NO | Wx::wxICON_QUESTION);
        if ($rc == Wx::wxYES)
        {
            foreach my $x (@{$self->{runtime_dependencies_to_remove}})
            {
                if (!defined($x->{dep}))
                {
                    @{$self->{this_product}->{runtime}->{runtime_products_compliant}} = grep { $_->{name} ne $x->{parent} } @{$self->{this_product}->{runtime}->{runtime_products_compliant}};
                    @{$self->{this_product}->{runtime}->{runtime_products_non_compliant}} = grep { $_->{name} ne $x->{parent} } @{$self->{this_product}->{runtime}->{runtime_products_non_compliant}};
                }
                else
                {
                    # Trying to remove a project/module_name
                    foreach my $p (@{$self->{this_product}->{runtime}->{runtime_products_compliant}})
                    {
                        @{$p->{dpo_project_dependencies}} = grep { "$_->{name}-$_->{version}" ne $x->{dep} } @{$p->{dpo_project_dependencies}};

                        if (scalar(@{$p->{dpo_project_dependencies}}) == 0)
                        {
                            Wx::MessageBox(
                                        "$p->{name} has no more dependencies.\n\n".
                                        "It will be removed from runtime dependencies too.",
                                        "Removing dependency from runtime");

                            my $product_flavour = $p->{flavour};

                            if ($product_flavour eq "")
                            {
                                @{$self->{this_product}->{runtime}->{runtime_products_compliant}} = grep { "$_->{name}-$_->{version}" ne "$p->{name}-$p->{version}" } @{$self->{this_product}->{runtime}->{runtime_products_compliant}};
                            }
                            else
                            {
                                @{$self->{this_product}->{runtime}->{runtime_products_compliant}} = grep { "$_->{name}-$_->{version}-$_->{flavour}" ne "$p->{name}-$p->{version}-$p->{flavour}" } @{$self->{this_product}->{runtime}->{runtime_products_compliant}};
                            }
                        }
                    }

                    foreach my $p (@{$self->{this_product}->{runtime}->{runtime_products_non_compliant}})
                    {
                        @{$p->{modules_names}} = grep { $_ ne $x->{dep} } @{$p->{modules_names}};

                        if (scalar(@{$p->{modules_names}}) == 0)
                        {
                            Wx::MessageBox(
                                        "$p->{name} has no more modules.\n\n".
                                        "It will be removed from runtime dependencies too.",
                                        "Removing dependency from runtime");

                            my $product_flavour = $p->{flavour};

                            if ($product_flavour eq "")
                            {
                                @{$self->{this_product}->{runtime}->{runtime_products_non_compliant}} = grep { "$_->{name}-$_->{version}" ne "$p->{name}-$p->{version}" } @{$self->{this_product}->{runtime}->{runtime_products_non_compliant}};
                            }
                            else
                            {
                                @{$self->{this_product}->{runtime}->{runtime_products_non_compliant}} = grep { "$_->{name}-$_->{version}-$_->{flavour}" ne "$p->{name}-$p->{version}-$p->{flavour}" } @{$self->{this_product}->{runtime}->{runtime_products_non_compliant}};
                            }
                        }
                    }
                }
            }

            $self->load_runtime();

            if (!$self->save_runtime())
            {
                # TO_DO
            }
        }
        else
        {
            return 0;
        }
    }

    # Trace modules that can't be removed.
    if (defined($self->{remove_runtime_warnings}))
    {
        foreach my $key (keys $self->{remove_runtime_warnings})
        {
            DPOLog::report_msg(DPOEvents::RUNTIME_COMPLIANT_SUB_DEP_CANT_BE_REMOVED, [$key, $self->{remove_runtime_warnings}->{$key}]);
        }
    }

    $self->fill_tree_runtime();

    return 1;
}

sub save_runtime
{
    my ($self) = @_;

    my $dpoproduct_file = "$self->{this_product}->{path}/DPOProduct.xml";

    my $config_product = DPOProductConfig->new($dpoproduct_file);
    if ($config_product)
    {
        if (!$config_product->save($self->{this_product}))
        {
            Wx::MessageBox("Can't save product", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }
    }
    else
    {
        Wx::MessageBox("Can't load product $dpoproduct_file", "", Wx::wxOK | Wx::wxICON_ERROR);
        return 0;
    }

    return 1;
}

sub remove_from_runtime_in_modules
{
    my ($self) = @_;

    my $tree_ctrl = $self->{tree_ctrl_runtime_in_workspace};
    my @selected_items = $tree_ctrl->GetSelections();

    my $projects_ids_to_remove;
    foreach my $item (@selected_items)
    {
        my $item_text = $tree_ctrl->GetItemText($item);

        $projects_ids_to_remove .= "\n- $item_text";
    }

    my $rc = Wx::MessageBox(
                "Removing\n$projects_ids_to_remove.\n\n".
                "Do you really want to proceed ?",
                "Removing project from workspace",
                Wx::wxYES_NO | Wx::wxICON_QUESTION);
    if ($rc == Wx::wxYES)
    {
        foreach my $item (@selected_items)
        {
            my ($project_name, $target_version) = $tree_ctrl->GetItemText($item) =~ /(.*)-(\d+\.\d+\.\d+)/;
            @{$self->{runtime_in_workspace}} = grep { "$_->{name}-$_->{target_version}" ne "$project_name-$target_version" } @{$self->{runtime_in_workspace}};
            if (!$self->save_runtime_in_workspace($self->{runtime_in_workspace}))
            {
                Wx::MessageBox("Can't save runtime_modules.", "", Wx::wxOK | Wx::wxICON_ERROR);
            }
        }

        $self->fill_tree_runtime_in_workspace();
    }
    else
    {
        return 0;
    }

    return 1;
}

sub save_runtime_in_workspace
{
    my ($self) = @_;

    my $file = "$self->{workspace_path}/runtime_modules";

    my $tmp_file = "runtime_modules.tmp";
    if (open (OUT, ">$tmp_file"))
    {
        foreach my $project (@{$self->{runtime_in_workspace}})
        {
            print OUT "$project->{name}\n";
        }

        close(OUT);

        if (!File::Copy::syscopy($tmp_file, $file))
        {
            Wx::MessageBox("Can't copy temporary file to runtime_modules file.", "", Wx::wxOK | Wx::wxICON_ERROR);
        }

        unlink($tmp_file);
    }
    else
    {
        Wx::MessageBox("Can't open temporary file to save runtime_modules in workspace.", "", Wx::wxOK | Wx::wxICON_ERROR);
    }
}

sub expand_runtime
{
    my ($self, $expand) = @_;

    my $root = $self->{tree_ctrl_runtime}->GetRootItem();

    if ($expand)
    {
        $self->{tree_ctrl_runtime}->ExpandAllChildren($root);
        my ($child, $cookie) = $self->{tree_ctrl_runtime}->GetFirstChild($root);
        $self->{tree_ctrl_runtime}->EnsureVisible($child);
    }
    else
    {
        $self->{tree_ctrl_runtime}->CollapseAllChildren($root);
    }
}

sub expand_workspace_projects
{
    my ($self, $expand) = @_;

    my $root = $self->{tree_ctrl_workspace_projects}->GetRootItem();

    if ($expand)
    {
        $self->{tree_ctrl_workspace_projects}->ExpandAllChildren($root);
        my ($child, $cookie) = $self->{tree_ctrl_workspace_projects}->GetFirstChild($root);
        $self->{tree_ctrl_workspace_projects}->EnsureVisible($child);
    }
    else
    {
        $self->{tree_ctrl_workspace_projects}->CollapseAllChildren($root);
    }
}

sub get_runtime_in_workspace_to_remove
{
    my ($self) = @_;

    $self->{runtime_in_workspace_to_remove} = [];
    $self->{remove_runtime_in_workspace_warnings} = ();

    my $root_item = $self->{tree_ctrl_runtime_in_workspace}->GetRootItem();

    my @selected_items = $self->{tree_ctrl_runtime_in_workspace}->GetSelections();
    foreach my $item (@selected_items)
    {
        my $item_text = $self->{tree_ctrl_runtime_in_workspace}->GetItemText($item);

        if ($self->{tree_ctrl_runtime_in_workspace}->GetItemParent($item) == $root_item)
        {
            push(@{$self->{runtime_in_workspace_to_remove}}, DPORuntimeDependencyToRemove->new($item_text, undef));
        }
        else
        {
            my $parent = $self->{tree_ctrl_runtime_in_workspace}->GetItemParent($item);
            my $last_non_root_parent = $parent;
            if ($self->{tree_ctrl_runtime_in_workspace}->GetItemParent($parent) != $root_item)
            {
                while ($parent != $root_item)
                {
                    $last_non_root_parent = $parent;
                    $parent = $self->{tree_ctrl_runtime_in_workspace}->GetItemParent($parent);
                }
                my $parent_text = $self->{tree_ctrl_runtime_in_workspace}->GetItemText($last_non_root_parent);
                $self->{remove_runtime_in_workspace_warnings}->{$item_text} = $parent_text;
                next;
            }

            my $parent_text = $self->{tree_ctrl_runtime_in_workspace}->GetItemText($parent);

            push(@{$self->{runtime_in_workspace_to_remove}}, DPORuntimeDependencyToRemove->new($parent_text, $item_text));
        }
    }
}

sub update_working_project_dependency_type
{
    my ($self, $project_name, $type, $type_text, $dep) = @_;

    if (!$dep->{dpo_compliant}->{value})
    {
        # Determine if the project can be used as $type
        my $product;
        if (!DPOProductConfig::get_product_with_name($dep->{dpo_compliant}->{product_name}, \$product))
        {
            Wx::MessageBox("Can't load product $dep->{dpo_compliant}->{product_name}", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }

        my $lib_type;
        if ($product->get_lib_type($dep->{name}, \$lib_type))
        {
            my $available = 0;

            if ($type == 5)
            {
                if ($lib_type == 5
                    || $lib_type == 7)
                {
                    $dep->{type} = $type;
                    $available = 1;
                }
            }
            if ($type == 6)
            {
                if ($lib_type == 6
                    || $lib_type == 7)
                {
                    $dep->{type} = $type;
                    $available = 1;
                }
            }

            if (!$available)
            {
                Wx::MessageBox("$dep->{name} is not available as '$type_text'", "", Wx::wxOK | Wx::wxICON_ERROR);
                return 0;
            }
        }
        else
        {
            Wx::MessageBox("Can't get lib type from $dep->{dpo_compliant}->{mpb} (doesn't exist)", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }
    }
    else
    {
        my $project;
        if (!$self->get_project($project_name, \$project))
        {
            Wx::MessageBox("Can't get project $project_name ==> can't change type.", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }

        if (($project->{type} & $type) != $type)
        {
            Wx::MessageBox("$project_name is not available as '$type_text'.", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }

        $dep->{type} = $type;
    }

    return 1;
}

sub show_workspace_project_side
{
    my ($self, $type) = @_;

    my $dlg = DPOProductWorkspaceProjectSideDlg->new(
                    $self,
                    $self->{workspace_project_to_show},
                    undef,
                    -1,
                    "",
                    Wx::wxDefaultPosition,
                    Wx::wxDefaultSize,
                    Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

    $dlg->ShowModal();

    $dlg->Destroy();
}

sub drag_copy
{
    my ($self, $x, $y, $source) = @_;

    # Determine the source list control
    my $ctrl_source;

    if ($source eq "list_ctrl_product_projects")
    {
        $ctrl_source = $self->{list_ctrl_product_projects};
    }
    else
    {
        if ($source eq "tree_ctrl_external_modules")
        {
            $ctrl_source = $self->{tree_ctrl_external_modules};
        }
        else
        {
            if ($source eq "tree_ctrl_runtime_pack")
            {
                $ctrl_source = $self->{tree_ctrl_runtime_pack};
            }
            else
            {
                return;
            }
        }
    }

    # Find the target widget
    my @point = $self->ClientToScreen($x, $y);

    my $target;

    my $notebook_workspace_pane_text = $self->{notebook_workspace_runtime}->GetPageText($self->{notebook_workspace_runtime}->GetSelection());
    my $notebook_runtime_text = $self->{notebook_runtime}->GetPageText($self->{notebook_runtime}->GetSelection());
    if (DPOUtils::point_in_widget($self->{tree_ctrl_workspace_projects}, \@point)
        && $notebook_workspace_pane_text eq "Workspace")
    {
        if ($ctrl_source == $self->{list_ctrl_product_projects})
        {
            if ($self->{workspace_path} eq "")
            {
                Wx::MessageBox("No workspace opened.");
                return;
            }

            $target = "workspace";
        }
        else
        {
            return;
        }
    }
    else
    {
        if (DPOUtils::point_in_widget($self->{tree_ctrl_runtime}, \@point)
            && $notebook_workspace_pane_text eq "Runtime")
        {
            if ($notebook_runtime_text eq "External")
            {
                if ($ctrl_source == $self->{tree_ctrl_external_modules}
                    || $ctrl_source == $self->{tree_ctrl_runtime_pack})
                {
                    $target = "runtime";
                }
                else
                {
                    return;
                }
            }
            else
            {
                if ($notebook_runtime_text eq "Workspace runtime modules")
                {
                    if ($self->{workspace_path} eq "")
                    {
                        Wx::MessageBox("No workspace opened.");
                        return;
                    }

                    if ($ctrl_source == $self->{list_ctrl_product_projects})
                    {
                        $target = "runtime_in_workspace";
                    }
                    else
                    {
                        Wx::MessageBox("Only product projects can go into 'Workspace runtime modules'.");
                        return;
                    }
                }
                else
                {
                    if ($notebook_runtime_text eq "etc/var")
                    {
                        return; # self contained pane: TO_DO
                    }
                }
            }
        }
        else
        {
            if (DPOUtils::point_in_widget($self->{tree_ctrl_working_project_dynamic}, \@point)
                || DPOUtils::point_in_widget($self->{tree_ctrl_working_project_static}, \@point))
            {
                if ($ctrl_source == $self->{list_ctrl_product_projects}
                    || $ctrl_source == $self->{tree_ctrl_external_modules})
                {
                    if ($self->{working_project} != 0)
                    {
                        if ($self->{workspace_path} eq "")
                        {
                            Wx::MessageBox("No workspace opened.");
                            return;
                        }

                        $target = "working_project";
                    }
                    else
                    {
                        Wx::MessageBox("No working project.");
                        return;
                    }
                }
                else
                {
                    return;
                }
            }
            else
            {
                return;
            }
        }
    }

    # %to_copy is a hash with product name as key associated with an
    # array of ToCopy objetcs.

    my %to_copy;

    if ($ctrl_source == $self->{tree_ctrl_external_modules})
    {
        # Targets are working_project and runtime

        my $root = $self->{tree_ctrl_external_modules}->GetRootItem();

        my @selected_items = $self->{tree_ctrl_external_modules}->GetSelections();
        foreach my $item (@selected_items)
        {
            my $parent_item;
            if ($self->{tree_ctrl_external_modules}->GetItemParent($item) == $root)
            {
                $parent_item = $item;
            }
            else
            {
                $parent_item = $self->{tree_ctrl_external_modules}->GetItemParent($item);
            }

            my $product_item_text = $self->{tree_ctrl_external_modules}->GetItemText($parent_item);

            my $product_name;
            my $product_version;
            my $product_flavour;
            DPOProduct::params_from_id($product_item_text, \$product_name, \$product_version, \$product_flavour);

            my $product;
            if (DPOProductConfig::get_product_with_name($product_name, \$product))
            {
                my $item_text = $self->{tree_ctrl_external_modules}->GetItemText($item);
                if ($parent_item != $item
                    || !$product->{dpo_compliant_product}->{value})
                {
                    if (!defined($to_copy{$product->{name}}))
                    {
                        $to_copy{$product->{name}} = ToCopy->new($product_version,
                                                                $product_version,
                                                                $product_flavour,
                                                                $product->{dpo_compliant_product}->{value});
                    }
                    # The dragged product is either compliant or not
                    # If it is compliant, $item_text is composed of project_name and version (name-version).
                    # We have to extract project_name
                    if ($product->{dpo_compliant_product}->{value})
                    {
                        my ($project_name, $version) = $item_text =~ /(.*)-(\d+.\d+.\d+)/;
                        push(@{$to_copy{$product->{name}}->{names}}, $project_name);
                    }
                    else
                    {
                        push(@{$to_copy{$product->{name}}->{names}}, $item_text);
                    }
                }
                else
                {
                    if ($product_flavour ne "")
                    {
                        $product_flavour = "-$product_flavour";
                    }
                    DPOLog::report_msg(DPOEvents::GET_ONLY_PROJECTS_MODULES_CAN_BE_IMPORTED, ["$product_name-$product_version$product_flavour"]);
                    next;
                }
            }
            else
            {
                DPOLog::report_msg(DPOEvents::CANT_GET_PRODUCT, [$product_name]);
                next;
            }
        }
    }
    else
    {
        if ($ctrl_source == $self->{tree_ctrl_runtime_pack})
        {
            # Target is runtime only

            my $root = $self->{tree_ctrl_runtime_pack}->GetRootItem();

            my @selected_items = $self->{tree_ctrl_runtime_pack}->GetSelections();
            foreach my $item (@selected_items)
            {
                my $parent_item = $self->{tree_ctrl_runtime_pack}->GetItemParent($item);
                if ($parent_item == $root)
                {
                    #~ print "Selection is at product level\n";

                    my ($runtime_product_child, $runtime_product_cookie) = $self->{tree_ctrl_runtime_pack}->GetFirstChild($item);
                    while ($runtime_product_child && $runtime_product_child->IsOk())
                    {
                        my $runtime_product_item_text = $self->{tree_ctrl_runtime_pack}->GetItemText($runtime_product_child);

                        $self->fill_to_copy_data($runtime_product_child, \%to_copy);

                        ($runtime_product_child, $runtime_product_cookie) = $self->{tree_ctrl_runtime_pack}->GetNextChild($item, $runtime_product_cookie);
                    }
                }
                else
                {
                    my $grand_parent_item = $self->{tree_ctrl_runtime_pack}->GetItemParent($parent_item);
                    if ($grand_parent_item == $root)
                    {
                        #~ print "Selection is at runtime product level\n";
                        $self->fill_to_copy_data($item, \%to_copy);
                    }
                    else
                    {
                        my $grand_grand_parent_item = $self->{tree_ctrl_runtime_pack}->GetItemParent($grand_parent_item);
                        if ($grand_grand_parent_item == $root)
                        {
                            #~ print "Selection is at module level\n";
                            $self->fill_to_copy_data($parent_item, \%to_copy, \@selected_items);
                        }
                    }
                }
            }
        }
        else
        {
            # $ctrl_source == $self->{list_ctrl_product_projects}
            # Targets are workspace, working project and runtime

            my $product;
            if (DPOProductConfig::get_product_with_name($self->{this_product}->{name}, \$product))
            {
                my $i = -1;
                for ( ;; )
                {
                    $i = $ctrl_source->GetNextItem($i,
                                                Wx::wxLIST_NEXT_ALL,
                                                Wx::wxLIST_STATE_SELECTED);
                    if ( $i == -1 )
                    {
                        last;
                    }

                    my $project_name = $ctrl_source->GetItemText($i);

                    # wxWidgets < 2.9.1 (we must get column 1 value by getting item this way...)
                    my $item = $ctrl_source->GetItem($i, 1);

                    my $version = $item->GetText();
                    #~ $to_copy{"$project_name-$version"} = [];

                    if (!defined($to_copy{$self->{this_product}->{name}}))
                    {
                        $to_copy{$self->{this_product}->{name}} = ToCopy->new($product->{version},
                                                                            $product->{version},
                                                                            $product->{flavour},
                                                                            $product->{dpo_compliant_product}->{value});
                    }

                    push(@{$to_copy{$self->{this_product}->{name}}->{names}}, $project_name);
                }
            }
            else
            {
                DPOLog::report_msg(DPOEvents::CANT_GET_PRODUCT, [$self->{this_product}->{name}]);
            }
        }
    }

    if (scalar(keys %to_copy) == 0)
    {
        return;
    }

    # Process projects addition according to target

    if ($target eq "workspace")
    {
        # Source is product_project_tree only

        foreach my $product (keys %to_copy)
        {
            foreach my $project_name (@{$to_copy{$product}->{names}})
            {
                if (!List::MoreUtils::any {$_->{name} eq $project_name} @{$self->{workspace_projects}})
                {
                    my $project;
                    if (!$self->get_project($project_name, \$project))
                    {
                        DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_name]);
                        next;
                    }

                    push(@{$self->{workspace_projects}}, $project);

                    if (!$self->save_workspace($self->{workspace_projects}))
                    {
                        Wx::MessageBox("Can't save workspace.", "", Wx::wxOK | Wx::wxICON_ERROR);
                    }
                }
            }
        }

        $self->fill_tree_workspace();

        $self->set_available_product_projects_color();
    }

    if ($target eq "runtime")
    {
        # Sources can be product_project_tree, external2 tree and runtime packs tree

        my @exclude; # Exclude when project is already in the workspace.

        foreach my $product_name (keys %to_copy)
        {
            foreach my $name (@{$to_copy{$product_name}->{names}})
            {
                if (List::MoreUtils::any {$_->{name} eq $name} @{$self->{product_runtime}})
                {
                    next;
                }

                if (List::MoreUtils::any {$_->{name} eq $name} @{$self->{workspace_projects}})
                {
                    push(@exclude, $name);
                    next;
                }

                my $product_version = $to_copy{$product_name}->{version};
                my $product_flavour = $to_copy{$product_name}->{flavour};

                my $product;

                if ($to_copy{$product_name}->{compliant})
                {
                    my $project;
                    if (!$self->get_project($name, \$project))
                    {
                        DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$name]);
                        next;
                    }

                    if ($project->{type} == 5)
                    {
                        Wx::MessageBox("Not relevant to include a static library into runtime dependencies.");
                    }
                    else
                    {
                        if ($project->{type} != 0)
                        {
                            # This project is aimed to be included as DPOProjectDependency
                            # in DPORuntimeProductCompliant::dpo_project_dependencies.
                            # DPOProjectDependency may have only these types:
                            #               <xs:enumeration value='0'/> <!-- executable -->
                            #               <xs:enumeration value='5'/> <!-- static library -->
                            #               <xs:enumeration value='6'/> <!-- dynamic library -->
                            #               <xs:enumeration value='8'/> <!-- determined by MPC with mpb  -->
                            # When we get a project (DPOProject), its type can be
                            #               <xs:enumeration value='7'/> <!-- static and dynamic library -->
                            # Thus we may have an incompatibility between DPOProjectDependency type
                            # and DPOProject 7.
                            # Since project type has no implication when a module is refered as runtime,
                            # we simply set its type as 6.
                            if ($project->{type} != 1)
                            {
                                $project->{type} = 6;
                            }
                        }

                        # Add product if not present
                        if (!List::MoreUtils::any {$_->{name} eq $product_name} @{$self->{this_product}->{runtime}->{runtime_products_compliant}})
                        {
                            my $new_product = DPORuntimeProductCompliant->new($product_name, $product_version, $product_flavour);
                            push(@{$self->{this_product}->{runtime}->{runtime_products_compliant}}, $new_product);
                            $product = $new_product;
                        }

                        if (!defined($product))
                        {
                            foreach my $p (@{$self->{this_product}->{runtime}->{runtime_products_compliant}})
                            {
                                if ($p->{name} eq $product_name)
                                {
                                    $product = $p;
                                }
                            }
                        }

                        if (!defined($product)) # not found (defensive)
                        {
                            next;
                        }

                        if (!List::MoreUtils::any {$_->{name} eq $name} @{$product->{dpo_project_dependencies}})
                        {
                            my $proj_dep = DPOProjectDependency->new($project->{name},
                                                                    $project->{version},
                                                                    $project->{target_version},
                                                                    $project->{type},
                                                                    $project->{dpo_compliant});
                            push(@{$product->{dpo_project_dependencies}}, $proj_dep);

                            if ($product->{version} eq $product_version
                                && $product->{flavour} eq $product_flavour)
                            {
                                my $flavour = "";
                                if ($product_flavour ne "")
                                {
                                    $flavour = "-$product_flavour";
                                }
                                push(@{$self->{runtime_products_to_select_in_tree}->{"$product_name-$product_version$flavour"}}, "$proj_dep->{name}-$proj_dep->{version}");
                            }

                        }
                    }
                }
                else
                {
                    # Add product if not present
                    if (!List::MoreUtils::any {$_->{name} eq $product_name} @{$self->{this_product}->{runtime}->{runtime_products_non_compliant}})
                    {
                        my $new_product = DPORuntimeProductNonCompliant->new($product_name, $product_version, $product_flavour);
                        push(@{$self->{this_product}->{runtime}->{runtime_products_non_compliant}}, $new_product);
                        $product = $new_product;
                    }

                    if (!defined($product))
                    {
                        foreach my $p (@{$self->{this_product}->{runtime}->{runtime_products_non_compliant}})
                        {
                            if ($p->{name} eq $product_name)
                            {
                                $product = $p;
                                last;
                            }
                        }
                    }

                    if (!defined($product)) # not found (defensive)
                    {
                        next;
                    }

                    if ($product->{name} eq $product_name)
                    {
                        if (!List::MoreUtils::any {$_ eq $name} @{$product->{modules_names}})
                        {
                            push(@{$product->{modules_names}}, $name);

                            if ($product->{version} eq $product_version
                                && $product->{flavour} eq $product_flavour)
                            {
                                my $flavour = "";
                                if ($product_flavour ne "")
                                {
                                    $flavour = "-$product_flavour";
                                }
                                push(@{$self->{runtime_products_to_select_in_tree}->{"$product_name-$product_version$flavour"}}, $name);
                            }
                        }
                    }
                }
            }
        }

        $self->load_runtime();
        $self->fill_tree_runtime();

        if (!$self->save_runtime())
        {
        }

        if (scalar(@exclude) != 0)
        {
            my $text = "These projects are in workspace projects and don't need to be included as runtime dependencies:\n";
            foreach my $x (@exclude)
            {
                $text .= "\n   - $x";
            }
            Wx::MessageBox($text);
        }
    }

    if ($target eq "runtime_in_workspace")
    {
        if ($ctrl_source != $self->{list_ctrl_product_projects})
        {
            return;
        }

        my @projects_to_add;

        foreach my $product_name (keys %to_copy)
        {
            my @projects;

            if ($to_copy{$product_name}->{compliant})
            {
                # Compliant product
                foreach my $project_name (@{$to_copy{$product_name}->{names}})
                {
                    if ($self->{working_project}
                        && $project_name eq $self->{working_project}->{name})
                    {
                        Wx::MessageBox("Not releveant to set $project_name as a dependency of itself.\n");
                        next
                    }

                    my $project;
                    if (!$self->get_project($project_name, \$project))
                    {
                        Wx::MessageBox("Failed to get project $project_name.", "", Wx::wxOK | Wx::wxICON_ERROR);
                        next;
                    }

                    if (!List::MoreUtils::any {$_->{name} eq $project->{name}} @{$self->{runtime_in_workspace}})
                    {
                        push(@{$self->{runtime_in_workspace}}, $project);
                    }
                }
            }
        }

        $self->fill_tree_runtime_in_workspace();

        $self->save_runtime_in_workspace();
    }

    if ($target eq "working_project")
    {
        if ($ctrl_source == $self->{tree_ctrl_runtime_pack})
        {
            return;
        }

        my @projects_to_add;

        foreach my $product_name (keys %to_copy)
        {
            my @projects;

            if ($to_copy{$product_name}->{compliant})
            {
                # Compliant product
                foreach my $project_name (@{$to_copy{$product_name}->{names}})
                {
                    if ($project_name eq $self->{working_project}->{name})
                    {
                        Wx::MessageBox("Not releveant to set $project_name as a dependency of itself.\n");
                        return;
                    }

                    my $wait = Wx::BusyCursor->new();

                    my $project = 0;
                    my $env_var_id = uc($project_name) . "_PRJ_ROOT";
                    my $path = "\$($env_var_id)";
                    if (DPOEnvVars::expand_env_var(\$path))
                    {
                        my $file = "$path/DPOProject.xml";
                        if (-e $file)
                        {
                            my $err;
                            my $config = DPOProjectConfig->new($file, \$err);
                            if ($config)
                            {
                                if (!$config->get_project(\$project))
                                {
                                    DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_name]);
                                    return;
                                }
                            }
                            else
                            {
                                DPOLog::report_msg(DPOEvents::LOAD_PROJECT_FAILURE, [$file, $err]);
                                return;
                            }
                        }
                        else
                        {
                            DPOLog::report_msg(DPOEvents::FILE_OPERATION_FAILURE, ["exist", $file, $!]);
                            return;
                        }
                    }
                    else
                    {
                        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$env_var_id]);
                        return;
                    }

                    push(@projects, $project);
                }
            }
            else
            {
                # Non compliant product

                my $product;
                if (!DPOProductConfig::get_product_with_name($product_name, \$product))
                {
                    Wx::MessageBox("Can't load product $product_name", "", Wx::wxOK | Wx::wxICON_ERROR);
                    return;
                }

                my @mpbs;
                if (!$self->select_mpbs_from_non_compliant_product($product, \@mpbs))
                {
                    DPOLog::report_msg(DPOEvents::GETTING_MPBS_FROM_NON_COMPLIANT_MODULES, [$product_name]);
                    next
                }

                foreach my $mpb (@mpbs)
                {
                    # Make project with mpb
                    my $dpo_compliant = DPOCompliant->new(0,
                                                        $product->{name},
                                                        $product->{flavour},
                                                        $mpb->{name},
                                                        $mpb->{mpc_includes});

                    my $project = DPOProject->new($mpb->{lib_id},
                                                $product->{version},
                                                $product->{version},
                                                4,
                                                $dpo_compliant); # type 4: determined next

                    # Determine if the project can be used as static/dynamic
                    my $type;
                    if ($product->get_lib_type($mpb->{lib_id}, \$type))
                    {
                        $project->{type} = $type;

                        # Add dependencies

                        if ($mpb->load_non_compliant_dependencies($product,
                                                                $project,
                                                                $self->{loaded_projects},
                                                                $self->{mpbs_scanned}))
                        {
                            push(@projects, $project);
                            if (!List::MoreUtils::any {$_->{name} eq $project->{name}} @{$self->{loaded_projects}})
                            {
                                push(@{$self->{loaded_projects}}, $project);
                            }
                        }
                        else
                        {
                            my $msg = "Can't get non compliant dependencies for $project->{name}";
                            DPOLog::report_msg(DPOEvents::GENERIC_ERROR, [$msg]);
                        }
                    }
                    else
                    {
                        DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Can't get lib type from $mpb->{lib_id} (doesn't exist)"]);
                    }
                }
            }

            foreach my $project (@projects)
            {
                # Check if project is executable
                if ($project->is_executable())
                {
                    my $rc = Wx::MessageBox(
                                "Here is a design issue.\n\n".
                                "It is not usual to include an executable ".
                                "($project->{name}) as build dependency (of ".
                                "$self->{working_project}->{name}).\n\n".
                                "If it is necessary to include stuff from ".
                                "executable, you should split it into parts ".
                                "in a way that it is possible to include ".
                                "those parts into executable and others in ".
                                "the same way.\n\n".
                                "The dependency elements used are headers and ".
                                "libraries. First, it does not make sense to ".
                                "link with an executable. Second, if you want ".
                                "to use headers from an executable it would ".
                                "be better to put headers somewhere else.\n\n".
                                "Do you still want to include $project->{name} to ".
                                "$self->{working_project}->{name} as ".
                                "executable build dependency?",
                                "Design issue",
                                Wx::wxYES_NO | Wx::wxICON_WARNING);

                    if ($rc == Wx::wxNO)
                    {
                        next;
                    }
                }

                if ($project->{type} == 4)
                {
                    Wx::MessageBox(
                                "$project->{name} type has not been determined yet.\n".
                                "You can't include it into $self->{working_project}->{name}.\n".
                                "You must build $project->{name}.",
                                "", Wx::wxOK | Wx::wxICON_ERROR);

                    next;
                }

                # Check for recursivity
                if ($self->recursivity($project, $self->{working_project}->{name}))
                {
                    Wx::MessageBox("Can't make $project->{name} a dependent of $self->{working_project}->{name} (recursivity)\n", "", Wx::wxOK | Wx::wxICON_ERROR);
                    next;
                }

                push(@projects_to_add, $project->clone);
            }
        }

        if (!$self->add_new_projects_to_working_one(\@projects_to_add))
        {
            return;
        }
    }

    $self->validate();
}

sub fill_to_copy_data
{
    my ($self, $tree_item, $to_copy, $selected_items_ref) = @_;

    my $runtime_product_item_text = $self->{tree_ctrl_runtime_pack}->GetItemText($tree_item);

    my $ok = 1;

    my $product_name;
    my $product_version;
    my $product_flavour;
    DPOProduct::params_from_id($runtime_product_item_text, \$product_name, \$product_version, \$product_flavour);

    if (!defined($to_copy->{$product_name}))
    {
        my $product;
        if (DPOProductConfig::get_product_with_name($product_name, \$product))
        {
            $to_copy->{$product_name} = ToCopy->new($product_version, $product_version, $product_flavour, $product->{dpo_compliant_product}->{value});
        }
        else
        {
            $ok = 0;
        }
    }

    if ($ok)
    {
        my ($module_child, $module_cookie) = $self->{tree_ctrl_runtime_pack}->GetFirstChild($tree_item);
        while ($module_child && $module_child->IsOk())
        {
            my $name = $self->{tree_ctrl_runtime_pack}->GetItemText($module_child);

            my $push = 1;
            if (defined($selected_items_ref))
            {
                if (!List::MoreUtils::any {$self->{tree_ctrl_runtime_pack}->GetItemText($_) eq $name} @{$selected_items_ref})
                {
                    $push = 0;
                }
            }

            if ($push)
            {
                if ($to_copy->{$product_name}->{compliant})
                {
                    my ($name_only) = $name =~ /(.*)-/;
                    push(@{$to_copy->{$product_name}->{names}}, $name_only);
                }
                else
                {
                    push(@{$to_copy->{$product_name}->{names}}, $name);
                }
            }

            ($module_child, $module_cookie) = $self->{tree_ctrl_runtime_pack}->GetNextChild($tree_item, $module_cookie);
        }
    }
}

sub select_mpbs_from_non_compliant_product
{
    my ($self, $product, $mpbs_ref) = @_;

    my $wait = Wx::BusyCursor->new();

    my @mpbs_to_use;
    my $dlg = DPOProductNonProductMPBDlg->new(
                    #~ \@mpbs,
                    $product->{dpo_compliant_product}->{non_compliant_lib_seq},
                    \@mpbs_to_use,
                    undef,
                    -1,
                    "",
                    Wx::wxDefaultPosition,
                    Wx::wxDefaultSize,
                    Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

    my $rc = $dlg->ShowModal();

    $dlg->Destroy();

    if ($rc == Wx::wxID_CANCEL)
    {
        return 1;
    }

    foreach my $mpb_name (@mpbs_to_use)
    {
        foreach my $non_compliant_lib (@{$product->{dpo_compliant_product}->{non_compliant_lib_seq}})
        {
            my @tokens = split(/;/, $non_compliant_lib->{mpb_name});
            if (scalar(@tokens) > 1)
            {
                my $found = 0;
                foreach my $token (@tokens)
                {
                    if ($token eq $mpb_name)
                    {
                        $found = 1;
                        my $dpo_mpb = DPOMpb->new($non_compliant_lib->{lib_id},
                                                    $mpb_name,
                                                    $product->{mpc_includes});
                        push(@$mpbs_ref, $dpo_mpb);
                        last;
                    }
                }
                if ($found)
                {
                    last;
                }
            }
            else
            {
                if ($non_compliant_lib->{mpb_name} eq $mpb_name)
                {
                    my $dpo_mpb = DPOMpb->new($non_compliant_lib->{lib_id},
                                                $mpb_name,
                                                $product->{mpc_includes});
                    push(@$mpbs_ref, $dpo_mpb);
                }
            }
        }
    }

    return 1;
}

sub recursivity
{
    my ($self, $target_project, $project_name) = @_;

    foreach my $dependency (@{$target_project->{dependencies_when_dynamic}}) # dynamic or static, it doesn't matter.
    {
        if ($dependency->{name} eq $project_name)
        {
            return 1;
        }
        else
        {
            if ($self->recursivity($dependency, $project_name))
            {
                return 1;
            }
        }
    }

    return 0;
}

sub get_updated_line
{
    my ($self, $line, $num, $updated_line) = @_;

    my @tokens = split(/[' ', '\t']/, $line);

    my @actual_tokens=();
    foreach(@tokens)
    {
        chomp($_);

        if ($_)
        {
            push(@actual_tokens, $_);
        }
    }

    $$updated_line = "$actual_tokens[0] $actual_tokens[1] $num\n";
}

sub save_arch_os_tool_chain
{
    my ($self) = @_;

    my $file = "$self->{workspace_path}/arch_os_toolchain";

    my $tmp_file = "arch_os_toolchain.tmp";
    if (open (OUT, ">$tmp_file"))
    {
        print OUT "arch=" . $self->{combo_box_arch}->GetValue() . "\n";
        print OUT "os=" . $self->{combo_box_os}->GetValue() . "\n";
        print OUT "toolchain=" . $self->{combo_box_toolchain}->GetValue() . "\n";

        close(OUT);

        if (!File::Copy::syscopy($tmp_file, $file))
        {
            Wx::MessageBox("Can't copy temporary file to arch_os_toolchain file.", "", Wx::wxOK | Wx::wxICON_ERROR);
        }

        unlink($tmp_file);

        $self->{workspace_arch} = $self->{combo_box_arch}->GetValue();
        $self->{workspace_os} = $self->{combo_box_os}->GetValue();
        $self->{workspace_toolchain} = $self->{combo_box_toolchain}->GetValue();
    }
    else
    {
        Wx::MessageBox("Can't open temporary file to save arch/os/toolchain.", "", Wx::wxOK | Wx::wxICON_ERROR);
    }

    if (!$self->validate())
    {
        return;
    }
}

sub browse_product
{
    my ($self) = @_;

    # DPO_CORE_ROOT env. var..
    my $init =  "\$(DPO_CORE_ROOT)";
    if (!DPOEnvVars::expand_env_var(\$init))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$init]);
        return;
    }
    $init .= "/scripts/tests"; # TO_DO: delete

    my $dlg = Wx::DirDialog->new($self, "DPO product", $init);
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();

        $path =~ s/\\/\//g;

        unless (-f "$path/DPOProduct.xml")
        {
            Wx::MessageBox("$path is not a product directory.", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }

        if (DPOUtils::in_dpo_pool($path))
        {
            Wx::MessageBox("You must select a local directory (not a pool directory).", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }

        my $config_product = DPOProductConfig->new("$path/DPOProduct.xml");
        if ($config_product)
        {
            my $product;
            $config_product->get_product(\$product);

            my ($product_path, $product_name) = $path =~ /(.*)\/($product->{name})/;
            $self->append_product_to_mru($product->{name}, $product_path);
            $self->fill_mru_products();
            $self->{combo_box_product}->SetValue($product->{name});

            if ($self->{last_product_name} ne $product->{name})
            {
                $self->enable_product_elements(0);
            }
            else
            {
                $self->enable_product_elements(1);
            }
        }
        else
        {
            Wx::MessageBox("No product in $path", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }


        my ($product_name) = $path =~ /.*\/(.*)/;
        my @listEnvVarValues;
        my $product_env_var = DPOEnvVar->new(uc($product_name) . "_ROOT", $path);
        push(@listEnvVarValues, $product_env_var);
        DPOEnvVars::system_set_env_vars(\@listEnvVarValues);

        return 1;
    }

    return 0;
}

sub close_product
{
    my ($self) = @_;

    $self->close_workspace();

    $self->{this_product} = 0;

    $self->{sizer_product_staticbox}->SetLabel("Product workspace/runtime");

    $self->{radio_btn_available_projects_dependants_of}->SetValue(0);
    $self->{combo_box_available_projects_dependants_of}->Clear();
    $self->{combo_box_available_projects_dependants_of}->SetValue("");
    $self->{list_ctrl_product_projects}->DeleteAllItems();

    $self->{product_runtime} = [];

    $self->{tree_ctrl_runtime}->DeleteAllItems();
    $self->{runtime_products_to_select_in_tree} = {};

    $self->{combo_box_workspaces}->Clear();
    $self->{combo_box_workspaces}->SetValue("");

    $self->{last_workspace_id} = "";

    $self->{tree_ctrl_external_modules}->DeleteAllItems();
    $self->{list_ctrl_product_projects}->DeleteAllItems();
    $self->{tree_ctrl_runtime_pack}->DeleteAllItems();

    $self->{last_product_name} = "";

    $self->enable_product_elements(0);
    $self->enable_runtime_elements(0);
    $self->enable_workspace_actions(0);

    $self->{combo_box_product}->SetValue("");

    $self->{tree_ctrl_external_modules}->DeleteAllItems();
    $self->{loaded_projects} = [];
}

sub add_a_recall
{
    my ($self, $recall_text) = @_;

    my $dpo_recall = DPORecall->new($recall_text, "new");
    push(@{$self->{recalls}}, $dpo_recall);

    $self->{button_recalls}->SetBackgroundColour(Wx::Colour->new(255, 255, 0));
}

sub add_non_compliant_dep
{
    my ($self, $target_project, $product, $dep_name, $mpb_name) = @_;

    my $mpb = DPOMpb->new($dep_name,
                            $mpb_name,
                            $product->{mpc_includes});

    # Make project dependency with mpb
    my $dpo_compliant = DPOCompliant->new(0,
                                        $product->{name},
                                        $product->{flavour},
                                        $mpb->{name},
                                        $mpb->{mpc_includes});

    my $project = DPOProject->new($mpb->{lib_id}, $product->{version}, $product->{version}, 4, $dpo_compliant); # type 4: determined next

    foreach my $dep (@{$target_project->{dependencies_when_dynamic}}, @{$target_project->{dependencies_when_static}})
    {
        if ($dep->{name} eq $project->{name})
        {
            return 1;
        }
    }

    my $type;
    if ($product->get_lib_type($mpb->{lib_id}, \$type))
    {
        $project->{type} = $type;

        # Add dependencies
        if ($mpb->load_non_compliant_dependencies($product,
                                                $project,
                                                $self->{loaded_projects},
                                                $self->{mpbs_scanned}))
        {
            my $dep_static = DPOProjectDependency->new($project->{name},
                                                    $project->{version},
                                                    $project->{target_version},
                                                    $project->{type},
                                                    $project->{dpo_compliant});
            $dep_static->{type} = 5;

            my $dep_dynamic= DPOProjectDependency->new($project->{name},
                                                    $project->{version},
                                                    $project->{target_version},
                                                    $project->{type},
                                                    $project->{dpo_compliant});
            $dep_dynamic->{type} = 6;

            # Add to target_project
            if ($type == 7)
            {
                push(@{$target_project->{dependencies_when_static}}, $dep_static);
                push(@{$target_project->{dependencies_when_dynamic}}, $dep_dynamic);
            }

            if ($type == 5)
            {
                push(@{$target_project->{dependencies_when_static}}, $dep_static);
                push(@{$target_project->{dependencies_when_dynamic}}, $dep_static);
            }

            if ($type == 6)
            {
                push(@{$target_project->{dependencies_when_static}}, $dep_static);
                push(@{$target_project->{dependencies_when_dynamic}}, $dep_dynamic);
            }

            if (!List::MoreUtils::any {$_->{name} eq $project->{name}} @{$self->{loaded_projects}})
            {
                push(@{$self->{loaded_projects}}, $project);
            }

            $self->save_working_project(0);
        }
        else
        {
            DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Can't get non compliant dependencies for $project->{name}"]);
            return 0;
        }
    }
    else
    {
        DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Can't get lib type from $mpb->{lib_id} (doesn't exist)"]);
        return 0;
    }

    return 1;
}

################################################################################
# A product has projects associated with it. This function gets ids of
# those projects.
# $path: the path from where we have to search for projects.
# $exclude_project: a project name to not consider.
# $product_projects_ids_ref: outcome - projects ids.
# $errors_ref: errors description if something wrong happened.
################################################################################
sub extract_product_projects_ids
{
    my ($self, $path, $exclude_project, $product_projects_ids_ref) = @_;

    my @dir_content;
    if (!DPOUtils::get_dir_content($path, \@dir_content))
    {
        DPOLog::report_msg(DPOEvents::GET_DIR_CONTENT_FAILURE, [$path]);
        return 0;
    }

    foreach my $content (@dir_content)
    {
        my $complete = "$path/$content";

        if (-d $complete
            && $content ne "."
            && $content ne ".."
            && $content ne ".git"
            && $content ne ".svn"
            && $content ne ".bzr")
        {
            if (-f "$complete/DPOProject.xml")
            {
                if (-e "$complete/NewProject_.*\.pm")
                {
                    # It's a template, not a real project.
                    next;
                }
                if ($content ne $exclude_project)
                {
                    my $dpo_project_xml = "$complete/DPOProject.xml";
                    if (-e $dpo_project_xml)
                    {
                        my $err;
                        my $config = DPOProjectConfig->new($dpo_project_xml, \$err);
                        if ($config)
                        {
                            my $project;
                            $config->get_project(\$project);
                            push(@$product_projects_ids_ref, "$project->{name}-$project->{version}");
                        }
                        else
                        {
                            DPOLog::report_msg(DPOEvents::GENERIC_ERROR, [$err]);
                            return 0;
                        }
                    }
                }
            }

            if (!$self->extract_product_projects_ids($complete, $exclude_project, $product_projects_ids_ref))
            {
                return 0;
            }
        }
    }

    return 1;
}

# product_project_path: to sort $self->{product_projects_paths}.
sub product_project_path
{
    my ($self, $product_project_path) = @_;

    my ($path, $project_name) = $product_project_path =~ /(.*)\/(.*)/;

    return $project_name;
}

sub extract_projects_of_product_with_version
{
    my ($self, $product_name, $product_version, $projects_ref) = @_;

    my $env_var_id = uc($product_name) . "_ROOT";
    my $path = "\$($env_var_id)";
    if (DPOEnvVars::expand_env_var(\$path))
    {
        if (DPOUtils::in_dpo_pool($path))
        {
            my $versions_log = "$path/dpo_versions.log";

            my @blocks;
            if (DPOUtils::get_versions_blocks($versions_log, \@blocks))
            {
                foreach my $block (@blocks)
                {
                    if ($block->{version} eq $product_version)
                    {
                        foreach my $project (@{$block->{projects}})
                        {
                            if ($project->{status} ne 'X')
                            {
                                my $proj;
                                if ($self->get_project($project->{project_name}, \$proj))
                                {
                                    push(@$projects_ref, $proj);
                                }
                                else
                                {
                                    DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project->{project_name}]);
                                    return 0;
                                }
                            }
                        }
                    }
                }
            }
        }
        else
        {
            my @projects_paths;
            if (!DPOUtils::get_projects_paths("$path/projects", \@projects_paths))
            {
                # TO_DO
                return 0;
            }

            foreach my $x (sort @projects_paths)
            {
                my ($project_name) = $x =~ /.*\/(.*)/;

                print DPOUtils::now_text(), "Loading $project_name...\n";

                my $project;
                if ($self->get_project($project_name, \$project))
                {
                    push(@$projects_ref, $project);
                }
                else
                {
                    DPOLog::report_msg(DPOEvents::GET_PROJECT_FAILURE, [$project_name]);
                    return 0;
                }
            }
        }
    }
    else
    {
        # TO_DO
        return 0;
    }

    return 1;
}



#### Eeeeeeeeevent handlers
sub on_combo_box_product
{
    my ($self, $event) = @_;

    my $new = $event->GetString();

    if ($self->{last_product_name} ne $new)
    {
        $self->enable_product_elements(0);
    }
    else
    {
        $self->enable_product_elements(1);
    }

    $self->{button_product_open}->SetFocus();

    return;

    # wxGlade: DPOPanelProduct::on_combo_box_product <event_handler>
    warn "Event handler (on_combo_box_product) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_product_browse
{
    my ($self, $event) = @_;

    $self->browse_product();

    # On some machines, the refresh is not done properly --> Show(0) + Show(1) fix the problem.
    $self->Show(0);
    $self->Show(1);

    return;

    # wxGlade: DPOPanelProduct::on_button_product_browse <event_handler>
    warn "Event handler (on_button_product_browse) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_product_open
{
    my ($self, $event) = @_;

    my $product_name = $self->{combo_box_product}->GetValue();

    if ($product_name eq "")
    {
        Wx::MessageBox("You must select a product", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    if (!DPOUtils::valid_input($product_name))
    {
        Wx::MessageBox("Invalid character in $product_name", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    if ($product_name eq $self->{last_product_name})
    {
        my $rc = Wx::MessageBox(
                    "$product_name is already open.\n\n".
                    "Reopen?",
                    "",
                    Wx::wxYES_NO | Wx::wxICON_QUESTION);
        if ($rc == Wx::wxNO)
        {
            return;
        }
    }

    my $ok = 1;
    my $env_var_id = uc($product_name) . "_ROOT";
    my $path = "\$($env_var_id)";
    if (!DPOEnvVars::expand_env_var(\$path))
    {
        my $rc = Wx::MessageBox("$product_name seems to not exist\n".
                        "or maybe $env_var_id is defined as a pool product.\n\n".
                        "If $product_name exists as local product (maybe you need to get it from an SCM), you can browse for it with the related browse button.\n\n" .
                        "If it doesn't exist as local product, you can create it now.\n\n" .
                        "Do you want to create it now?",
                        "Product selection",
                        Wx::wxYES_NO | Wx::wxICON_QUESTION);
        if ($rc == Wx::wxYES)
        {
            my $dlg = DPONewCompliantProductDlg->new(
                undef,
                -1,
                "",
                Wx::wxDefaultPosition,
                Wx::wxDefaultSize,
                Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

            $dlg->{text_ctrl_product_name}->SetValue($product_name);

            if ($dlg->ShowModal() == Wx::wxID_OK)
            {
                $path = $dlg->{text_ctrl_parent_directory}->GetValue();

                my $product_name = $dlg->{text_ctrl_product_name}->GetValue();
                $self->append_product_to_mru($product_name, $dlg->{text_ctrl_parent_directory}->GetValue());
            }
            else
            {
                $ok = 0;
            }

            $dlg->Destroy();
        }
        else
        {
            $self->{combo_box_product}->SetValue("");
            #~ DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$env_var_id]);
            return;
        }
    }

    if ($ok)
    {
        if (DPOUtils::in_dpo_pool($path))
        {
            my $rc = Wx::MessageBox("$product_name is set to a pool directory.\n\n" .
                            "Do you want to browse for a local dictrectory ?",
                            "Product selection",
                            Wx::wxYES_NO | Wx::wxICON_QUESTION);
            if ($rc == Wx::wxYES)
            {
                if (!$self->browse_product())
                {
                    return;
                }
            }
            else
            {
                return;
            }
        }

        $self->fill_mru_products();
        $self->{combo_box_product}->SetValue($product_name);
        if (!$self->open_product($product_name))
        {
            $self->disable_product_actions();
            $self->enable_product_elements(0);
            return;
        }
    }

    # On some machines, the refresh is not done properly --> Show(0) + Show(1) fix the problem.
    $self->Show(0);
    $self->Show(1);

    return;

    # wxGlade: DPOPanelProduct::on_button_product_open <event_handler>
    warn "Event handler (on_button_product_open) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_radio_btn_all_product_projects
{
    my ($self, $event) = @_;

    $self->{combo_box_available_projects_dependants_of}->SetValue("");
    $self->{combo_box_available_projects_dependants_of}->Enable(0);
    $self->{button_available_projects_dependants_of}->Enable(0);

    return;

    # wxGlade: DPOPanelProduct::on_radio_btn_all_product_projects <event_handler>
    warn "Event handler (on_radio_btn_all_product_projects) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_radio_btn_dependants_of
{
    my ($self, $event) = @_;

    $self->{combo_box_available_projects_dependants_of}->Enable(1);
    $self->{button_available_projects_dependants_of}->Enable(1);

    $self->{combo_box_available_projects_dependants_of}->Clear();

    my $wait = Wx::BusyCursor->new();

    my $sub_path = "projects";
    if (DPOUtils::in_dpo_pool($self->{this_product}->{path}))
    {
        $sub_path = "../modules";
    }
    my @product_projects_ids;
    my $exclude_project = "";
    if (!$self->extract_product_projects_ids("$self->{this_product}->{path}/$sub_path", $exclude_project, \@product_projects_ids))
    {
        return;
    }

    foreach my $project_id (sort @product_projects_ids)
    {
        $self->{combo_box_available_projects_dependants_of}->Append($project_id);
    }

    return;

    # wxGlade: DPOPanelProduct::on_radio_btn_dependants_of <event_handler>
    warn "Event handler (on_radio_btn_dependants_of) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_available_projects_dependants_of
{
    my ($self, $event) = @_;

    my $dlg = Wx::DirDialog->new($self, "Select the project", $self->{this_product}->{path});
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $path = $dlg->GetPath();
        $path =~ s/\\/\//g;

        my $project_name;
        my $flavour;
        my $version;
        if (DPOUtils::in_dpo_pool($path))
        {
            if (-e "$path/DPOProject.xml") # Compliant
            {
                ($project_name, $version) = $path =~ /.*\/(.*)\/(\d+.\d+.\d+)$/;
                $self->{tree_ctrl_working_project_dynamic}->DeleteAllItems();
                $self->{tree_ctrl_working_project_static}->DeleteAllItems();
                $self->{combo_box_available_projects_dependants_of}->SetValue("$project_name-$version");
            }
            else # Not compliant
            {
                if (-e "$path/DPOProduct.xml")
                {
                    my ($product_name, $flavour, $version) = $path =~ /.*\/(.*)\/(.*)\/(\d+.\d+.\d+)$/;

                    # Lire DPOProduct.xml

                    my $product;
                    if (DPOProductConfig::get_product_with_name($product_name, \$product))
                    {
                        if (scalar(@{$product->{dpo_compliant_product}->{non_compliant_lib_seq}}) != 0)
                        {
                            my @lib_ids;
                            foreach my $non_compliant_lib (@{$product->{dpo_compliant_product}->{non_compliant_lib_seq}})
                            {
                                #~ print "NNN - $non_compliant_lib->{lib_id}\n";
                                push(@lib_ids, $non_compliant_lib->{lib_id});
                            }

                            my $dlg = DPOProductNonCompliantLibsDlg->new(
                                            \@lib_ids,
                                            undef,
                                            -1,
                                            "",
                                            Wx::wxDefaultPosition,
                                            Wx::wxDefaultSize,
                                            Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

                            $dlg->{text_ctrl_product}->SetValue($product_name);

                            my $rc = $dlg->ShowModal();
                            if ($rc == Wx::wxID_OK)
                            {
                                $self->{tree_ctrl_working_project_dynamic}->DeleteAllItems();
                                $self->{tree_ctrl_working_project_static}->DeleteAllItems();
                                $self->{combo_box_available_projects_dependants_of}->SetValue("$dlg->{selected_lib_id}-$version");
                            }

                            $dlg->Destroy();
                        }
                    }
                    else
                    {
                        Wx::MessageBox("Can't get product from $path/DPOProduct.xml");
                        return;
                    }
                }
                else
                {
                    Wx::MessageBox("Not a project/product");
                    return;
                }
            }
        }
        else
        {
            if (-e "$path/DPOProject.xml")  # Compliant
            {
                ($project_name) = $path =~ /.*\/(.*)$/;
                my $major;
                my $minor;
                my $patch;
                if (DPOUtils::read_project_version($path, \$major, \$minor, \$patch))
                {
                    $version = "$major.$minor.$patch";
                }

                $self->{tree_ctrl_working_project_dynamic}->DeleteAllItems();
                $self->{tree_ctrl_working_project_static}->DeleteAllItems();
                $self->{combo_box_available_projects_dependants_of}->SetValue("$project_name-$version");
            }
            else
            {
                Wx::MessageBox("Not a project");
            }
        }
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_available_projects_dependants_of <event_handler>
    warn "Event handler (on_button_available_projects_dependants_of) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_product_projects_get
{
    my ($self, $event) = @_;

    if ($self->fill_product_projects())
    {
        $self->set_available_product_projects_color();
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_product_projects_get <event_handler>
    warn "Event handler (on_button_product_projects_get) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_product_projects_begin_drag
{
    my ($self, $event) = @_;

    my $text_obj = Wx::TextDataObject->new("list_ctrl_product_projects");

    my $source = Wx::DropSource->new($self->{list_ctrl_product_projects});
    $source->SetData($text_obj);

    my $drop_result = $source->DoDragDrop();

    return;

    # wxGlade: DPOPanelProduct::on_list_ctrl_product_projects_begin_drag <event_handler>
    warn "Event handler (on_list_ctrl_product_projects_begin_drag) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_project_new
{
    my ($self, $event) = @_;

    if ($self->{workspace_path} eq "")
    {
        Wx::MessageBox("No workspace opened.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    my $dlg = DPOProductNewProjectDlg->new(
                    $self,
                    undef,
                    -1,
                    "",
                    Wx::wxDefaultPosition,
                    Wx::wxDefaultSize,
                    Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

    if ($dlg->ShowModal() == Wx::wxID_OK
        && $dlg->{project_created})
    {
        if ($dlg->{project_name} ne ""
            && $dlg->{parent_dir} ne "")
        {
            my $wait = Wx::BusyCursor->new();

            if (!$self->fill_product_projects()) # refresh product projects
            {
                $dlg->Destroy();
                return;
            }

            if (!$self->fill_non_product_projects()) # refresh non-product projects
            {
                $dlg->Destroy();
                return;
            }
        }

        if (defined($self->{workspace_name})
            && $self->{workspace_name} ne "")
        {
            $self->validate();
        }
    }

    $dlg->Destroy();

    return;

    # wxGlade: DPOPanelProduct::on_button_project_new <event_handler>
    warn "Event handler (on_button_project_new) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_external_modules_begin_drag
{
    my ($self, $event) = @_;

    my $item = $event->GetItem();
    my $root_item = $self->{tree_ctrl_external_modules}->GetRootItem();

    my $item_text = $self->{tree_ctrl_external_modules}->GetItemText($item);
    my $parent = $self->{tree_ctrl_external_modules}->GetItemParent($item);

    if ($parent == $root_item)
    {
        my $text_obj = Wx::TextDataObject->new("tree_ctrl_external_modules");

        my $source = Wx::DropSource->new($self->{tree_ctrl_external_modules});
        $source->SetData($text_obj);

        my $drop_result = $source->DoDragDrop();
    }
    else
    {
        # Module from non compliant project
        my $text_obj = Wx::TextDataObject->new("tree_ctrl_external_modules");

        my $source = Wx::DropSource->new($self->{tree_ctrl_external_modules});
        $source->SetData($text_obj);

        my $drop_result = $source->DoDragDrop();
    }

    return;

    # wxGlade: DPOPanelProduct::on_tree_ctrl_external_modules_begin_drag <event_handler>
    warn "Event handler (on_tree_ctrl_external_modules_begin_drag) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_external2_expanding
{
    my ($self, $event) = @_;

    my $item = $event->GetItem();
    my $item_text = $self->{tree_ctrl_external_modules}->GetItemText($item);

    $self->{tree_ctrl_external_modules}->DeleteChildren($item);

    my $product_name;
    my $product_version;
    my $product_flavour;
    DPOProduct::params_from_id($item_text, \$product_name, \$product_version, \$product_flavour);

    my $product;
    if (DPOProductConfig::get_product_with_name($product_name, \$product))
    {
        if ($product->{dpo_compliant_product}->{value})
        {
            my @projects;
            if ($self->extract_projects_of_product_with_version($product_name, $product_version, \@projects))
            {
                foreach my $project (@projects)
                {
                    my $new_item = $self->{tree_ctrl_external_modules}->AppendItem($item, "$project->{name}-$project->{version}");

                    my $plugin_exec_none;
                    if (DPOUtils::check_for_plugin_exec($project->{name}, \$plugin_exec_none))
                    {
                        if ($plugin_exec_none eq "plugin")
                        {
                            $self->{tree_ctrl_external_modules}->SetItemBackgroundColour($new_item, Wx::Colour->new(128, 255, 128));
                        }
                        else
                        {
                            if ($plugin_exec_none eq "executable")
                            {
                                $self->{tree_ctrl_external_modules}->SetItemBackgroundColour($new_item, Wx::Colour->new(128, 255, 255));
                            }
                        }
                    }
                    else
                    {
                        $self->{tree_ctrl_external_modules}->SetItemBackgroundColour($new_item, Wx::Colour->new(255, 0, 0));
                    }
                }
            }
            else
            {
                # TO_DO
                return;
            }
        }
        else
        {
            my $wait = Wx::BusyCursor->new();

            my $env_var_id = uc($product_name) . "_ROOT";
            my $path = "\$($env_var_id)";
            if (!DPOEnvVars::expand_env_var(\$path))
            {
                DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$env_var_id]);
                return;
            }

            if (!defined($self->{non_compliant_modules}->{$product_name})
                || scalar(@{$self->{non_compliant_modules}->{$product_name}}) == 0)
            {
                $product->get_exec($path, \@{$self->{non_compliant_modules}->{$product_name}});
            }

            foreach my $e (@{$self->{non_compliant_modules}->{$product_name}})
            {
                my ($name) = $e =~ /.*\/(.*)/;
                my $new_item = $self->{tree_ctrl_external_modules}->AppendItem($item, $name);
                $self->{tree_ctrl_external_modules}->SetItemBackgroundColour($new_item, Wx::Colour->new(255, 176, 98));

                foreach my $non_compliant_lib (@{$product->{dpo_compliant_product}->{non_compliant_lib_seq}})
                {
                    my ($name_with_no_ext) = $name =~ /(.*)\..*/;
                    if ($non_compliant_lib->{lib_id} eq $name_with_no_ext
                        || $non_compliant_lib->{lib_id} . "d" eq $name_with_no_ext)
                    {
                        if ($non_compliant_lib->{plugin})
                        {
                            $self->{tree_ctrl_external_modules}->SetItemBackgroundColour($new_item, Wx::Colour->new(128, 255, 128));
                        }
                    }
                }
            }
        }
    }
    else
    {
        Wx::MessageBox("Can't open product $product_name", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    return;

    # wxGlade: DPOPanelProduct::on_tree_ctrl_external2_expanding <event_handler>
    warn "Event handler (on_tree_ctrl_external2_expanding) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_ctrl_runtime_pack_begin_drag
{
    my ($self, $event) = @_;

    my $text_obj = Wx::TextDataObject->new("tree_ctrl_runtime_pack");

    my $source = Wx::DropSource->new($self->{tree_ctrl_runtime_pack});
    $source->SetData($text_obj);

    my $drop_result = $source->DoDragDrop();

    return;

    # wxGlade: DPOPanelProduct::on_tree_ctrl_runtime_pack_begin_drag <event_handler>
    warn "Event handler (on_tree_ctrl_runtime_pack_begin_drag) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_runtime_pack_expand
{
    my ($self, $event) = @_;

    if ($self->{button_runtime_pack_expand}->GetLabel() eq "+")
    {
        $self->expand_runtime_pack(1);
        $self->{button_runtime_pack_expand}->SetLabel("-");
    }
    else
    {
        $self->expand_runtime_pack(0);
        $self->{button_runtime_pack_expand}->SetLabel("+");
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_runtime_pack_expand <event_handler>
    warn "Event handler (on_button_runtime_pack_expand) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_combo_box_workspaces
{
    my ($self, $event) = @_;

    my $new = $event->GetString();

    $self->enable_workspace_actions(1);

    if ($self->{last_workspace_id} ne $new)
    {
        $self->enable_workspace_elements(0);
        $self->enable_working_project_elements(0);
        $self->enable_actions_elements(0);
    }
    else
    {
        $self->enable_workspace_elements(1);
        $self->enable_working_project_elements(1);
        $self->enable_actions_elements(1);
    }

    $self->{button_workspace_open}->SetFocus();

    return;

    # wxGlade: DPOPanelProduct::on_combo_box_workspaces <event_handler>
    warn "Event handler (on_combo_box_workspaces) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_workspace_open
{
    my ($self, $event) = @_;

    $self->open_workspace();

    return;

    # wxGlade: DPOPanelProduct::on_button_workspace_open <event_handler>
    warn "Event handler (on_button_workspace_open) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_workspace_projects_activated
{
    my ($self, $event) = @_;

    $self->load_working_project();

    return;

    # wxGlade: DPOPanelProduct::on_tree_workspace_projects_activated <event_handler>
    warn "Event handler (on_tree_workspace_projects_activated) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_workspace_projects_keydown
{
    my ($self, $event) = @_;

    my $key_code = $event->GetKeyCode();

    if ($key_code == WXK_DELETE)
    {
        if ($self->remove_from_workspace())
        {
            $self->validate();
        }
    }

    if ($key_code == WXK_RETURN)
    {
        $self->load_working_project();
        $self->validate();
    }

    return;

    # wxGlade: DPOPanelProduct::on_tree_workspace_projects_keydown <event_handler>
    warn "Event handler (on_tree_workspace_projects_keydown) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_text_target_version
{
    my ($self, $event) = @_;

    my $dlg = DPOProductVersionDlg->new(
                    $self->{working_project}->{target_version},
                    $event->GetString(),
                    undef,
                    -1,
                    "",
                    Wx::wxDefaultPosition,
                    Wx::wxDefaultSize,
                    Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

    if ($dlg->ShowModal() == Wx::wxID_OK)
    {
        my $target_version = $dlg->{text_ctrl_new_version}->GetValue();

        my ($major, $minor, $patch) = $target_version =~ /(\d+)\.(\d+)\.(\d+)/;
        my ($prev_major,
            $prev_minor,
            $prev_patch) = $self->{working_project}->{version} =~ /(\d+)\.(\d+)\.(\d+)/;
        if ($patch < $prev_patch)
        {
            if ($minor <= $prev_minor)
            {
                if ($major <= $prev_major)
                {
                    $self->{text_ctrl_working_project_target_version}->ChangeValue($self->{working_project}->{target_version});
                    my $msg = "New version ($target_version) can't be smaller than the current version ($self->{working_project}->{version}).";
                    Wx::MessageBox($msg, "", Wx::wxOK | Wx::wxICON_ERROR);
                    $dlg->Destroy();
                    return;
                }
            }
        }

        $self->{text_ctrl_working_project_target_version}->ChangeValue($target_version);
        $self->{working_project}->{target_version} = $target_version;

        if ($self->save_working_project(1))
        {
            $self->validate();
        }
    }
    else
    {
        $self->{text_ctrl_working_project_target_version}->ChangeValue($self->{working_project}->{target_version});
    }

    $dlg->Destroy();

    return;

    # wxGlade: DPOPanelProduct::on_text_target_version <event_handler>
    warn "Event handler (on_text_target_version) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_checkbox_dynamic
{
    my ($self, $event) = @_;

    $self->checkbox_dynamic_static("dynamic");

    $self->validate();

    return;

    # wxGlade: DPOPanelProduct::on_checkbox_dynamic <event_handler>
    warn "Event handler (on_checkbox_dynamic) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_checkbox_static
{
    my ($self, $event) = @_;

    $self->checkbox_dynamic_static("static");

    $self->validate();

    return;

    # wxGlade: DPOPanelProduct::on_checkbox_static <event_handler>
    warn "Event handler (on_checkbox_static) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_working_project_dynamic_keydown
{
    my ($self, $event) = @_;

    $self->tree_working_project_dynamic_keydown($event, "dynamic", $self->{tree_ctrl_working_project_dynamic});

    $self->validate();

    return;

    # wxGlade: DPOPanelProduct::on_tree_working_project_dynamic_keydown <event_handler>
    warn "Event handler (on_tree_working_project_dynamic_keydown) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_working_project_static_keydown
{
    my ($self, $event) = @_;

    $self->tree_working_project_dynamic_keydown($event, "static", $self->{tree_ctrl_working_project_static});

    $self->validate();

    return;

    # wxGlade: DPOPanelProduct::on_tree_working_project_static_keydown <event_handler>
    warn "Event handler (on_tree_working_project_static_keydown) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_working_project_expand
{
    my ($self, $event) = @_;

    if ($self->{button_working_project_expand}->GetLabel() eq "+")
    {
        $self->expand_working_project(1);
        $self->{button_working_project_expand}->SetLabel("-");
    }
    else
    {
        $self->expand_working_project(0);
        $self->{button_working_project_expand}->SetLabel("+");
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_working_project_expand <event_handler>
    warn "Event handler (on_button_working_project_expand) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_workspace_projects_expand
{
    my ($self, $event) = @_;

    if ($self->{button_workspace_projects_expand}->GetLabel() eq "+")
    {
        $self->expand_workspace_projects(1);
        $self->{button_workspace_projects_expand}->SetLabel("-");
    }
    else
    {
        $self->expand_workspace_projects(0);
        $self->{button_workspace_projects_expand}->SetLabel("+");
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_workspace_projects_expand <event_handler>
    warn "Event handler (on_button_workspace_projects_expand) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_versions
{
    my ($self, $event) = @_;

    my $dlg = DPOProductWorkspaceProjectsVersionsDlg->new(
                    $self,
                    undef,
                    -1,
                    "",
                    Wx::wxDefaultPosition,
                    Wx::wxDefaultSize,
                    Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

    my $rc = $dlg->ShowModal();

    $dlg->Destroy();

    if ($rc == Wx::wxID_OK)
    {
        my $wait = Wx::BusyCursor->new();

        foreach my $project (@{$self->{workspace_projects}})
        {
            foreach my $project_to_change (@{$dlg->{projects_to_change}})
            {
                if ($project_to_change->{project_name} eq $project->{name})
                {
                    print "Changing $project_to_change->{project_name} in workspace...\n";
                    $project->{target_version} = $project_to_change->{new_target_version};
                    if ($self->update_workspace_projects($project))
                    {
                        if (!$self->update_header_version_file($project))
                        {
                            return;
                        }

                        if ($project == $self->{working_project})
                        {
                            $self->{text_ctrl_working_project_target_version}->ChangeValue($project->{target_version});
                        }
                    }
                    else
                    {
                        DPOLog::report_msg(DPOEvents::UPDATE_WORKSPACE_PROJECTS_FAILURE, [$project->{name}]);
                    }
                }
            }
        }

        $self->fill_product_projects();
        $self->fill_tree_workspace();
        $self->fill_tree_runtime();
        if ($self->{working_project})
        {
            $self->fill_tree_working();
        }

        $self->validate();
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_versions <event_handler>
    warn "Event handler (on_button_versions) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_tree_runtime_keydown
{
    my ($self, $event) = @_;

    my @selections = $self->{tree_ctrl_runtime}->GetSelections();

    if (scalar(@selections) == 0)
    {
        return;
    }

    my $key_code = $event->GetKeyCode();

    if ($key_code == Wx::WXK_DELETE)
    {
        $self->get_runtime_dependencies_to_remove();
        if ($self->remove_module_from_runtime())
        {
            $self->validate();
        }
    }

    return;

    # wxGlade: DPOPanelProduct::on_tree_runtime_keydown <event_handler>
    warn "Event handler (on_tree_runtime_keydown) not implemented";
    $event->Skip;
    # end wxGlade
}


sub tree_ctrl_runtime_in_workspace_keydown
{
    my ($self, $event) = @_;

    my @selections = $self->{tree_ctrl_runtime_in_workspace}->GetSelections();

    if (scalar(@selections) == 0)
    {
        return;
    }

    my $key_code = $event->GetKeyCode();

    if ($key_code == Wx::WXK_DELETE)
    {
        if ($self->remove_from_runtime_in_modules())
        {
            $self->validate();
        }
    }

    return;

    # wxGlade: DPOPanelProduct::tree_ctrl_runtime_in_workspace_keydown <event_handler>
    warn "Event handler (tree_ctrl_runtime_in_workspace_keydown) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_runtime_expand
{
    my ($self, $event) = @_;

    if ($self->{button_runtime_expand}->GetLabel() eq "+")
    {
        $self->expand_runtime(1);
        $self->{button_runtime_expand}->SetLabel("-");
    }
    else
    {
        $self->expand_runtime(0);
        $self->{button_runtime_expand}->SetLabel("+");
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_runtime_expand <event_handler>
    warn "Event handler (on_button_runtime_expand) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_runtime_pack
{
    my ($self, $event) = @_;

    Wx::MessageBox("Not implemented yet");

    return;

    # wxGlade: DPOPanelProduct::on_runtime_pack <event_handler>
    warn "Event handler (on_runtime_pack) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_expand_all
{
    my ($self, $event) = @_;

    my $expand = 1;
    my $sign = "-";
    my $sign_all = $self->{button_expand_all}->GetLabel();

    if ($sign_all eq "-")
    {
        $expand = 0;
        $sign = "+";
        $sign_all = "+";
    }
    else
    {
        $sign_all = "-";
    }

    $self->{button_expand_all}->SetLabel($sign_all);

    $self->expand_workspace_projects($expand);
    $self->{button_workspace_projects_expand}->SetLabel($sign);

    $self->expand_runtime($expand);
    $self->{button_runtime_expand}->SetLabel($sign);

    $self->expand_working_project($expand);
    $self->{button_working_project_expand}->SetLabel($sign);

    return;

    # wxGlade: DPOPanelProduct::on_button_expand_all <event_handler>
    warn "Event handler (on_button_expand_all) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_highlight
{
    my ($self, $event) = @_;

    $self->highlight();

    return;

    # wxGlade: DPOPanelProduct::on_button_highlight <event_handler>
    warn "Event handler (on_button_highlight) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_combobox_arch
{
    my ($self, $event) = @_;

    $self->save_arch_os_tool_chain();

    return;

    # wxGlade: DPOPanelProduct::on_combobox_arch <event_handler>
    warn "Event handler (on_combobox_arch) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_combobox_os
{
    my ($self, $event) = @_;

    $self->save_arch_os_tool_chain();

    return;

    # wxGlade: DPOPanelProduct::on_combobox_os <event_handler>
    warn "Event handler (on_combobox_os) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_combobox_toolchain
{
    my ($self, $event) = @_;

    $self->save_arch_os_tool_chain();

    $self->{combo_box_toolchain}->SetBackgroundColour(Wx::Colour->new(255, 255, 255));

    if (uc($self->{combo_box_toolchain}->GetValue()) =~ /^VC/)
    {
        $self->{button_ide}->Enable(1);
    }

    return;

    # wxGlade: DPOPanelProduct::on_combobox_toolchain <event_handler>
    warn "Event handler (on_combobox_toolchain) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_generate
{
    my ($self, $event) = @_;

    if ($self->{checkbox_generate}->GetValue())
    {
        $self->{checkbox_validate}->Enable(0);
        $self->{checkbox_fetch_runtime}->Enable(1);
        $self->{checkbox_set_env_vars}->Enable(0);
        $self->{checkbox_freeze}->Enable(0);
        $self->{checkbox_fix}->Enable(0);
        $self->{checkbox_cleanup}->Enable(0);

        $self->{checkbox_validate}->SetValue(1);
        $self->{checkbox_fetch_runtime}->SetValue(1);
        $self->{checkbox_set_env_vars}->SetValue(1);
        $self->{checkbox_freeze}->SetValue(0);
        $self->{checkbox_fix}->SetValue(0);
        $self->{checkbox_cleanup}->SetValue(0);
    }
    else
    {
        $self->{checkbox_validate}->Enable(1);
        $self->{checkbox_fetch_runtime}->Enable(1);
        $self->{checkbox_set_env_vars}->Enable(1);
        $self->{checkbox_freeze}->Enable(1);
        $self->{checkbox_fix}->Enable(1);
        $self->{checkbox_cleanup}->Enable(1);

        $self->{checkbox_validate}->SetValue(0);
        $self->{checkbox_fetch_runtime}->SetValue(0);
        $self->{checkbox_set_env_vars}->SetValue(0);
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_generate <event_handler>
    warn "Event handler (on_button_generate) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_freeze
{
    my ($self, $event) = @_;

    if ($self->{checkbox_freeze}->GetValue())
    {
        $self->{checkbox_generate}->Enable(0);
        $self->{checkbox_validate}->Enable(0);
        $self->{checkbox_fetch_runtime}->Enable(0);
        $self->{checkbox_set_env_vars}->Enable(0);
        $self->{checkbox_fix}->Enable(0);
        $self->{checkbox_cleanup}->Enable(0);

        $self->{checkbox_validate}->SetValue(1);
        $self->{checkbox_fetch_runtime}->SetValue(0);
        $self->{checkbox_set_env_vars}->SetValue(0);
        $self->{checkbox_fix}->SetValue(0);
        $self->{checkbox_cleanup}->SetValue(0);
    }
    else
    {
        $self->{checkbox_generate}->Enable(1);
        $self->{checkbox_validate}->Enable(1);
        $self->{checkbox_fetch_runtime}->Enable(1);
        $self->{checkbox_set_env_vars}->Enable(1);
        $self->{checkbox_fix}->Enable(1);
        $self->{checkbox_cleanup}->Enable(1);

        $self->{checkbox_validate}->SetValue(0);
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_freeze <event_handler>
    warn "Event handler (on_button_freeze) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_fix
{
    my ($self, $event) = @_;

    if ($self->{checkbox_fix}->GetValue())
    {
        $self->{checkbox_generate}->Enable(0);
        $self->{checkbox_validate}->Enable(0);
        $self->{checkbox_fetch_runtime}->Enable(0);
        $self->{checkbox_set_env_vars}->Enable(0);
        $self->{checkbox_freeze}->Enable(0);
        $self->{checkbox_cleanup}->Enable(0);

        $self->{checkbox_validate}->SetValue(0);
        $self->{checkbox_fetch_runtime}->SetValue(0);
        $self->{checkbox_set_env_vars}->SetValue(0);
    }
    else
    {
        $self->{checkbox_generate}->Enable(1);
        $self->{checkbox_validate}->Enable(1);
        $self->{checkbox_fetch_runtime}->Enable(1);
        $self->{checkbox_set_env_vars}->Enable(1);
        $self->{checkbox_freeze}->Enable(1);
        $self->{checkbox_cleanup}->Enable(1);
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_fix <event_handler>
    warn "Event handler (on_button_fix) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_action
{
    my ($self, $event) = @_;

    my $validate = $self->{checkbox_validate}->GetValue() * DPOActions::ACTION_VALIDATE;
    my $set_env_vars = $self->{checkbox_set_env_vars}->GetValue() * DPOActions::ACTION_ENV_VARS;
    my $fetch_runtime = $self->{checkbox_fetch_runtime}->GetValue() * DPOActions::ACTION_FETCH;
    my $generate = $self->{checkbox_generate}->GetValue() * DPOActions::ACTION_GENERATE;
    my $freeze = $self->{checkbox_freeze}->GetValue() * DPOActions::ACTION_FREEZE;
    my $fix = $self->{checkbox_fix}->GetValue() * DPOActions::ACTION_FIX;
    my $cleanup = $self->{checkbox_cleanup}->GetValue() * DPOActions::ACTION_CLEANUP;

    my $action_wanted = $validate +
                        $set_env_vars +
                        $fetch_runtime +
                        $generate +
                        $freeze +
                        $fix +
                        $cleanup;

    my $actions = DPOActions->new(
                        $action_wanted,
                        $self);

    my $rc = $actions->go();
    if ($self->{this_product} != 0) # Freeze closes product.
    {
        $self->fill_tree_workspace();
        $self->fill_tree_runtime();
        if ($self->{working_project})
        {
            $self->fill_tree_working();
        }

        #~ # Since, 'freeze' can be part of actions and that freeze, when it is successful, update
        #~ # the version of the project with the target_version, we want to reflect this change
        #~ # in the interface.
        #~ # Update version of the working project
        #~ if ($self->{working_project})
        #~ {
            #~ $self->{text_ctrl_working_project_current_version}->SetValue($self->{working_project}->{version});
        #~ }
    }

    if ($rc)
    {
        my $toolchain = $self->{combo_box_toolchain}->GetValue();
        if ($toolchain ne "")
        {
            if (uc($toolchain) =~ /^VC/)
            {
                $self->{button_ide}->Enable(1);
            }
        }
    }

    # save...

    return;

    # wxGlade: DPOPanelProduct::on_button_action <event_handler>
    warn "Event handler (on_button_action) not implemented";
    $event->Skip;
    # end wxGlade
}

sub on_tree_ctrl_working_project_dynamic_menu
{
    my ($self, $event) = @_;

    if ($self->{working_project} != 0)
    {
        $self->prepare_actions_on_working_project_tree("dynamic", $event, 1);

        $self->validate();
    }
}

sub on_tree_ctrl_working_project_static_menu
{
    my ($self, $event) = @_;

    if ($self->{working_project} != 0)
    {
        $self->prepare_actions_on_working_project_tree("static", $event, 1);

        $self->validate();
    }
}

sub on_tree_ctrl_workspace_projects_menu
{
    my ($self, $event) = @_;

    my $root_item = $self->{tree_ctrl_workspace_projects}->GetRootItem();

    my $item = $event->GetItem();

    if ($self->{tree_ctrl_workspace_projects}->GetItemParent($item) == $root_item)
    {
        my $text = $self->{tree_ctrl_workspace_projects}->GetItemText($item);

        my ($project_name, $version) = $text =~ /(.*)-(\d+\.\d+\.\d+)/;

        foreach my $dep (@{$self->{workspace_projects}})
        {
            if ($dep->{name} eq $project_name)
            {
                my $menuPopUp = Wx::Menu->new();

                $self->{workspace_project_to_show} = $dep;
                $menuPopUp->Append(SET_AS_WORKING_PROJECT, "Set as working project");
                $menuPopUp->Append(SHOW_DEPENDENCIES_ACCORDING_TO_TYPES, "Show dependencies according to type");
                $menuPopUp->Append(REMOVE_FROM_WORKSPACE, "Remove from workspace");
                $menuPopUp->Append(GENERATE_SELECTED_PROJECTS, "Generate selected projects only");
                $self->{tree_ctrl_workspace_projects}->PopupMenu($menuPopUp, $event->GetPoint());
            }
        }
    }
}

sub on_tree_ctrl_runtime_menu
{
    my ($self, $event) = @_;

    my @selections = $self->{tree_ctrl_runtime}->GetSelections();

    if (scalar(@selections) == 0)
    {
        return;
    }

    $self->get_runtime_dependencies_to_remove();

    my $menuPopUp = Wx::Menu->new();
    $menuPopUp->Append(REMOVE_RUNTIME_FROM_WORKSPACE, "Remove");
    $self->{tree_ctrl_runtime}->PopupMenu($menuPopUp, $event->GetPoint());
}

sub on_tree_ctrl_runtime_in_workspace_menu
{
    my ($self, $event) = @_;

    my @selections = $self->{tree_ctrl_runtime_in_workspace}->GetSelections();

    if (scalar(@selections) == 0)
    {
        return;
    }

    $self->get_runtime_in_workspace_to_remove();

    my $menuPopUp = Wx::Menu->new();
    $menuPopUp->Append(REMOVE_RUNTIME_IN_WORKSPACE, "Remove");
    $self->{tree_ctrl_runtime_in_workspace}->PopupMenu($menuPopUp, $event->GetPoint());
}

sub on_dependency_static
{
    my ($self, $event) = @_;

    my $change = 0;
    foreach my $x (@{$self->{dependencies_to_take_action_on}})
    {
        if ($x->{type} == 5)
        {
            next;
        }

        $change = $self->update_working_project_dependency_type($x->{name}, 5, "static", $x);
    }

    if ($change)
    {
        $self->save_working_project(0);

        $self->fill_tree_working();

        $self->validate();
    }
}

sub on_dependency_dynamic
{
    my ($self, $event) = @_;

    my $change = 0;
    foreach my $x (@{$self->{dependencies_to_take_action_on}})
    {
        if ($x->{type} == 6)
        {
            next;
        }

        $change = $self->update_working_project_dependency_type($x->{name}, 6, "dynamic", $x);
    }

    if ($change)
    {
        $self->save_working_project(0);

        $self->fill_tree_working();

        $self->validate();
    }
}

sub on_dependency_remove
{
    my ($self, $event) = @_;

    $self->remove_working_project_dependencies($self->{working_project_tree});

    $self->validate();
}

sub on_workspace_projects_menu_show_dependencies_according_to_types
{
    my ($self, $event) = @_;

    $self->show_workspace_project_side();
}

sub on_workspace_projects_menu_set_as_working_project
{
    my ($self, $event) = @_;

    $self->load_working_project();
}

sub on_workspace_projects_menu_remove_from_workspace
{
    my ($self, $event) = @_;

    if ($self->remove_from_workspace())
    {
        $self->validate();
    }
}

sub on_runtime_projects_menu_remove_from_workspace
{
    my ($self, $event) = @_;

    if ($self->remove_module_from_runtime())
    {
        $self->validate();
    }
}

sub on_runtime_in_workspace_menu_remove
{
    my ($self, $event) = @_;

    if ($self->remove_from_runtime_in_modules())
    {
        $self->validate();
    }
}

sub on_workspace_projects_menu_generate_selected_projects
{
    my ($self, $event) = @_;

    my $wait = Wx::BusyCursor->new();

    my $tree_ctrl = $self->{tree_ctrl_workspace_projects};

    my @selections = $tree_ctrl->GetSelections();

    if (scalar(@selections) == 0)
    {
        Wx::MessageBox("No selection");
        return;
    }

    foreach my $sel (@selections)
    {
        my $sel_text = $tree_ctrl->GetItemText($sel);
        my ($project_name) = $sel_text =~ /(.*)-/;

        my $env_var_id = "\$(" . uc($project_name) . "_PRJ_ROOT)";
        my $path = $env_var_id;
        if (!DPOEnvVars::expand_env_var(\$path))
        {
            DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$env_var_id]);
            return;
        }

        my $proj;
        $self->get_project($project_name, \$proj);

        my $dpo_action_prepare = DPOActions->new(
                            0, # any
                            $self);

        if (!$dpo_action_prepare->prepare_mpc_files($proj))
        {
            DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Failed to prepare mpb file"]);
            return;
        }

        my $mpc_project_type = $self->{combo_box_toolchain}->GetValue();

        my $mpc_name_modifier_option = "-name_modifier *-" .
                                        $mpc_project_type .
                                        " -apply_project";

        my $arch = $self->{combo_box_arch}->GetValue();
        if ($^O =~ /Win/)
        {
            if ($arch eq "i686")
            {
                $arch = "Win32";
            }
            else
            {
                $arch = "x64";
            }
        }

        my $value_template = "-value_template platforms=$arch";

        my $actions = DPOActions->new(
                            DPOActions::ACTION_VALIDATE, # any
                            $self);

        my @processed_mpc_includes;
        my @mpc_includes=();
        if (!$actions->get_mpc_includes_for_mwc($proj, \@processed_mpc_includes, \@mpc_includes))
        {
            DPOLog::report_msg(DPOEvents::GET_MPC_INCLUDES_FOR_MWC_FAILURE, [$proj->{name}]);
            return;
        }

        my $includes = "";
        foreach my $mpc_include (@mpc_includes)
        {
            my ($inc) = $mpc_include =~ /\"(.*)\"/;

            if (!DPOEnvVars::expand_env_var(\$inc))
            {
                DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$inc]);
            }

            $includes .= " -include $inc";
        }

        my $mpc_env_var_id = "\$(MPC_ROOT)";
        my $mpc_path = $mpc_env_var_id;
        if (DPOEnvVars::expand_env_var(\$mpc_path))
        {
            my $cmd = "$mpc_path/mpc.pl -type".
                                " $mpc_project_type".
                                " -noreldefs".
                                " $mpc_name_modifier_option".
                                " $value_template".
                                " $includes" .
                                " $project_name.mpc";

            my $cwd = Cwd::getcwd();
            chdir("$path/src");

            my $mpc_ok = 1;
            print "\n********** MPC **********\n";
            print "$cmd\n";
            my $output = `$cmd 2>&1`;
            if ($output !~ "Generation Time:"
                || $output =~ /Skipping/)
            {
                print $output;
                $mpc_ok = 0;
            }
            print "*************************\n";

            chdir($cwd);

            if (!$mpc_ok)
            {
                DPOLog::report_msg(DPOEvents::MPC_FAILURE, []);
                return;
            }
        }
    }

    Wx::MessageBox("Project generation done");
}

sub on_combo_box_workspaces_text
{
    my ($self, $event) = @_;

    $self->{button_workspace_open}->SetDefault();

    return;

    # wxGlade: DPOPanelProduct::on_combo_box_workspaces_text <event_handler>
    warn "Event handler (on_combo_box_workspaces_text) not implemented";
    $event->Skip;
    # end wxGlade
}



sub on_combo_box_product_text
{
    my ($self, $event) = @_;

    $self->{button_product_open}->SetDefault();

    return;

    # wxGlade: DPOPanelProduct::on_combo_box_product_text <event_handler>
    warn "Event handler (on_combo_box_product_text) not implemented";
    $event->Skip;
    # end wxGlade
}



sub on_button_layers
{
    my ($self, $event) = @_;

    my $env_var_id = "\$(" . uc($self->{working_project}->{name}) . "_PRJ_ROOT)";
    my $project_path = $env_var_id;
    if (!DPOEnvVars::expand_env_var(\$project_path))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$env_var_id]);
        return;
    }

    my $dlg = DPOLayersDlg->new(
        $project_path,
        $self,
        undef,
        -1,
        "",
        Wx::wxDefaultPosition,
        Wx::wxDefaultSize,
        Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

    if ($dlg->ShowModal() == Wx::wxID_OK)
    {
    }

    $dlg->Destroy();

    $self->fill_tree_workspace();
    $self->fill_tree_working();

    return;

    # wxGlade: DPOPanelProduct::on_button_layers <event_handler>
    warn "Event handler (on_button_layers) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_recall
{
    my ($self, $event) = @_;

    my $frame_recalls = DPOFrameRecalls->new(
                    $self->{recalls},
                    $self->{button_recalls},
                    undef,
                    -1,
                    "",
                    Wx::wxDefaultPosition,
                    Wx::wxDefaultSize,
                    Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL );

    $frame_recalls->Show();

    return;

    # wxGlade: DPOPanelProduct::on_button_recall <event_handler>
    warn "Event handler (on_button_recall) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_ide
{
    my ($self, $event) = @_;

    if ($^O =~ /Win/)
    {
        my $toolchain = $self->{combo_box_toolchain}->GetValue();
        if ($toolchain eq "")
        {
            Wx::MessageBox("Toolchain not selected");
            return;
        }

        my ($version) = uc($toolchain) =~ /VC(.*)/;

        my $env_var_id = "\$(VS" . $version . "0COMNTOOLS)";
        my $devenv_path = $env_var_id;
        if (!DPOEnvVars::expand_env_var(\$devenv_path))
        {
            DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, [$env_var_id]);
            return;
        }

        $devenv_path =~ s/\\/\//g;
        if ($devenv_path !~ /\/$/)
        {
            $devenv_path .= "/";
        }
        my $vcvars32_bat_cmd = "$devenv_path../../VC/" . "vcvarsall.bat";

        $vcvars32_bat_cmd = "c:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\vcvarsall.bat";


        $devenv_path = "$devenv_path../IDE/devenv";
        my $params = "$self->{workspace_path}/$self->{workspace_name}" . "_$toolchain.sln";

        $params =~ s/\//\\/g;

        my @cmd;
        push(@cmd, $vcvars32_bat_cmd);
        push(@cmd, "&&");
        push(@cmd, $devenv_path);
        push(@cmd, $params);
        #~ system(@cmd);

        my $explorer = "explorer /select,$params";
        system($explorer);
    }

    return;

    # wxGlade: DPOPanelProduct::on_button_ide <event_handler>
    warn "Event handler (on_button_ide) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_local_env_var
{
    my ($self, $event) = @_;

    Wx::MessageBox("TO_DO");

    return;

    # wxGlade: DPOPanelProduct::on_button_local_env_var <event_handler>
    warn "Event handler (on_button_local_env_var) not implemented";
    $event->Skip;
    # end wxGlade
}

# end of class DPOPanelProduct

1;

