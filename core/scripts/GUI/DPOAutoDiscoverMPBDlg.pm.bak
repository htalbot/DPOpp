use lib $ENV{DPO2_CORE_ROOT} . "/scripts";

# generated by wxGlade 0.6.8 on Mon Oct 19 06:41:19 2015
#
# To get wxPerl visit http://wxPerl.sourceforge.net/
#

use Wx 0.15 qw[:allclasses];
use strict;
use File::Copy;
use List::MoreUtils;
use DPOEvents;
use DPOReplaceMPBDlg;

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

package ListItemIdType;

sub new
{
    my ($class,
        $id,
        $type) = @_;

    my $self =
    {
        id => $id,
        type => $type
    };

    bless($self, $class);

    return $self;
}

1;

package Association;

sub new
{
    my ($class,
        $lib_id,
        $mpb) = @_;

    my $self =
    {
        lib_id => $lib_id,
        mpb => $mpb
    };

    bless($self, $class);

    return $self;
}

1;

package DPOAutoDiscoverMPBDlg;

use Wx qw[:everything];
use base qw(Wx::Dialog);
use strict;
use Wx::Locale 'gettext' => '_T', 'gettext_noop' => 'gettext_noop';

use constant
{
    MENU_CREATE_EDIT_MPB => 0,
    MENU_DEBUG => 1,
    MENU_RELEASE => 2,
    MENU_DEBUG_RELEASE => 3,
    MENU_ASSOCIATE_MPB => 4
};


sub new {
    my( $self, $non_mpc_compliant_node, $pool_path, $product_name, $product_version, $product_flavor, $parent, $id, $title, $pos, $size, $style, $name ) = @_;
    $parent = undef              unless defined $parent;
    $id     = -1                 unless defined $id;
    $title  = ""                 unless defined $title;
    $pos    = wxDefaultPosition  unless defined $pos;
    $size   = wxDefaultSize      unless defined $size;
    $name   = ""                 unless defined $name;

    # begin wxGlade: DPOAutoDiscoverMPBDlg::new
    $style = wxDEFAULT_DIALOG_STYLE 
        unless defined $style;

    $self = $self->SUPER::new( $parent, $id, $title, $pos, $size, $style, $name );
    $self->{splitter} = Wx::SplitterWindow->new($self, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_3D|wxSP_BORDER);
    $self->{splitter_pane_list_ctrl} = Wx::Panel->new($self->{splitter}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{list_ctrl_lib_id_mpb} = Wx::ListCtrl->new($self->{splitter_pane_list_ctrl}, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT|wxSUNKEN_BORDER);
    $self->{splitter_pane_file_content} = Wx::Panel->new($self->{splitter}, wxID_ANY, wxDefaultPosition, wxDefaultSize, );
    $self->{text_ctrl_mpb} = Wx::TextCtrl->new($self->{splitter_pane_file_content}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE|wxTE_READONLY);
    $self->{button_deduce} = Wx::Button->new($self->{splitter_pane_file_content}, wxID_ANY, _T("Deduce =>"));
    $self->{text_ctrl_mpb_name} = Wx::TextCtrl->new($self->{splitter_pane_file_content}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, );
    $self->{text_ctrl_mpb_file_name} = Wx::TextCtrl->new($self->{splitter_pane_file_content}, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, wxTE_READONLY);
    $self->{sizer_110_staticbox} = Wx::StaticBox->new($self->{splitter_pane_file_content}, wxID_ANY, _T("MPB file name") );
    $self->{button_ok} = Wx::Button->new($self->{splitter_pane_file_content}, wxID_ANY, _T("Ok"));
    $self->{button_cancel} = Wx::Button->new($self->{splitter_pane_file_content}, wxID_ANY, _T("Cancel"));
    $self->{sizer_mpb_staticbox_staticbox} = Wx::StaticBox->new($self->{splitter_pane_file_content}, wxID_ANY, _T("MPB file:") );
    $self->{button_predefined_mpbs} = Wx::Button->new($self, wxID_ANY, _T("Predefined MPBs..."));
    $self->{button_create_mpb_file} = Wx::Button->new($self, wxID_ANY, _T("Create/edit MPB file..."));
    $self->{sizer_mpb_define_staticbox} = Wx::StaticBox->new($self, wxID_ANY, _T("MPB") );
    $self->{button_return} = Wx::Button->new($self, wxID_ANY, _T("Return"));
    $self->{button_return_cancel} = Wx::Button->new($self, wxID_ANY, _T("Cancel"));

    $self->__set_properties();
    $self->__do_layout();

    Wx::Event::EVT_LIST_ITEM_DESELECTED($self, $self->{list_ctrl_lib_id_mpb}->GetId, \&on_list_ctrl_lib_id_mpb_deselected);
    Wx::Event::EVT_LIST_ITEM_SELECTED($self, $self->{list_ctrl_lib_id_mpb}->GetId, \&on_list_ctrl_lib_id_mpb_selected);
    Wx::Event::EVT_LIST_ITEM_RIGHT_CLICK($self, $self->{list_ctrl_lib_id_mpb}->GetId, \&on_list_ctrl_lib_id_mpb_item_right_click);
    Wx::Event::EVT_TEXT($self, $self->{text_ctrl_mpb}->GetId, \&on_text_ctrl_mpb_text);
    Wx::Event::EVT_BUTTON($self, $self->{button_deduce}->GetId, \&on_button_deduce);
    Wx::Event::EVT_TEXT($self, $self->{text_ctrl_mpb_name}->GetId, \&on_text_ctrl_mpb_name_text);
    Wx::Event::EVT_BUTTON($self, $self->{button_ok}->GetId, \&on_button_ok);
    Wx::Event::EVT_BUTTON($self, $self->{button_cancel}->GetId, \&on_button_cancel);
    Wx::Event::EVT_BUTTON($self, $self->{button_predefined_mpbs}->GetId, \&on_button_predefined_mpbs);
    Wx::Event::EVT_BUTTON($self, $self->{button_create_mpb_file}->GetId, \&on_button_create_mpb_file);
    Wx::Event::EVT_BUTTON($self, $self->{button_return}->GetId, \&on_button_return);
    Wx::Event::EVT_BUTTON($self, $self->{button_return_cancel}->GetId, \&on_button_return_cancel);

    # end wxGlade

    Wx::Event::EVT_MENU($self, MENU_CREATE_EDIT_MPB, \&on_menu_create_edit_mpb);
    Wx::Event::EVT_MENU($self, MENU_DEBUG, \&on_menu_debug);
    Wx::Event::EVT_MENU($self, MENU_RELEASE, \&on_menu_release);
    Wx::Event::EVT_MENU($self, MENU_DEBUG_RELEASE, \&on_menu_debug_release);
    Wx::Event::EVT_MENU($self, MENU_ASSOCIATE_MPB, \&on_menu_associate);

    $self->{associations} = [];

    $self->{leaves} = [];
    $non_mpc_compliant_node->get_leaves($self->{leaves});

    $self->{pool_path} = $pool_path;
    $self->{product_name} = $product_name;
    $self->{product_version} = $product_version;
    $self->{product_flavor} = $product_flavor;

    $self->{product_mpc_path} = "$self->{pool_path}/$self->{product_name}/$self->{product_flavor}/$self->{product_version}/MPC";

    unless (-d $self->{product_mpc_path})
    {
        if (!DPOUtils::make_path($self->{product_mpc_path}))
        {
            return 0;
        }
    }

    $self->existing_mpb_files(); # Defines existing_mpb_files internally.

    $self->{default_mpb_file_label} = $self->{sizer_mpb_staticbox}->GetStaticBox()->GetLabel();

    $self->create_list_ctrl();

    $self->{splitter}->SetMinimumPaneSize(50);
    my ($w, $h) = $self->GetSizeWH();
    $self->{splitter}->SetSashPosition(0.60 * $w);

    $self->enable_create_mpb_actions(0);

    $self->{mpb_text_changed} = 0;

    $self->{click_on_create_edit_button_text} = "To define this MPB, click on 'Create/edit MPB file...' button";

    my @new_mpbs;
    $self->assign_existing_mpb_to_non_mpc_compliant_libs($self->{product_mpc_path}, \@new_mpbs);

    #~ $self->determine_debug_release();

    return $self;

}


sub __set_properties {
    my $self = shift;
    # begin wxGlade: DPOAutoDiscoverMPBDlg::__set_properties
    $self->SetTitle(_T("Auto discover MPB"));
    $self->SetSize(Wx::Size->new(1000, 600));
    $self->{button_predefined_mpbs}->SetToolTipString(_T("Looks for MPBs from DPO templates"));
    $self->{button_create_mpb_file}->SetToolTipString(_T("Please, select libs on which MPB file is to be created/edited."));
    # end wxGlade

    $self->SetSize(Wx::Size->new(1000, 600));
}

sub __do_layout {
    my $self = shift;
    # begin wxGlade: DPOAutoDiscoverMPBDlg::__do_layout
    $self->{sizer_main} = Wx::BoxSizer->new(wxVERTICAL);
    $self->{sizer_actions} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_buildconfig_mpb} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_mpb_define_staticbox}->Lower();
    $self->{sizer_mpb_define} = Wx::StaticBoxSizer->new($self->{sizer_mpb_define_staticbox}, wxHORIZONTAL);
    $self->{sizer_mpb_staticbox_top} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_mpb_staticbox_staticbox}->Lower();
    $self->{sizer_mpb_staticbox} = Wx::StaticBoxSizer->new($self->{sizer_mpb_staticbox_staticbox}, wxVERTICAL);
    $self->{sizer_108} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_110_staticbox}->Lower();
    $self->{sizer_110} = Wx::StaticBoxSizer->new($self->{sizer_110_staticbox}, wxHORIZONTAL);
    $self->{sizer_listctrl_mpbfile} = Wx::BoxSizer->new(wxHORIZONTAL);
    $self->{sizer_listctrl_mpbfile}->Add($self->{list_ctrl_lib_id_mpb}, 2, wxALL|wxEXPAND, 10);
    $self->{splitter_pane_list_ctrl}->SetSizer($self->{sizer_listctrl_mpbfile});
    $self->{sizer_mpb_staticbox}->Add($self->{text_ctrl_mpb}, 1, wxEXPAND, 0);
    $self->{sizer_110}->Add($self->{button_deduce}, 0, wxLEFT, 3);
    $self->{sizer_110}->Add($self->{text_ctrl_mpb_name}, 1, wxLEFT, 3);
    $self->{sizer_110}->Add($self->{text_ctrl_mpb_file_name}, 1, 0, 0);
    $self->{sizer_mpb_staticbox}->Add($self->{sizer_110}, 0, wxEXPAND|wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{sizer_108}->Add($self->{button_ok}, 0, wxALL, 5);
    $self->{sizer_108}->Add($self->{button_cancel}, 0, wxALL, 5);
    $self->{sizer_mpb_staticbox}->Add($self->{sizer_108}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{sizer_mpb_staticbox_top}->Add($self->{sizer_mpb_staticbox}, 1, wxALL|wxEXPAND, 5);
    $self->{splitter_pane_file_content}->SetSizer($self->{sizer_mpb_staticbox_top});
    $self->{splitter}->SplitVertically($self->{splitter_pane_list_ctrl}, $self->{splitter_pane_file_content}, );
    $self->{sizer_main}->Add($self->{splitter}, 1, wxEXPAND, 0);
    $self->{sizer_mpb_define}->Add($self->{button_predefined_mpbs}, 0, wxLEFT, 3);
    $self->{sizer_mpb_define}->Add($self->{button_create_mpb_file}, 0, wxLEFT, 3);
    $self->{sizer_buildconfig_mpb}->Add($self->{sizer_mpb_define}, 1, wxALL|wxEXPAND, 5);
    $self->{sizer_main}->Add($self->{sizer_buildconfig_mpb}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->{sizer_actions}->Add($self->{button_return}, 0, wxALL, 5);
    $self->{sizer_actions}->Add($self->{button_return_cancel}, 0, wxALL, 5);
    $self->{sizer_main}->Add($self->{sizer_actions}, 0, wxALIGN_CENTER_HORIZONTAL, 0);
    $self->SetSizer($self->{sizer_main});
    $self->Layout();
    # end wxGlade
}

sub existing_mpb_files
{
    my ($self) = @_;

    $self->{product_mpc_path} = "$self->{pool_path}/$self->{product_name}/$self->{product_flavor}/$self->{product_version}/MPC";

    if (-d $self->{product_mpc_path})
    {
        my @content;
        if (DPOUtils::get_dir_content($self->{product_mpc_path}, \@content))
        {
            foreach my $elem (@content)
            {
                push(@{$self->{existing_mpb_files}}, $elem);
            }
        }
        else
        {
            Wx::MessageBox("Failed to get directory content of $self->{product_mpc_path}.", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }
    }
}

sub create_list_ctrl
{
    my ($self) = @_;

    my $col = Wx::ListItem->new();
    $col->SetId(0);
    $col->SetText("Library");
    $col->SetWidth(130);
    $self->{list_ctrl_lib_id_mpb}->InsertColumn(0, $col);

    $col = Wx::ListItem->new();
    $col->SetId(1);
    $col->SetText("Static/Dynamic");
    $col->SetWidth(100);
    $self->{list_ctrl_lib_id_mpb}->InsertColumn(1, $col);

    $col = Wx::ListItem->new();
    $col->SetId(2);
    $col->SetText("Debug/Release");
    $col->SetWidth(100);
    $self->{list_ctrl_lib_id_mpb}->InsertColumn(2, $col);

    $col = Wx::ListItem->new();
    $col->SetId(3);
    $col->SetText("MPB");
    $col->SetWidth(180);
    $self->{list_ctrl_lib_id_mpb}->InsertColumn(3, $col);

    $self->fill_list_ctrl();
}

sub fill_list_ctrl
{
    my ($self) = @_;

    $self->{list_ctrl_lib_id_mpb}->DeleteAllItems();

    my $i = 0;
    foreach my $elem (@{$self->{leaves}})
    {
        my $include = 1;

        if ($^O =~ /Win/)
        {
            if ("$elem->{id}" =~ /\.dll$/)  # TO_DO: linux ?
            {
                $include = 0;
            }
        }

        if ($include)
        {
            my $item = Wx::ListItem->new();

            $item->SetId($i);
            $item->SetText($elem->{id});
            $self->{list_ctrl_lib_id_mpb}->InsertItem( $item );
            $self->{list_ctrl_lib_id_mpb}->SetItem($i, 1, $elem->{type});

            my $build_config = "";
            if ($elem->{build_config} == DPOUtils::BUILD_CONFIG_DEBUG)
            {
                $build_config = "Debug";
            }
            if ($elem->{build_config} == DPOUtils::BUILD_CONFIG_RELEASE)
            {
                $build_config = "Release";
            }
            if ($elem->{build_config} == DPOUtils::BUILD_CONFIG_DEBUG_RELEASE)
            {
                $build_config = "Debug/Release";
            }

            $self->{list_ctrl_lib_id_mpb}->SetItem($i, 2, $build_config);
            $self->{list_ctrl_lib_id_mpb}->SetItem($i, 3, $elem->{mpb_file});

            $i++;
        }
    }
}

sub set_build_config
{
    my ($self, $build_config) = @_;

    my @selected_indexes;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $lib = $self->{list_ctrl_lib_id_mpb}->GetItemText($i);
        my $item_type = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 1);
        my $type = $item_type->GetText();

        foreach my $leaf (@{$self->{leaves}})
        {
            if ($leaf->{id} eq $lib
                && $leaf->{type} eq $type)
            {
                $leaf->{build_config} = $build_config;
            }
        }

        push(@selected_indexes, $i);
    }

    if (scalar(@selected_indexes) == 0)
    {
        Wx::MessageBox("No selection", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    $self->fill_list_ctrl();

    foreach my $sel (@selected_indexes)
    {
        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_DONTCARE);
            if ( $i == -1 )
            {
                last;
            }

            if ($i == $sel)
            {
                $self->{list_ctrl_lib_id_mpb}->SetItemState($i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);
                $self->{list_ctrl_lib_id_mpb}->EnsureVisible($i);
            }
        }
    }

    return;
}

sub exist_debug
{
    my ($self, $lib, $libs_ref) = @_;

    my ($fname) = $lib =~ /(.*)\..*/;

    foreach my $elem (@$libs_ref)
    {
        if ($elem->{id} =~ /(.*)\..*/)
        {
            my $elem_name = $1;
            if ($elem_name eq $fname . "d")
            {
                return 1;
            }
        }
    }

    return 0;
}

sub exist_release
{
    my ($self, $lib, $libs_ref) = @_;

    my ($fname) = $lib =~ /(.*)\..*/;

    foreach my $elem (@$libs_ref)
    {
        if ($elem->{id} =~ /(.*)\..*/)
        {
            my $elem_name = $1;
            if ($fname =~ /($elem_name)d$/)
            {
                return 1;
            }
        }
    }

    return 0;
}

sub is_build_config_set_for_all_libs
{
    my ($self) = @_;

    my $build_config_defined = 0;
    my $item_count = 0;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        my $item_build_config = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 2);
        my $build_config = $item_build_config->GetText();

        if ($build_config ne "")
        {
            $build_config_defined++;
        }

        $item_count++;
    }

    if ($build_config_defined != $item_count)
    {
        return 0;
    }

    return 1;
}

sub assign_existing_mpb_to_non_mpc_compliant_libs
{
    my ($self, $path, $new_mpbs_assigned_ref) = @_;

    unless (-d $path)
    {
        return 1;
    }

    my @content;
    if (DPOUtils::get_dir_content($path, \@content))
    {
        foreach my $elem (@content)
        {
            if ($elem =~ /(.*)\.mpb$/)
            {
                my $mpb_name = $1;

                my $complete = "$path/$elem";

                my @lines;
                if (DPOUtils::get_file_lines($complete, \@lines))
                {
                    foreach my $leaf (@{$self->{leaves}})
                    {
                        my ($lib_id) = $leaf->{id} =~ /(.*)\..*/;
                        foreach my $line (@lines)
                        {
                            chomp $line;

                            if ($line =~ /\Q$lib_id\E$/) # since the mpb file is to be used by client, we can use $ sign to compare.
                            {
                                my $assign = 1;

                                if ($leaf->{type} eq "static"
                                    && $mpb_name !~ /_static$/)
                                {
                                    $assign = 0;
                                }
                                if ($leaf->{type} eq "dynamic"
                                    && $mpb_name =~ /_static$/)
                                {
                                    $assign = 0;
                                }

                                if ($assign)
                                {
                                    $leaf->{mpb_file} = $mpb_name;
                                    if (!List::MoreUtils::any {$_ eq $complete} @{$new_mpbs_assigned_ref})
                                    {
                                        push(@{$new_mpbs_assigned_ref}, $complete);
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    DPOLog::report_msg(DPOEvents::GET_LINES_FROM_FILE_FAILURE, [$complete]);
                    return 0;
                }
            }
        }
    }

    return 1;
}

sub enable_create_mpb_actions
{
    my ($self, $enable) = @_;

    $self->{button_deduce}->Enable($enable);
    $self->{text_ctrl_mpb_name}->Enable($enable);
    $self->{text_ctrl_mpb_file_name}->Enable($enable);
    $self->{button_ok}->Enable($enable);
    $self->{button_cancel}->Enable($enable);

    $self->{text_ctrl_mpb}->SetEditable($enable);
    $self->{mpb_text_changed} = 0;
}

sub enable_mpb_actions
{
    my ($self, $enable) = @_;

    $self->{button_return}->Enable($enable);
}

sub enable_item_selection
{
    my ($self, $enable) =  @_;

    $self->{list_ctrl_lib_id_mpb}->Enable($enable);
}

sub update_mpb_file_name
{
    my ($self) = @_;

    my $text = $self->{text_ctrl_mpb_name}->GetValue() . "_dpo";

    if ($self->{create_mpb_for_static})
    {
        $text .= "_static";
    }

    $text .= ".mpb";

    $self->{text_ctrl_mpb_file_name}->SetValue($text);
}

sub predefined_mpbs_dir
{
    my ($self, $predefined_mpbs_dir_ref) =  @_;

    my $dpo_templates_root = "\$(DPO2_TEMPLATES_ROOT)";
    if (!DPOEnvVars::expand_env_var(\$dpo_templates_root))
    {
        DPOLog::report_msg(DPOEvents::ENV_VAR_NOT_DEFINED, ["DPO2_TEMPLATES_ROOT"]);
        return;
    }

    $$predefined_mpbs_dir_ref = $dpo_templates_root .= "/mpb";
}

sub save
{
    my ($self) = @_;

    my $file_name = $self->{text_ctrl_mpb_file_name}->GetValue();

    if ($file_name eq "")
    {
        Wx::MessageBox("No file name supplied", "", Wx::wxOK | Wx::wxICON_WARNING);
        return 0;
    }

    unless (-d $self->{product_mpc_path})
    {
        if (!DPOUtils::make_path($self->{product_mpc_path}))
        {
            Wx::MessageBox("Can't make path $self->{product_mpc_path}", "", Wx::wxOK | Wx::wxICON_WARNING);
            return 0;
        }
    }

    my $complete_file_name = "$self->{product_mpc_path}/$file_name";

    my $overwrite = 1;
    if (-f $complete_file_name)
    {
        my $rc = Wx::MessageBox(
                    "$complete_file_name exists.\n\nDo you want to overwrite it?",
                    "Saving MPB file",
                    Wx::wxYES_NO | Wx::wxICON_QUESTION);
        if ($rc == Wx::wxNO)
        {
            $overwrite = 0;
        }
    }

    if ($overwrite == 1)
    {
        if (!$self->{text_ctrl_mpb}->SaveFile($complete_file_name))
        {
            Wx::MessageBox("Failed to save $complete_file_name", "", Wx::wxOK | Wx::wxICON_ERROR);
            return 0;
        }
    }

    foreach my $leaf (@{$self->{leaves}})
    {
        foreach my $current (@{$self->{current_libs}})
        {
            foreach my $key (keys $current)
            {
                if ($leaf->{id} eq $key)
                {
                    my ($mpb_name) = $self->{text_ctrl_mpb_file_name}->GetValue() =~ /(.*)\..*/;
                    $leaf->{mpb_file} = $mpb_name;
                }
            }
        }
    }

    my $rc = Wx::MessageBox(
                "Do you want to save it as template?",
                "Saving MPB file as template",
                Wx::wxYES_NO | Wx::wxICON_QUESTION);
    if ($rc == Wx::wxYES)
    {
        my $predefined_mpbs_dir;
        if (!$self->predefined_mpbs_dir(\$predefined_mpbs_dir))
        {
            return 0;
        }

        my $dlg = Wx::DirDialog->new($self, "Predefined MPB", $predefined_mpbs_dir);
        my $rc = $dlg->ShowModal();
        if ($rc == Wx::wxID_OK)
        {
            my $path = $dlg->GetPath();
            $path =~ s/\\/\//g;

            $file_name = "$path/$file_name";

            if (-f $file_name)
            {
                my $rc = Wx::MessageBox(
                            "$file_name exists.\n\nDo you want to overwrite it?",
                            "Saving MPB file as template",
                            Wx::wxYES_NO | Wx::wxICON_QUESTION);
                if ($rc == Wx::wxNO)
                {
                    return 0;
                }
            }

            if (!$self->{text_ctrl_mpb}->SaveFile($file_name))
            {
                Wx::MessageBox("Failed to save $file_name", "", Wx::wxOK | Wx::wxICON_ERROR);
                return 0;
            }
        }
    }

    $self->fill_list_ctrl();

    return 1;
}

sub determine_debug_release
{
    my ($self) = @_;

    foreach my $leaf (@{$self->{leaves}})
    {
        if ($leaf->{build_config} == DPOUtils::BUILD_CONFIG_NOT_SET)
        {
            my $debug = $self->exist_debug($leaf->{id}, \@{$self->{leaves}});
            my $release = $self->exist_release($leaf->{id}, \@{$self->{leaves}});

            if ($debug && $release)
            {
                $leaf->{build_config} = DPOUtils::BUILD_CONFIG_DEBUG_RELEASE;
            }
            else
            {
                if ($debug)
                {
                    $leaf->{build_config} = DPOUtils::BUILD_CONFIG_RELEASE;
                }
                if ($release)
                {
                    $leaf->{build_config} = DPOUtils::BUILD_CONFIG_DEBUG;
                }
            }
        }
    }

    $self->fill_list_ctrl();
}


####EEEEEEEEEEEeeeeeeeeeevent handlers
sub on_button_predefined_mpbs
{
    my ($self, $event) = @_;

    my $predefined_mpbs_dir;
    if (!$self->predefined_mpbs_dir(\$predefined_mpbs_dir))
    {
        return;
    }

    if (-d "$predefined_mpbs_dir/$self->{product_name}")
    {
        $predefined_mpbs_dir .= "/$self->{product_name}";
    }

    my $dlg = Wx::DirDialog->new($self, "Predefined MPB directory", $predefined_mpbs_dir);
    my $rc = $dlg->ShowModal();
    if ($rc == Wx::wxID_OK)
    {
        my $predefined_mpb_dir = $dlg->GetPath();
        $predefined_mpb_dir =~ s/\\/\//g;

        my @new_mpbs;
        if (!$self->assign_existing_mpb_to_non_mpc_compliant_libs($predefined_mpb_dir, \@new_mpbs))
        {
            return;
        }

        # Before saving, get existing product MPC files to know if we have
        # to overwrite them with new ones.

        my @files_to_ask_to_replace;
        foreach my $new_mpb (@new_mpbs)
        {
            my ($mpb_name) = $new_mpb =~ /.*\/(.*)/;
            if (List::MoreUtils::any {$_ eq $mpb_name} @{$self->{existing_mpb_files}})
            {
                if (!List::MoreUtils::any {$_ eq $mpb_name} @files_to_ask_to_replace)
                {
                    push(@files_to_ask_to_replace, $mpb_name);
                }
            }
        }

        my @to_replace;
        if (scalar(@files_to_ask_to_replace) != 0)
        {
            # Ask to replace existing
            my $dlg = DPOReplaceMPBDlg->new(
                \@files_to_ask_to_replace,
                $predefined_mpb_dir,
                $self->{product_mpc_path},
                undef,
                -1,
                "",
                Wx::wxDefaultPosition,
                Wx::wxDefaultSize,
                Wx::wxDEFAULT_FRAME_STYLE|Wx::wxTAB_TRAVERSAL);

            $dlg->Centre();

            my $rc = $dlg->ShowModal();
            if ($rc == Wx::wxID_OK)
            {
                @to_replace = @{$dlg->{mpbs_to_replace}};
            }
            $dlg->Destroy();
        }

        foreach my $mpb (@to_replace)
        {
            print "To replace: $predefined_mpb_dir/$mpb ==> $self->{product_mpc_path}/$mpb\n";
        }

        foreach my $new_mpb (@new_mpbs)
        {
            my $copy = 0;

            my ($mpb) = $new_mpb =~ /.*\/(.*\.mpb)$/;

            if (!List::MoreUtils::any {$_ eq $mpb} @{$self->{existing_mpb_files}})
            {
                $copy = 1;
            }
            else
            {
                foreach my $rep (@to_replace)
                {
                    if ($rep eq $mpb)
                    {
                        $copy = 1;
                        last;
                    }
                }
            }

            if ($copy)
            {
                # Save new mpc file
                if (!File::Copy::copy("$predefined_mpb_dir/$mpb", "$self->{product_mpc_path}/$mpb"))
                {
                    DPOLog::report_msg(DPOEvents::GENERIC_ERROR, ["Failed to copy $predefined_mpb_dir/$mpb to $self->{product_mpc_path}/$mpb"]);
                }
            }
        }

        $self->fill_list_ctrl();
    }

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_button_predefined_mpbs <event_handler>
    warn "Event handler (on_button_predefined_mpbs) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_deduce
{
    my ($self, $event) = @_;

    if ($self->{list_ctrl_lib_id_mpb}->GetSelectedItemCount() == 0)
    {
        Wx::MessageBox("No libs selected.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    my @names;

    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $lib = $self->{list_ctrl_lib_id_mpb}->GetItemText($i);

        my $fname = $lib;
        if ($fname =~ /\//)
        {
            ($fname) = $lib =~ /.*\/(.*)/;
        }

        push(@names, $fname);
    }

    my %hash;

    foreach my $name (@names)
    {
        $hash{$name} = [];
        my @arr = split(//, $name);
        @{$hash{$name}} = @arr;
    }

    my $mpb_name = "";

    my $index = 0;
    my $continue = 1;
    while (1)
    {
        if (!$continue)
        {
            last;
        }

        my $c = "";
        foreach my $name (@names)
        {
            if ($index >= length($name))
            {
                $continue = 0;
                last;
            }

            if ($c eq "")
            {
                $c = $hash{$name}[$index];
                $mpb_name .= $c;

                if ($c eq ".")
                {
                    $continue = 0;
                }

                next;
            }
            else
            {
                if ($hash{$name}[$index] ne $c)
                {
                    $continue = 0;
                    last;
                }
                else
                {
                    #$mpb_name .= $c;
                    next;
                }
            }
        }

        $index++;
    }

    $mpb_name = substr($mpb_name, 0, length($mpb_name) - 1);

    $self->{text_ctrl_mpb_name}->ChangeValue($mpb_name);
    $self->update_mpb_file_name();

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_button_deduce <event_handler>
    warn "Event handler (on_button_deduce) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_create_mpb_file
{
    my ($self, $event) = @_;

    if ($self->{list_ctrl_lib_id_mpb}->GetSelectedItemCount() == 0)
    {
        Wx::MessageBox("No selection", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    $self->{current_libs} = [];

    my $relative_path = "";

    # Get the count of non empty build config and of static and dynamic
    my $sel_count = 0;
    my $static_count = 0;
    my $dynamic_count = 0;
    my $build_config_count = 0;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        $sel_count++;

        # Type
        my $item_type = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 1);
        my $type = $item_type->GetText();

        if ($type eq "dynamic")
        {
            $dynamic_count++;
        }

        if ($type eq "static")
        {
            $static_count++;
        }

        # Build config
        my $item_build_config = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 2);
        my $build_config = $item_build_config->GetText();

        if ($build_config ne "")
        {
            $build_config_count++;
        }
    }

    if ($build_config_count != $sel_count)
    {
        Wx::MessageBox("Build config not set for all selected items", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    my $debug_lib = "";
    my $release_lib = "";
    my @files;
    $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $item_lib = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 0);
        my $item_type = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 1);
        my $type = $item_type->GetText();
        my %current = ($item_lib->GetText(), $type);
        push(@{$self->{current_libs}}, \%current);

        my $lib_id;
        foreach my $leaf (@{$self->{leaves}})
        {
            foreach my $current (@{$self->{current_libs}})
            {
                my ($id, $type) = %$current;
                if ($leaf->{id} eq $id
                    && $leaf->{type} eq $type)
                {
                    my $product_pool_path = "$self->{pool_path}/$self->{product_name}/$self->{product_flavor}/$self->{product_version}";
                    my $parent_path = $leaf->get_parent_path();
                    if ($leaf->get_parent_path() =~ /(.*)\/$/)
                    {
                        $parent_path = $1;
                    }
                    (my $pre, $relative_path) = $parent_path =~ /($product_pool_path\/)(.*)/;
                    ($lib_id) = $id =~ /(.*)\..*/;
                    if ($leaf->{mpb_file} ne "")
                    {
                        if (!List::MoreUtils::any {$_ eq $leaf->{mpb_file}} @files)
                        {
                            push(@files, $leaf->{mpb_file});
                        }
                    }
                }
            }
        }

        my $item_build_config = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 2);
        my $build_config = $item_build_config->GetText();

        if ($build_config eq "Release")
        {
            $release_lib = $lib_id;
        }
        if ($build_config eq "Debug")
        {
            $debug_lib = $lib_id;
        }

        if ($type eq "dynamic")
        {
            $dynamic_count++;
        }

        if ($type eq "static")
        {
            $static_count++;
        }
    }

    if ($dynamic_count != 0
        && $static_count != 0)
    {
        Wx::MessageBox("Can't define the same MPB for static and dynamic library", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    if (scalar(@files) > 1)
    {
        my $text;
        my $sep = "";
        foreach my $file (@files)
        {
            $text .= "$sep$file";
            $sep = ", ";
        }

        Wx::MessageBox("Can't work on multiple MPB files: $text", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    $self->{create_mpb_for_static} = ($static_count != 0);

    if (scalar(@files) == 0)
    {
        my $text = "";
        my $env_var_id = uc($self->{product_name}) . "_ROOT";

        $text .= "// ***** Example *****\n";
        $text .= "// project: acelib {\n";
        $text .= "//   includes += \$(ABC_ROOT)/include\n";
        $text .= "//   libpaths += \$(ABC_ROOT)/lib\n";
        $text .= "//   ***********************************\n";
        $text .= "//   In the context of external products\n";
        $text .= "//   it is strongly recommended to include\n";
        $text .= "//   Debug and Release lit_libs entries.\n";
        $text .= "//   This way DPO can better manage MPB files.\n";
        $text .= "//   ***********************************\n";
        $text .= "//   Debug::lit_libs   += abcd\n";
        $text .= "//   Release::lit_libs += abc\n\n\n";

        $text .= "project {\n";
        $text .= "  includes += \$($env_var_id)/include\n";
        $text .= "  libpaths += \$($env_var_id)/$relative_path\n";
        $text .= "\n";
        $text .= "  specific(prop:windows) {\n";
        $text .= "    Debug::lit_libs   += $debug_lib\n";
        $text .= "    Release::lit_libs += $release_lib\n";
        $text .= "  } else {\n";
        $text .= "    // TO_DO: linux\n";
        $text .= "    // Debug::lit_libs += $release_lib\n";
        $text .= "    // Release::lit_libs += $release_lib\n";
        $text .= "    lit_libs += $release_lib\n";
        $text .= "  }\n";
        $text .= "}\n";

        $self->{text_ctrl_mpb}->SetValue($text);
    }
    else
    {
        my $file = "$self->{product_mpc_path}/$files[0].mpb";
        if (!$self->{text_ctrl_mpb}->LoadFile($file))
        {
            Wx::MessageBox("Failed to load $file", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }
    }

    $self->{mpb_text_changed} = 0;

    $self->enable_create_mpb_actions(1);
    $self->enable_mpb_actions(0);
    $self->enable_item_selection(0);

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_button_create_mpb_file <event_handler>
    warn "Event handler (on_button_create_mpb_file) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_lib_id_mpb_deselected
{
    my ($self, $event) = @_;

    if ($self->{list_ctrl_lib_id_mpb}->GetSelectedItemCount() == 1)
    {
        my $i = -1;
        for ( ;; )
        {
            $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                        Wx::wxLIST_NEXT_ALL,
                                        Wx::wxLIST_STATE_SELECTED);
            if ( $i == -1 )
            {
                last;
            }

            my $item_mpb = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 3);
            my $mpb_name = $item_mpb->GetText();

            my $file = "$self->{product_mpc_path}/$mpb_name.mpb";
            if (-f $file)
            {
                if (!$self->{text_ctrl_mpb}->LoadFile($file))
                {
                    Wx::MessageBox("Failed to load $file", "", Wx::wxOK | Wx::wxICON_ERROR);
                }

                $self->{mpb_text_changed} = 0;
            }
        }
    }


    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_list_ctrl_lib_id_mpb_deselected <event_handler>
    warn "Event handler (on_list_ctrl_lib_id_mpb_deselected) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_lib_id_mpb_selected
{
    my ($self, $event) = @_;

    my $index = $event->GetIndex();
    my $item_lib_id = $self->{list_ctrl_lib_id_mpb}->GetItem($index, 0);
    my $lib_id = $item_lib_id->GetText();
    my $item_type = $self->{list_ctrl_lib_id_mpb}->GetItem($index, 1);
    my $type = $item_type->GetText();

    foreach my $leaf (@{$self->{leaves}})
    {
        if ($leaf->{id} eq $lib_id)
        {
            if ($leaf->{type} eq $type)
            {
                $self->{sizer_mpb_staticbox}->GetStaticBox()->SetLabel("$self->{default_mpb_file_label} $leaf->{mpb_file}");
                my $file = "$self->{product_mpc_path}/$leaf->{mpb_file}.mpb";
                if (-f $file)
                {
                    if (!$self->{text_ctrl_mpb}->LoadFile($file))
                    {
                        Wx::MessageBox("Failed to load $file", "", Wx::wxOK | Wx::wxICON_ERROR);
                    }
                    $self->{mpb_text_changed} = 0;
                }
                else
                {
                    if ($self->{button_create_mpb_file}->IsEnabled())
                    {
                        $self->{text_ctrl_mpb}->SetValue($self->{click_on_create_edit_button_text});
                    }
                }
                last;
            }
        }
        else
        {
            $self->{text_ctrl_mpb}->SetValue("");
        }
    }

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_list_ctrl_lib_id_mpb_selected <event_handler>
    warn "Event handler (on_list_ctrl_lib_id_mpb_selected) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_return
{
    my ($self, $event) = @_;

    my $build_condif_set_count = 0;
    my $total = 0;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_DONTCARE);
        if ( $i == -1 )
        {
            last;
        }

        my $item_build_config = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 2);
        my $build_config = $item_build_config->GetText();

        if ($build_config ne "")
        {
            $build_condif_set_count++;
        }

        $total++;
    }

    if ($build_condif_set_count != $total)
    {
        Wx::MessageBox("Not all build config (Debug/Release) defined.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    $self->EndModal(Wx::wxID_OK);

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_button_return <event_handler>
    warn "Event handler (on_button_return) not implemented";
    $event->Skip;
    # end wxGlade
}

sub on_button_return_cancel
{
    my ($self, $event) = @_;

    $self->EndModal(Wx::wxID_CANCEL);

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_button_return_cancel <event_handler>
    warn "Event handler (on_button_return_cancel) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_menu_create_edit_mpb
{
    my ($self, $event) = @_;

    if ($self->{list_ctrl_lib_id_mpb}->GetSelectedItemCount() == 0)
    {
        Wx::MessageBox("No selection", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    $self->{current_libs} = [];

    my $relative_path = "";

    # Get the count of non empty build config and of static and dynamic
    my $sel_count = 0;
    my $static_count = 0;
    my $dynamic_count = 0;
    my $build_config_count = 0;
    my $dll_count = 0;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        $sel_count++;

        # Id
        my $item_lib_id = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 0);
        my $lib_id = $item_lib_id->GetText();
        if ($lib_id =~ /\.dll$/)
        {
            $dll_count++;
        }

        # Type
        my $item_type = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 1);
        my $type = $item_type->GetText();

        if ($type eq "dynamic")
        {
            $dynamic_count++;
        }

        if ($type eq "static")
        {
            $static_count++;
        }

        # Build config
        my $item_build_config = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 2);
        my $build_config = $item_build_config->GetText();

        if ($build_config ne "")
        {
            $build_config_count++;
        }
    }

    if ($dll_count != 0)
    {
        Wx::MessageBox("Not relevant to create MPB for DLLs. Instead, associate them.", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    if ($build_config_count != $sel_count)
    {
        Wx::MessageBox("Build config not set for all selected items", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    my $debug_lib = "";
    my $release_lib = "";
    my @files;
    $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        my $item_lib = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 0);
        my $item_type = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 1);
        my $type = $item_type->GetText();
        my %current = ($item_lib->GetText(), $type);
        push(@{$self->{current_libs}}, \%current);

        my $lib_id;
        foreach my $leaf (@{$self->{leaves}})
        {
            foreach my $current (@{$self->{current_libs}})
            {
                my ($id, $type) = %$current;
                if ($leaf->{id} eq $id
                    && $leaf->{type} eq $type)
                {
                    my $product_pool_path = "$self->{pool_path}/$self->{product_name}/$self->{product_flavor}/$self->{product_version}";
                    my $parent_path = $leaf->get_parent_path();
                    if ($leaf->get_parent_path() =~ /(.*)\/$/)
                    {
                        $parent_path = $1;
                    }
                    (my $pre, $relative_path) = $parent_path =~ /($product_pool_path\/)(.*)/;
                    ($lib_id) = $id =~ /(.*)\..*/;
                    if ($leaf->{mpb_file} ne "")
                    {
                        if (!List::MoreUtils::any {$_ eq $leaf->{mpb_file}} @files)
                        {
                            push(@files, $leaf->{mpb_file});
                        }
                    }
                }
            }
        }

        my $item_build_config = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 2);
        my $build_config = $item_build_config->GetText();

        if ($build_config eq "Release")
        {
            $release_lib = $lib_id;
        }
        if ($build_config eq "Debug")
        {
            $debug_lib = $lib_id;
        }

        if ($type eq "dynamic")
        {
            $dynamic_count++;
        }

        if ($type eq "static")
        {
            $static_count++;
        }
    }

    if ($dynamic_count != 0
        && $static_count != 0)
    {
        Wx::MessageBox("Can't define the same MPB for static and dynamic library", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    if (scalar(@files) > 1)
    {
        my $text;
        my $sep = "";
        foreach my $file (@files)
        {
            $text .= "$sep$file";
            $sep = ", ";
        }

        Wx::MessageBox("Can't work on multiple MPB files: $text", "", Wx::wxOK | Wx::wxICON_ERROR);
        return;
    }

    $self->{create_mpb_for_static} = ($static_count != 0);

    if (scalar(@files) == 0)
    {
        my $text = "";
        my $env_var_id = uc($self->{product_name}) . "_ROOT";

        $text .= "// ***** Example *****\n";
        $text .= "// project: acelib {\n";
        $text .= "//   includes += \$(ABC_ROOT)/include\n";
        $text .= "//   libpaths += \$(ABC_ROOT)/lib\n";
        $text .= "//   ***********************************\n";
        $text .= "//   In the context of external products\n";
        $text .= "//   it is strongly recommended to include\n";
        $text .= "//   Debug and Release lit_libs entries.\n";
        $text .= "//   This way DPO can better manage MPB files.\n";
        $text .= "//   ***********************************\n";
        $text .= "//   Debug::lit_libs   += abcd\n";
        $text .= "//   Release::lit_libs += abc\n\n\n";

        $text .= "project {\n";
        $text .= "  includes += \$($env_var_id)/include\n";
        $text .= "  libpaths += \$($env_var_id)/$relative_path\n";
        $text .= "\n";
        $text .= "  specific(prop:windows) {\n";
        $text .= "    Debug::lit_libs   += $debug_lib\n";
        $text .= "    Release::lit_libs += $release_lib\n";
        $text .= "  } else {\n";
        $text .= "    // TO_DO: linux\n";
        $text .= "    // Debug::lit_libs += $release_lib\n";
        $text .= "    // Release::lit_libs += $release_lib\n";
        $text .= "    lit_libs += $release_lib\n";
        $text .= "  }\n";
        $text .= "}\n";

        $self->{text_ctrl_mpb}->SetValue($text);
    }
    else
    {
        my $file = "$self->{product_mpc_path}/$files[0].mpb";
        if (!$self->{text_ctrl_mpb}->LoadFile($file))
        {
            Wx::MessageBox("Failed to load $file", "", Wx::wxOK | Wx::wxICON_ERROR);
            return;
        }
    }

    $self->{mpb_text_changed} = 0;

    $self->enable_create_mpb_actions(1);
    $self->enable_mpb_actions(0);
    $self->enable_item_selection(0);

    return;
}

sub on_menu_debug
{
    my ($self, $event) = @_;

    $self->set_build_config(DPOUtils::BUILD_CONFIG_DEBUG);

    return;
}

sub on_menu_release
{
    my ($self, $event) = @_;

    $self->set_build_config(DPOUtils::BUILD_CONFIG_RELEASE);

    return;
}

sub on_menu_debug_release
{
    my ($self, $event) = @_;

    $self->set_build_config(DPOUtils::BUILD_CONFIG_DEBUG | DPOUtils::BUILD_CONFIG_DEBUG_RELEASE);

    return;
}

sub on_menu_associate
{
    my ($self, $event) = @_;

    # Get mpb from non dll lib
    my $mpb_source;
    foreach my $association (@{$self->{associations}})
    {
        if ($association->{lib_id} =~ /\.lib$/)
        {
            $mpb_source = $association->{mpb};
            last;
        }
    }

    # Assign mpb to dll
    foreach my $association (@{$self->{associations}})
    {
        if ($association->{lib_id} =~ /\.dll$/)
        {
            foreach my $leaf (@{$self->{leaves}})
            {
                if ($leaf->{id} eq $association->{lib_id})
                {
                    $leaf->{mpb_file} = $mpb_source;
                }
            }
        }
    }

    $self->fill_list_ctrl();

    return;
}

sub on_text_ctrl_mpb_name_text
{
    my ($self, $event) = @_;

    $self->update_mpb_file_name();
    my $text = $self->{text_ctrl_mpb_name}->GetValue() . "_dpo";

    if ($self->{create_mpb_for_static})
    {
        $text .= "_static";
    }

    $text .= ".mpb";

    $self->{text_ctrl_mpb_file_name}->SetValue($text);

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_text_ctrl_mpb_name_text <event_handler>
    warn "Event handler (on_text_ctrl_mpb_name_text) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_ok
{
    my ($self, $event) = @_;

    if ($self->save())
    {
        $self->enable_item_selection(1);
        $self->enable_create_mpb_actions(0);
        $self->enable_mpb_actions(1);
        $self->{text_ctrl_mpb}->SetValue("");
        $self->{text_ctrl_mpb_name}->SetValue("");
        $self->{text_ctrl_mpb_file_name}->SetValue("");

        $self->{mpb_text_changed} = 0;
    }

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_button_ok <event_handler>
    warn "Event handler (on_button_ok) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_button_cancel
{
    my ($self, $event) = @_;

    if ($self->{mpb_text_changed})
    {
        my $rc = Wx::MessageBox(
                    "Want to stop edition (modifications will be lost) ?",
                    "Warning",
                    Wx::wxYES_NO | Wx::wxICON_QUESTION);
        if ($rc == Wx::wxNO)
        {
            return;
        }
    }

    $self->enable_item_selection(1);
    $self->enable_create_mpb_actions(0);
    $self->enable_mpb_actions(1);
    $self->{text_ctrl_mpb}->SetValue("");
    $self->{text_ctrl_mpb_name}->SetValue("");
    $self->{text_ctrl_mpb_file_name}->SetValue("");

    $self->{mpb_text_changed} = 0;

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_button_cancel <event_handler>
    warn "Event handler (on_button_cancel) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_text_ctrl_mpb_text
{
    my ($self, $event) = @_;

    my $text = $event->GetString();
    if ($text ne $self->{click_on_create_edit_button_text})
    {
        $self->{mpb_text_changed} = 1;
    }

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_text_ctrl_mpb_text <event_handler>
    warn "Event handler (on_text_ctrl_mpb_text) not implemented";
    $event->Skip;
    # end wxGlade
}


sub on_list_ctrl_lib_id_mpb_item_right_click
{
    my ($self, $event) = @_;

    $self->{associations} = [];

    my $dll_count = 0;
    my $lib_count = 0;
    my $i = -1;
    for ( ;; )
    {
        $i = $self->{list_ctrl_lib_id_mpb}->GetNextItem($i,
                                    Wx::wxLIST_NEXT_ALL,
                                    Wx::wxLIST_STATE_SELECTED);
        if ( $i == -1 )
        {
            last;
        }

        # Id
        my $item_lib_id = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 0);
        my $lib_id = $item_lib_id->GetText();
        if ($lib_id =~ /\.dll$/)
        {
            $dll_count++;
        }

        if ($lib_id =~ /\.lib$/)
        {
            $lib_count++;
        }

        my $lib = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 0)->GetText();
        my $mpb = $self->{list_ctrl_lib_id_mpb}->GetItem($i, 3)->GetText();
        my $association = Association->new($lib, $mpb);
        push(@{$self->{associations}}, $association);
    }

    my $different_mpb_source = 0;
    my @non_dll_mpbs;
    foreach my $association (@{$self->{associations}})
    {
        if ($association->{lib_id} =~ /\.lib$/)
        {
            if (!List::MoreUtils::any {$_ eq $association->{mpb}} @non_dll_mpbs)
            {
                push(@non_dll_mpbs, $association->{mpb});
                if (scalar(@non_dll_mpbs) > 1)
                {
                    $different_mpb_source = 1;
                    last;
                }
            }
        }
    }

    my $menuPopUp = Wx::Menu->new();
    if ($dll_count == 0)
    {
        $menuPopUp->Append(MENU_CREATE_EDIT_MPB, "Create/Edit MPB...");
    }
    $menuPopUp->Append(MENU_DEBUG, "Debug");
    $menuPopUp->Append(MENU_RELEASE, "Release");
    $menuPopUp->Append(MENU_DEBUG_RELEASE, "Debug/Release");
    if ($dll_count != 0
        && $lib_count != 0
        && !$different_mpb_source)
    {
        $menuPopUp->Append(MENU_ASSOCIATE_MPB, "Associate MPB");
    }
    $self->{list_ctrl_lib_id_mpb}->PopupMenu($menuPopUp, $event->GetPoint());

    return;

    # wxGlade: DPOAutoDiscoverMPBDlg::on_list_ctrl_lib_id_mpb_item_right_click <event_handler>
    warn "Event handler (on_list_ctrl_lib_id_mpb_item_right_click) not implemented";
    $event->Skip;
    # end wxGlade
}


# end of class DPOAutoDiscoverMPBDlg

1;

